<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陶同学&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/85a0cbb73a82a62a3f9fc11c5e6f5f5c</icon>
  <subtitle>hhh</subtitle>
  <link href="https://daixueshengt.github.io/atom.xml" rel="self"/>
  
  <link href="https://daixueshengt.github.io/"/>
  <updated>2024-10-26T14:35:34.720Z</updated>
  <id>https://daixueshengt.github.io/</id>
  
  <author>
    <name>陶同学</name>
    <email>2568510567@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sat Oct 26 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4e0.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4e0.html</id>
    <published>2024-10-26T14:16:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>注意: 合并必须从两个树的根节点开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上的方法修改了t1的结构，当然也可以不修改t1和t2的结构，重新定义一个树。</p><p>不修改输入树的结构，前序遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">// 重新定义新的节点，不修改原有两个树的结构</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>之前我们讲的都是普通二叉树，那么接下来看看二叉搜索树。</p><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p><p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p><p>递归法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) result = <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) result = <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><p>可以递归中序遍历将二叉搜索树转变成一个数组，然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p>注意是二叉搜索树，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p><p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p><p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line">TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>)&#123;       <span class="comment">// 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur; <span class="comment">// 记录前一个</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="企业项目性能优化方案"><a href="#企业项目性能优化方案" class="headerlink" title="企业项目性能优化方案"></a>企业项目性能优化方案</h1><ul><li>数据懒加载处理方案</li><li>图片懒加载处理方案</li><li>webpack打包体积过大与cdn优化处理方案</li><li>其他优化方案（gzip，http缓存，service worker）</li></ul><h2 id="数据懒加载"><a href="#数据懒加载" class="headerlink" title="数据懒加载"></a>数据懒加载</h2><p>一开始不获取数据，等到用户将要看到它的时候，再进行数据获取和展示</p><p>三个阶段</p><ul><li>不获取数据</li><li>用户将要看到</li><li>获取数据并渲染</li></ul><p>需要用到一个新的api intersectionObserver，监听某一个视窗是否被用户看到</p><p>因为原始这一块代码写的比较复杂</p><p>vueuse中有对intersectionObserver的封装，更方便使用，useIntersectionObserver</p><p>官方文档中都有示例代码，或者让gpt写示例代码</p><p>当判断视图可见后，再请求接口获取数据即可</p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>解决图片资源的防盗链  403   再index.html中 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 请求不添加请求来源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据懒加载，需要一个具体dom，而图片懒加载不好确定具体某一个dom</p><p>所有在vue3中，通过自定义指令，只需要图片懒加载的img标签处，写入该指令即可。</p><ol><li>构建自定义指令</li><li>利用IntersectionObserver完成检测</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgLazy=&#123;</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params">el</span>)&#123;</span><br><span class="line">        <span class="comment">// 图片懒加载：一开始不加载，等到将要看到时再加载</span></span><br><span class="line">        <span class="comment">// 1 缓存当前图片路径</span></span><br><span class="line">        <span class="keyword">const</span> cacheSrc = el.<span class="property">src</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(cacheSrc)</span><br><span class="line">        <span class="comment">// 2 把 img.src 变为占位图</span></span><br><span class="line">        el.<span class="property">src</span> = <span class="string">&#x27;https://....&#x27;</span></span><br><span class="line">        <span class="comment">// 3 监听将要看到</span></span><br><span class="line">        <span class="keyword">const</span> &#123;stop&#125; =<span class="title function_">useIntersectionObserver</span>(el,<span class="function">(<span class="params">[&#123;isIntersecting&#125;]</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isIntersecting)&#123;</span><br><span class="line">                <span class="comment">// 4 渲染图片</span></span><br><span class="line">                el.<span class="property">src</span> = cacheSrc</span><br><span class="line">                <span class="comment">// 5 停止监听</span></span><br><span class="line">                <span class="title function_">stop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包体积越来越大怎么办？"><a href="#项目打包体积越来越大怎么办？" class="headerlink" title="项目打包体积越来越大怎么办？"></a>项目打包体积越来越大怎么办？</h2><p>尤其是当导入的第三方包越来越多</p><p>首先需要了解一下 webpack配置 </p><p>externals 防止将某些import的包打包到bundle中，而是在运行时再去从外部获取这些扩展依赖</p><p>要想运行打包后的包，可以使用一个第三方包anywhere</p><p>然后就是CDN引入</p><p>打包的体积变小了，用户访问的项目体积还是没变小的</p><p>还有一些相对简单一些的优化方案</p><ol><li>gzip压缩：需要再nginx里面配置gzip压缩</li><li>http缓存：304状态码，表示所请求的资源没有被修改</li><li>service worker：js api 为当前网站提供有效的离线体验（存在一些兼容性问题，目前使用并不广泛）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;617-合并二叉树&quot;&gt;&lt;a href=&quot;#617-合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;617.合并二叉树&quot;&gt;&lt;/a&gt;617.合并二叉树&lt;/h1&gt;&lt;p&gt;给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Fri Oct 11 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d9.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d9.html</id>
    <published>2024-10-11T22:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-判断一个对象是否是数组"><a href="#1-判断一个对象是否是数组" class="headerlink" title="1.判断一个对象是否是数组"></a>1.判断一个对象是否是数组</h2><p>在 JavaScript 中，可以通过几种方法判断一个对象是否是数组。以下是常用的几种方法：</p><ol><li>Array.isArray(arr)</li></ol><ol><li>instanceof   arr instanceof Array</li><li>Object.prototype.toString.call()</li></ol><p><code>console.log(Object.prototype.toString.call(arr) === &#39;[object Array]&#39;); // 输出: true</code></p><p><code>typeof</code> 不能准确判断一个对象是否是数组，因为 <code>typeof</code> 对于数组的返回值也是 <code>&quot;object&quot;</code>。这是因为数组在 JavaScript 中被实现为对象。下面是一些示例，说明了这个问题：</p><h2 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2.跨域解决方案"></a>2.跨域解决方案</h2><p>跨域问题是由于浏览器的同源策略引起的</p><p>1.CORS 跨源资源共享</p><p>CORS 是一种机制，它使用 HTTP 头来告诉浏览器，允许来自不同源的请求。服务器通过设置特定的 HTTP 响应头（如 <code>Access-Control-Allow-Origin</code>）来允许跨域请求。</p><p>2.JSONP</p><p>JSONP 允许从服务器请求数据时，使用 <code>&lt;script&gt;</code> 标签来实现跨域请求。它仅支持 <code>GET</code> 请求。</p><p>3.代理服务器</p><p>通过在同一源的服务器上设置代理，将请求转发到目标服务器。前端代码发起请求到自己的服务器，由服务器转发请求到外部服务。</p><p>4.iframe + postMessage</p><p>通过使用 iframe 和 <code>postMessage</code> 方法实现跨域通信。可以在不同源之间安全地传递信息。</p><p>5.Nginx 反向代理</p><p>在 Nginx 中设置反向代理，将跨域请求代理到目标服务器。</p><h3 id="选择合适的解决方案"><a href="#选择合适的解决方案" class="headerlink" title="选择合适的解决方案"></a>选择合适的解决方案</h3><ul><li><strong>CORS</strong> 是现代的、最常用的解决方案，适用于大多数场景。</li><li><strong>JSONP</strong> 适合需要兼容旧浏览器和只支持 <code>GET</code> 请求的场合，但不推荐用于敏感数据。</li><li><strong>代理服务器</strong> 和 <strong>Nginx 反向代理</strong> 是后端解决方案，适合需要隐藏 API 关键点的情况。</li><li><strong>iframe + postMessage</strong> 是用于父子页面之间的跨域通信的解决方案。</li></ul><p>选择合适的方案应根据具体的应用场景和需求进行。</p><h2 id="3-CORS-的工作原理"><a href="#3-CORS-的工作原理" class="headerlink" title="3.CORS 的工作原理"></a>3.CORS 的工作原理</h2><p>CORS 通过 HTTP 头进行通信，以下是 CORS 工作的基本步骤：</p><ol><li>预检请求（Preflight Request）</li></ol><ul><li>在某些情况下（例如，使用了 <code>PUT</code> 或 <code>DELETE</code> 请求，或自定义请求头），浏览器会先发送一个 <code>OPTIONS</code> 请求，以确定实际请求是否安全。</li><li>服务器需返回适当的 CORS 头部以表明是否允许该请求。</li></ul><ol><li>实际请求</li></ol><p>如果预检请求获得了允许，浏览器会发送实际的请求（如 <code>GET</code>、<code>POST</code> 等）。</p><p>跨域中什么情况下需要预检请求？</p><p>在 CORS 中，预检请求（Preflight Request）是指在实际请求发送之前，浏览器先发送一个 <code>OPTIONS</code> 请求，以确认目标服务器是否允许实际请求。以下是需要发送预检请求的情况：</p><h3 id="1-使用非简单请求方法"><a href="#1-使用非简单请求方法" class="headerlink" title="1. 使用非简单请求方法"></a>1. 使用非简单请求方法</h3><p>非简单请求方法包括：</p><ul><li><code>PUT</code></li><li><code>DELETE</code></li><li><code>PATCH</code></li></ul><p>如果使用上述方法之一，则会触发预检请求。</p><h3 id="2-使用自定义请求头"><a href="#2-使用自定义请求头" class="headerlink" title="2. 使用自定义请求头"></a>2. 使用自定义请求头</h3><p>当请求中包含了以下自定义头部时，会触发预检请求：</p><ul><li>自定义的请求头（以 <code>X-</code> 开头的头部，或其他自定义头部）。</li><li>常见的自定义请求头，如 <code>Authorization</code>、<code>X-Requested-With</code>、<code>X-Custom-Header</code>。</li></ul><h3 id="3-Content-Type-为非简单类型"><a href="#3-Content-Type-为非简单类型" class="headerlink" title="3. Content-Type 为非简单类型"></a>3. Content-Type 为非简单类型</h3><p>对于 POST 请求，如果 <code>Content-Type</code> 设置为以下非简单类型，则会触发预检请求：</p><ul><li><code>application/json</code></li><li><code>application/xml</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul><p>简单请求的方法和类型如下：</p><ul><li><strong>简单请求方法</strong>：<ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul></li></ul><p><strong>简单请求的 Content-Type</strong>：</p><ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul><p>当浏览器发起跨域请求时，特别是在以下情况下，将发送 <code>OPTIONS</code> 预检请求：</p><ul><li>使用非简单请求方法（如 <code>PUT</code>、<code>DELETE</code>）。</li><li>使用自定义请求头。</li><li><code>Content-Type</code> 为非简单类型。</li><li>请求设置为携带用户凭证。</li></ul><h2 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4.垃圾回收"></a>4.垃圾回收</h2><p>垃圾回收（Garbage Collection，GC）是自动管理内存的一种机制，主要用于清理不再被引用的对象，以释放内存资源。下面是关于垃圾回收的一些要点：</p><h3 id="1-垃圾回收的目的"><a href="#1-垃圾回收的目的" class="headerlink" title="1. 垃圾回收的目的"></a>1. 垃圾回收的目的</h3><ul><li><strong>内存管理</strong>：自动回收不再使用的内存，防止内存泄漏。</li><li><strong>提高性能</strong>：通过释放内存，可以提高应用程序的性能，避免频繁的手动内存管理。</li></ul><h3 id="2-垃圾回收的工作原理"><a href="#2-垃圾回收的工作原理" class="headerlink" title="2. 垃圾回收的工作原理"></a>2. 垃圾回收的工作原理</h3><p>垃圾回收的工作原理通常基于以下几种算法：</p><h4 id="2-1-标记-清除算法（Mark-and-Sweep）"><a href="#2-1-标记-清除算法（Mark-and-Sweep）" class="headerlink" title="2.1. 标记-清除算法（Mark-and-Sweep）"></a>2.1. 标记-清除算法（Mark-and-Sweep）</h4><ul><li><strong>标记阶段</strong>：遍历所有可达的对象，标记为“活跃”。</li><li><strong>清除阶段</strong>：遍历所有对象，清除未标记的对象，释放其内存。  自动回收不再使用的对象。</li></ul><h4 id="2-2-复制算法（Copying）"><a href="#2-2-复制算法（Copying）" class="headerlink" title="2.2. 复制算法（Copying）"></a>2.2. 复制算法（Copying）</h4><ul><li>将内存分为两个区域：使用区和空闲区。</li><li>将存活对象从使用区复制到空闲区，然后清除使用区。</li></ul><h4 id="2-3-标记-整理算法（Mark-and-Compact）"><a href="#2-3-标记-整理算法（Mark-and-Compact）" class="headerlink" title="2.3. 标记-整理算法（Mark-and-Compact）"></a>2.3. 标记-整理算法（Mark-and-Compact）</h4><ul><li>类似于标记-清除算法，但在清除阶段会整理存活对象，以消除内存碎片。</li></ul><h4 id="2-4-引用计数（Reference-Counting）"><a href="#2-4-引用计数（Reference-Counting）" class="headerlink" title="2.4. 引用计数（Reference Counting）"></a>2.4. 引用计数（Reference Counting）</h4><ul><li>每个对象都有一个计数器，记录引用该对象的次数。</li><li>当计数器变为零时，说明该对象不再被引用，可以回收。</li></ul><h3 id="3-垃圾回收的触发"><a href="#3-垃圾回收的触发" class="headerlink" title="3. 垃圾回收的触发"></a>3. 垃圾回收的触发</h3><p>垃圾回收可以在以下情况下触发：</p><ul><li><strong>内存不足</strong>：当系统检测到可用内存不足时。</li><li><strong>显式请求</strong>：某些语言提供显式调用垃圾回收的方式（例如，<code>System.gc()</code>）。</li><li><strong>程序运行阶段</strong>：某些情况下，运行时环境会定期或不定期自动执行垃圾回收。</li></ul><h2 id="5-JS中的垃圾回收机制"><a href="#5-JS中的垃圾回收机制" class="headerlink" title="5.JS中的垃圾回收机制"></a>5.JS中的垃圾回收机制</h2><p>JavaScript 的垃圾回收主要使用标记-清除算法。其基本过程如下：</p><ul><li><strong>标记阶段</strong>：遍历所有可达的对象，标记为“活跃”。可达对象是从根对象（如全局对象和函数的局部变量）可以直接访问的对象。</li><li><strong>清除阶段</strong>：遍历所有对象，清除未标记的对象（即不再被引用的对象），释放其占用的内存。</li></ul><p>垃圾回收的触发</p><p>JavaScript 的垃圾回收是自动进行的，通常在以下情况下触发：</p><ul><li><strong>内存压力</strong>：当内存使用达到一定阈值时，垃圾回收器会自动运行。</li><li><strong>定期检查</strong>：引擎会定期检查未被引用的对象，以便进行垃圾回收。</li><li><strong>显式调用</strong>：虽然不推荐，但可以通过某些方法显式请求垃圾回收（如在 Node.js 中使用 <code>global.gc()</code>，前提是启动时使用 <code>--expose-gc</code> 标志）。</li></ul><p>常见的内存泄漏模式</p><p>虽然 JavaScript 提供了垃圾回收机制，但仍可能出现内存泄漏，常见的模式包括：</p><ul><li><strong>全局变量</strong>：未清理的全局变量会保持引用，导致内存无法释放。</li><li><strong>闭包</strong>：闭包保留了对外部变量的引用，如果不当使用，会导致无法释放这些变量。</li><li><strong>事件监听器</strong>：未移除的事件监听器仍会引用相关对象，导致内存泄漏。</li><li><strong>DOM引用</strong>：如果 JavaScript 保持对 DOM 元素的引用，可能导致页面中的元素无法被垃圾回收。</li></ul><h2 id="6-垃圾回收计数是怎么计数"><a href="#6-垃圾回收计数是怎么计数" class="headerlink" title="6.垃圾回收计数是怎么计数"></a>6.垃圾回收计数是怎么计数</h2><h3 id="1-引用计数（Reference-Counting）"><a href="#1-引用计数（Reference-Counting）" class="headerlink" title="1. 引用计数（Reference Counting）"></a>1. 引用计数（Reference Counting）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>引用计数机制</strong>：每个对象都有一个计数器，用于记录有多少个引用指向它。当对象被引用时，计数器增加；当引用被删除或赋值为其他对象时，计数器减少。</li><li><strong>当计数器为零时</strong>，说明没有任何引用指向该对象，此时该对象就可以被垃圾回收器回收。</li></ul><p><strong>循环引用问题</strong>：如果两个对象互相引用，即使它们不再被使用，其计数器也不会变为零，导致内存泄漏。</p><h3 id="2-标记-清除（Mark-and-Sweep）"><a href="#2-标记-清除（Mark-and-Sweep）" class="headerlink" title="2. 标记-清除（Mark-and-Sweep）"></a>2. 标记-清除（Mark-and-Sweep）</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>标记阶段</strong>：垃圾回收器从根对象（如全局对象）开始，遍历所有可达的对象并标记它们。</li><li><strong>清除阶段</strong>：遍历所有对象，删除未被标记的对象，释放其占用的内存。</li></ul><h2 id="7-webpack热更新"><a href="#7-webpack热更新" class="headerlink" title="7.webpack热更新"></a>7.webpack热更新</h2><p>Webpack 热更新（Hot Module Replacement, HMR）是一种功能，允许在开发过程中实时更新模块，而无需完全刷新整个页面。这种方式可以提高开发效率，保持应用的状态不变，极大地改善开发体验。</p><h2 id="8-http协商缓存"><a href="#8-http协商缓存" class="headerlink" title="8.http协商缓存"></a>8.http协商缓存</h2><p>HTTP 协商缓存是一种优化 Web 性能的技术，允许浏览器和服务器之间进行有效的资源管理。通过利用缓存，减少网络请求，从而提高页面加载速度。协商缓存主要分为两种类型：<strong>强缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h3><p>强缓存是指在客户端缓存资源的策略，当缓存未过期时，浏览器直接使用缓存，而不向服务器发送请求。强缓存通过 HTTP 响应头来控制，主要包括：</p><ul><li><strong><code>Cache-Control</code></strong>：用于设置缓存的有效期。例如：<ul><li><code>Cache-Control: max-age=3600</code> 表示资源可以被缓存 1 小时（3600 秒）。</li><li><code>Cache-Control: no-cache</code> 表示需要重新验证缓存（即使缓存存在）。</li></ul></li><li><strong><code>Expires</code></strong>：设置一个过期时间，表示资源的缓存有效时间。通常以 GMT 格式表示。例如：<ul><li><code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code></li></ul></li></ul><h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p>当强缓存失效后，浏览器会向服务器发送请求，服务器根据客户端的缓存信息决定是否使用缓存。协商缓存通过以下两个请求头来实现：</p><ul><li><strong><code>If-None-Match</code></strong>：包含缓存资源的 ETag（实体标签），服务器根据这个值来判断缓存资源是否被修改。</li><li><strong><code>If-Modified-Since</code></strong>：包含缓存资源的最后修改时间。服务器根据这个时间判断资源是否有更新。</li></ul><h3 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3. 服务器响应"></a>3. 服务器响应</h3><p>当接收到协商缓存请求时，服务器会根据以下情况做出响应：</p><ul><li><strong>304 Not Modified</strong>：表示资源未被修改，浏览器继续使用缓存。</li><li><strong>200 OK</strong>：表示资源已被修改，服务器返回新的资源和新的 <code>ETag</code>、<code>Last-Modified</code> 头部信息，浏览器更新缓存。</li></ul><h3 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. <strong>最佳实践</strong></h3><ul><li>如果资源的修改较频繁、或者需要精确控制缓存，使用 <strong><code>ETag</code></strong> 是最佳选择。</li><li>如果资源不常修改或性能要求较高，使用 <strong><code>Last-Modified</code></strong> 较为简单有效。</li><li>可以同时使用 <code>ETag</code> 和 <code>Last-Modified</code>，以提供更强的缓存验证机制，<code>ETag</code> 更精确，<code>Last-Modified</code> 作为后备方案。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-判断一个对象是否是数组&quot;&gt;&lt;a href=&quot;#1-判断一个对象是否是数组&quot; class=&quot;headerlink&quot; title=&quot;1.判断一个对象是否是数组&quot;&gt;&lt;/a&gt;1.判断一个对象是否是数组&lt;/h2&gt;&lt;p&gt;在 JavaScript 中，可以通过几种方法判断一</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Thu Oct 10 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d8.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d8.html</id>
    <published>2024-10-10T22:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码题1"><a href="#代码题1" class="headerlink" title="代码题1"></a>代码题1</h2><p>给定一个数列，其中可能有正数也可能有负数，我们的任务是找出其中连续的一个子数列(不允许空序列)，使它们的和尽可能小。<br>输入描述<br>第一行:一个数字N，N&lt;1000<br>第二行:N个数字，每个数字X，-10000&lt;x&lt;10000<br>输出描述<br>子数列最小和<br>示例<br>输入<br>8<br>-2 6 -1 -5 4 -7 -2 3<br>输出<br>-11</p><h3 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h3><p>暴力法是直接遍历所有可能的子数组并计算它们的和。这种方法简单，但时间复杂度是 O(N2)O(N^2)O(N2)，对于 N&lt;1000N &lt; 1000N&lt;1000 仍然可以接受。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_sum = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力法：遍历所有子数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            current_sum += arr[j];</span><br><span class="line">            min_sum = <span class="built_in">min</span>(min_sum, current_sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; min_sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><ul><li>遍历数组，使用一个变量 <code>current_min_sum</code> 来跟踪当前子数组的最小和。</li><li>使用另一个变量 <code>min_sum</code> 来存储全局的最小和。</li><li>如果 <code>current_min_sum</code> 大于当前元素加上 <code>current_min_sum</code>，则更新 <code>current_min_sum</code> 为当前元素。</li><li>每次更新 <code>min_sum</code> 为当前的 <code>current_min_sum</code> 和当前的 <code>min_sum</code> 中的较小值。</li></ul><p><code>current_min_sum</code> 记录当前子数组的最小和。</p><p><code>min_sum</code> 记录全局的最小子数组和。</p><p>每次更新 <code>current_min_sum</code> 时，选择当前元素和 <code>current_min_sum + 当前元素</code> 中的较小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> current_min_sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min_sum = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组求最小子数组和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 选择继续累加或从当前元素重新开始</span></span><br><span class="line">        current_min_sum = <span class="built_in">min</span>(arr[i], current_min_sum + arr[i]);</span><br><span class="line">        <span class="comment">// 更新全局最小值</span></span><br><span class="line">        min_sum = <span class="built_in">min</span>(min_sum, current_min_sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; min_sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力法适用于小规模数据，但对于更大的数据集性能不佳。<br>动态规划是更高效的方案，具有 O(N) 的复杂度。</p><h2 id="http-缓存机制-强制缓存-对比缓存"><a href="#http-缓存机制-强制缓存-对比缓存" class="headerlink" title="http 缓存机制(强制缓存/对比缓存)"></a>http 缓存机制(强制缓存/对比缓存)</h2><p>http报文就是浏览器和服务器间通信时发送及响应的数据块</p><p>浏览器向服务器请求数据，发送请求（request）报文</p><p>服务器向浏览器返回数据，返回响应（response）报文</p><p>报文信息主要分为两部分：</p><ol><li>包含属性的首部header —- 附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中</li><li>包含数据的主体部分（body）—- http请求真正想要传输的部分</li></ol><p>为什么需要使用缓存？</p><p>HITP 缓存机制作为 web 性能优化的重要手段，它可以通过复用获取过的资源，降低服务器压力、减少等待时间、节约网络流量</p><p>缓存规则解析</p><p>为了方便理解，我们认为浏览器提供了一个<strong>缓存数据库</strong>，用于存储缓存数据和信息</p><p>在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>在强制缓存规则下 ，分为缓存命中，和缓存未命中</p><p>缓存命中，直接从缓存数据库中去缓存数据</p><p>缓存未命中，先是去缓存数据库中访问，发现缓存数据失效，然后服务器往服务器发送请求数据，服务器返回数据和缓存规则到客户端，客户端获得数据的同时，将数据和缓存规则存入缓存系统中。</p><p>强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，浏览器是如何判断缓存数据是否失效呢?</p><p>在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p><p>对于强制缓存来说，响应header中会有两个字段来标明失效规则(Expires/Cache-Control)使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况:取资源是是from disk cache</p><h3 id="对比缓存（协商缓存）"><a href="#对比缓存（协商缓存）" class="headerlink" title="对比缓存（协商缓存）"></a>对比缓存（协商缓存）</h3><p>与强缓存最主要的区别是，不管缓存是否命中，都会向服务器发送请求</p><p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。</p><p>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p><p>PLUS：</p><p>使用命令上次gitee</p><blockquote><p>注意：第一次上传的时候，不要有readme（和仓库里面同名的文件）</p></blockquote><ul><li>git init 创建仓库</li><li>git remote add origin 具体仓库地址</li><li>git push origin master</li><li>git add .</li><li>git commit -m “first commit”</li><li>git push origin master</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码题1&quot;&gt;&lt;a href=&quot;#代码题1&quot; class=&quot;headerlink&quot; title=&quot;代码题1&quot;&gt;&lt;/a&gt;代码题1&lt;/h2&gt;&lt;p&gt;给定一个数列，其中可能有正数也可能有负数，我们的任务是找出其中连续的一个子数列(不允许空序列)，使它们的和尽可能小。&lt;br&gt;</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-10-9</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d7.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d7.html</id>
    <published>2024-10-09T15:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP2和HTTP3的区别"><a href="#1-HTTP2和HTTP3的区别" class="headerlink" title="1.HTTP2和HTTP3的区别"></a>1.HTTP2和HTTP3的区别</h2><p>HTTP/1.0、HTTP/2 和 HTTP/3（实际上是基于 QUIC 协议）</p><p>HTTP 协议经历了多次更新以适应不断增长的需求，提高性能、安全性和效率</p><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>特点：</p><ul><li>每个请求都需要建立一个新的 TCP 连接。</li><li>无状态：每个请求之间是独立的。</li><li>支持基本的身份验证和缓存机制。</li></ul><p>限制：由于每次请求都要重新建立连接，导致了较高的延迟和资源消耗。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>特点：</p><ul><li>引入了持久连接，允许在一个 TCP 连接上发送多个请求。</li><li>支持管道化，即客户端可以在一个连接中发送多个请求而无需等待每个请求的响应。</li><li>增加了 Host 头部，支持在同一 IP 地址上托管多个域名。</li></ul><p>改进：显著减少了因频繁建立连接而产生的开销，提高了网页加载速度。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>特点：</p><ul><li>多路复用（Multiplexing）：允许多个请求同时在一个连接上进行，减少了阻塞。</li><li>二进制分帧层（Binary Framing Layer）：将数据分割成更小的消息和帧，提高了效率。</li><li>服务器推送（Server Push）：服务器可以主动向客户端推送资源，而不需要客户端先发起请求。</li><li>请求优先级（Request Prioritization）：客户端可以指定哪些资源优先加载。</li></ul><p>安全性：虽然 HTTP/2 不强制要求加密，但大多数实现都默认使用 HTTPS（即 TLS 加密）。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>特点：</p><ul><li>基于 QUIC 协议：QUIC 是一个基于 UDP 的多路复用网络传输协议，旨在减少延迟并提供更好的拥塞控制。</li><li>减少握手延迟：QUIC 允许零往返时间（0-RTT）连接建立，这意味着如果客户端之前与服务器通信过，则可以立即开始发送数据。</li><li>更好的网络条件适应性：QUIC 包含先进的拥塞控制算法，可以更好地适应不同的网络环境。</li></ul><p>优势：相比 HTTP/2，HTTP/3 在减少延迟、提高可靠性和安全性方面有了进一步的提升。</p><p>演进过程：</p><ul><li><strong>从 HTTP/1.0 到 HTTP/1.1</strong>：主要是解决了连接效率的问题，通过引入持久连接和管道化来减少延迟。</li><li><strong>从 HTTP/1.1 到 HTTP/2</strong>：重点在于提高并发处理能力和优化数据传输效率，引入了多路复用等关键技术。</li><li><strong>从 HTTP/2 到 HTTP/3</strong>：目标是进一步降低延迟和提高网络稳定性，特别是针对移动网络和高延迟网络环境进行了优化。</li></ul><h2 id="2-强缓存与协商缓存"><a href="#2-强缓存与协商缓存" class="headerlink" title="2.强缓存与协商缓存"></a>2.强缓存与协商缓存</h2><p>缓存可以减少对服务器的请求次数，减轻服务器负载，加快页面加载速度。根据缓存策略的不同，通常可以分为强缓存（Strong Caching）和协商缓存（Negotiated Caching）两种类型。</p><h3 id="强缓存（Strong-Caching）"><a href="#强缓存（Strong-Caching）" class="headerlink" title="强缓存（Strong Caching）"></a>强缓存（Strong Caching）</h3><p>强缓存是指浏览器直接从本地缓存中读取资源，而不需要与服务器进行任何通信。当用户再次访问同一个资源时，如果该资源在强缓存的有效期内，浏览器会直接使用缓存中的版本，不会向服务器发送请求。</p><p>强缓存主要依赖于以下两个HTTP头部字段：</p><p><strong>Expires</strong>：这个字段指定了资源的过期时间，是一个绝对时间点。如果 <code>Cache-Control</code> 和 <code>Expires</code> 同时存在，<code>Cache-Control</code> 的优先级更高。</p><p><strong>Cache-Control</strong>：这个字段用于指定缓存策略</p><h3 id="协商缓存（Negotiated-Caching）"><a href="#协商缓存（Negotiated-Caching）" class="headerlink" title="协商缓存（Negotiated Caching）"></a>协商缓存（Negotiated Caching）</h3><p>协商缓存是指当强缓存失效后，浏览器会向服务器发送一个带有特定头部的请求，询问资源是否有更新。如果资源没有变化，服务器会返回一个 304 Not Modified 状态码，告诉浏览器继续使用缓存中的资源；如果有更新，服务器则会返回新的资源。协商缓存主要依赖于以下两个HTTP头部字段：</p><p><strong>ETag (Entity Tag)</strong>：服务器为每个资源生成一个唯一的标识符（ETag）。当资源发生变化时，ETag 也会相应改变。客户端在请求时可以通过 <code>If-None-Match</code> 头部发送上次获取的 ETag 值，服务器根据这个值判断资源是否已更改。</p><p><strong>Last-Modified / If-Modified-Since</strong>：服务器在响应头中包含 <code>Last-Modified</code> 字段，表示资源最后修改的时间。客户端在下次请求时通过 <code>If-Modified-Since</code> 头部发送这个时间戳，服务器根据这个时间戳判断资源是否已更改。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>强缓存</strong>：适用于那些很少或永远不会改变的静态资源，如图片、CSS 文件、JavaScript 文件等。通过设置较长的 <code>max-age</code>，可以显著减少这些资源的加载时间。</li><li><strong>协商缓存</strong>：适用于那些可能会定期更新的动态资源。虽然每次请求都会与服务器进行一次简短的通信，但只有当资源确实发生变化时才会重新下载，因此仍然可以有效减少带宽使用和服务器负载。</li></ul><h2 id="3-304状态码和403状态码"><a href="#3-304状态码和403状态码" class="headerlink" title="3. 304状态码和403状态码"></a>3. 304状态码和403状态码</h2><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><ul><li>304状态码表示客户端请求的资源未被修改。这通常发生在客户端使用了协商缓存机制的情况下。</li><li>当客户端请求一个资源时，如果该资源在服务器上的最后修改时间与客户端缓存中的资源相同，服务器会返回304状态码，而不是重新发送资源内容。</li></ul><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><ul><li>403状态码表示服务器理解请求客户端的请求，但拒绝执行此请求。通常是因为客户端没有足够的权限访问请求的资源。</li><li>这个状态码表明请求本身没有问题，但服务器出于某种原因不允许访问。</li></ul><p><strong>使用场景</strong>：</p><ul><li>客户端尝试访问受保护的资源，但没有提供正确的认证信息或权限不足。</li><li>服务器配置禁止访问某些目录或文件。</li><li>客户端的IP地址被服务器列入黑名单。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>304 Not Modified</strong>：表示资源未被修改，客户端可以从缓存中读取资源。</li><li><strong>403 Forbidden</strong>：表示客户端没有权限访问请求的资源。</li></ul><h2 id="4-cdn缓存"><a href="#4-cdn缓存" class="headerlink" title="4.cdn缓存"></a>4.cdn缓存</h2><p>CDN（Content Delivery Network，内容分发网络）是一种用于加速互联网内容传输的技术。通过在全球范围内分布的服务器节点，CDN 可以将内容缓存到离用户最近的节点，从而减少数据传输的延迟和带宽消耗，提高用户的访问速度和体验。</p><p><strong>内容上传</strong>：原始服务器（Origin Server）将内容上传到 CDN 的中心节点。内容可以是静态资源（如图片、CSS、JavaScript 文件）或动态内容（如视频流、API 响应）。</p><p><strong>内容分发</strong>：就近访问内容</p><p><strong>用户请求</strong>：用户向 CDN 发起请求，通常是通过 DNS 解析将请求重定向到最近的边缘节点。边缘节点接收到请求后，首先检查本地缓存中是否有请求的资源</p><p><strong>缓存命中</strong>：如果边缘节点的缓存中有请求的资源，并且资源未过期，边缘节点直接将资源返回给用户。这种情况下，请求不会到达原始服务器，减少了原始服务器的负载。</p><p><strong>缓存未命中</strong>：</p><ul><li>如果边缘节点的缓存中没有请求的资源或资源已过期，边缘节点会向原始服务器发起请求。</li><li>原始服务器返回资源后，边缘节点将其缓存起来，并返回给用户。</li><li>下次有相同的请求时，边缘节点可以直接从缓存中提供资源。</li></ul><p>CDN 缓存通过将内容缓存到离用户最近的边缘节点，显著提高了内容的访问速度和用户体验。合理的缓存策略和管理方法可以进一步优化 CDN 的性能，减少原始服务器的负载，提高整体系统的稳定性和可靠性。</p><h2 id="5-css盒模型"><a href="#5-css盒模型" class="headerlink" title="5.css盒模型"></a>5.css盒模型</h2><p>盒子由四个部分组成：内容区域（content）、内边距（padding）、边框（border）和外边距（margin）。</p><p>在标准盒模型（Standard Box Model）中，元素的总宽度和高度计算如下：</p><ul><li><strong>总宽度</strong> = <code>content width</code> + <code>padding left</code> + <code>padding right</code> + <code>border left</code> + <code>border right</code> + <code>margin left</code> + <code>margin right</code></li></ul><p>为了更方便地控制元素的尺寸，CSS 提供了一个 <code>box-sizing</code> 属性，可以改变盒模型的计算方式。</p><ul><li><strong>content-box</strong>（默认值）：使用标准盒模型，宽度和高度仅包括内容区域。</li><li><strong>border-box</strong>：宽度和高度包括内容区域、内边距和边框，但不包括外边距。</li></ul><h2 id="6-给行内元素设置margin和padding"><a href="#6-给行内元素设置margin和padding" class="headerlink" title="6.给行内元素设置margin和padding"></a>6.给行内元素设置margin和padding</h2><h3 id="行内元素（inline-elements）"><a href="#行内元素（inline-elements）" class="headerlink" title="行内元素（inline elements）"></a>行内元素（inline elements）</h3><p>行内元素（inline elements）和块级元素（block elements）在CSS中的行为有所不同。行内元素通常用于文本中的内容，如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code> 等。对于行内元素，设置 <code>margin</code> 和 <code>padding</code> 的效果有一些限制，但并不是完全没有作用。下面详细说明行内元素设置 <code>margin</code> 和 <code>padding</code> 的效果和用法。</p><ul><li>行内元素的水平方向 <code>margin</code>（<code>margin-left</code> 和 <code>margin-right</code>）是有效的，可以用来增加元素之间的间距。</li></ul><ul><li>行内元素的垂直方向 <code>margin</code>（<code>margin-top</code> 和 <code>margin-bottom</code>）通常不起作用，因为行内元素不会影响其所在行的高度。</li></ul><ul><li>行内元素的水平方向 <code>padding</code>（<code>padding-left</code> 和 <code>padding-right</code>）是有效的，可以用来增加元素内部的间距。</li><li>行内元素的垂直方向 <code>padding</code>（<code>padding-top</code> 和 <code>padding-bottom</code>）也是有效的，但它们不会增加元素的高度，而是会影响行高的计算。</li></ul><h3 id="行内块级元素（inline-block）"><a href="#行内块级元素（inline-block）" class="headerlink" title="行内块级元素（inline-block）"></a>行内块级元素（inline-block）</h3><p>如果你希望行内元素的行为更像块级元素，可以将它们的 <code>display</code> 属性设置为 <code>inline-block</code>。这样，行内元素就可以同时具有行内元素和块级元素的特性，包括垂直方向的 <code>margin</code> 和 <code>padding</code> 也会生效。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>行内元素</strong>：<ul><li>水平方向的 <code>margin</code> 和 <code>padding</code> 是有效的。</li><li>垂直方向的 <code>margin</code> 通常不起作用。</li><li>垂直方向的 <code>padding</code> 是有效的，但不会增加元素的高度，而是影响行高的计算。</li></ul></li><li><strong>行内块级元素（display: inline-block）</strong>：<ul><li>所有方向的 <code>margin</code> 和 <code>padding</code> 都是有效的。</li></ul></li></ul><p>通过合理使用 <code>display: inline-block</code>，你可以更灵活地控制行内元素的布局和间距。</p><h2 id="7-js数据类型"><a href="#7-js数据类型" class="headerlink" title="7.js数据类型"></a>7.js数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>Undefined</strong>  <strong>Null</strong> <strong>Boolean</strong> <strong>Number </strong> <strong>String</strong>  <strong>Symbol</strong>    <strong>BigInt</strong></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>Object</strong> <strong>Array</strong>  <strong>Function</strong>  <strong>Date</strong>  <strong>RegExp</strong> </p><p>JavaScript 的数据类型分为基本数据类型和引用数据类型。基本数据类型包括 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code> 和 <code>bigint</code>，引用数据类型包括 <code>object</code>、<code>array</code>、<code>function</code>、<code>date</code> 和 <code>regexp</code>。</p><h2 id="8-es6新增特性"><a href="#8-es6新增特性" class="headerlink" title="8.es6新增特性"></a>8.es6新增特性</h2><h3 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1. 块级作用域"></a>1. 块级作用域</h3><p><strong>let 和 const 关键字</strong>：</p><ul><li><code>let</code>：声明块级作用域的变量，避免了 <code>var</code> 的变量提升问题。</li><li><code>const</code>：声明块级作用域的常量，一旦赋值就不能再改变。</li></ul><h3 id="2-解构赋值（Destructuring-Assignment）"><a href="#2-解构赋值（Destructuring-Assignment）" class="headerlink" title="2. 解构赋值（Destructuring Assignment）"></a>2. 解构赋值（Destructuring Assignment）</h3><ul><li>从数组和对象中提取数据并赋值给变量，使代码更简洁。</li></ul><h3 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3.模板字符串（Template Literals）"></a>3.模板字符串（Template Literals）</h3><ul><li>使用反引号（`）来创建多行字符串，并嵌入表达式。</li></ul><h3 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. 默认参数（Default Parameters）</h3><ul><li>函数参数可以有默认值，如果调用时没有传入相应的参数，就使用默认值。</li></ul><h3 id="5-箭头函数（Arrow-Functions）"><a href="#5-箭头函数（Arrow-Functions）" class="headerlink" title="5.箭头函数（Arrow Functions）"></a>5.箭头函数（Arrow Functions）</h3><ul><li>简化函数的书写方式，没有自己的 <code>this</code> 上下文，继承外层函数的 <code>this</code> 值。</li></ul><h3 id="6-类（Classes）"><a href="#6-类（Classes）" class="headerlink" title="6. 类（Classes）"></a>6. 类（Classes）</h3><ul><li>提供了一种更清晰的面向对象编程方式，简化了构造函数和原型链的使用。</li></ul><h3 id="7-模块（Modules）"><a href="#7-模块（Modules）" class="headerlink" title="7. 模块（Modules）"></a>7. 模块（Modules）</h3><ul><li>支持模块化编程，可以导入和导出模块。</li></ul><h3 id="8-扩展运算符（Spread-Operator）"><a href="#8-扩展运算符（Spread-Operator）" class="headerlink" title="8. 扩展运算符（Spread Operator）"></a>8. 扩展运算符（Spread Operator）</h3><ul><li>用于展开数组或对象，方便操作和传递参数。</li></ul><h3 id="9-剩余参数（Rest-Parameters）"><a href="#9-剩余参数（Rest-Parameters）" class="headerlink" title="9. 剩余参数（Rest Parameters）"></a>9. 剩余参数（Rest Parameters）</h3><ul><li>用于收集函数中的多余参数，形成一个数组。</li></ul><h3 id="10-Set-和-Map"><a href="#10-Set-和-Map" class="headerlink" title="10. Set 和 Map"></a>10. Set 和 Map</h3><ul><li><strong>Set</strong>：表示一个值的集合，其中的值唯一且不重复。</li><li><strong>Map</strong>：表示一个键值对的集合，其中键的类型不受限制。</li></ul><h3 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. Promise</h3><ul><li>用于异步操作的处理，提供更清晰的错误处理和链式调用。</li></ul><h3 id="12-Symbol"><a href="#12-Symbol" class="headerlink" title="12. Symbol"></a>12. Symbol</h3><ul><li>表示独一无二的值，常用于对象属性的键，避免命名冲突。</li></ul><h3 id="13-Iterator-和-For-of-循环"><a href="#13-Iterator-和-For-of-循环" class="headerlink" title="13. Iterator 和 For-of 循环"></a>13. Iterator 和 For-of 循环</h3><ul><li><strong>Iterator</strong>：提供了一种统一的遍历接口。</li><li><strong>For-of 循环</strong>：用于遍历可迭代对象（如数组、字符串、Map、Set 等）。</li></ul><h3 id="14-Generator-函数"><a href="#14-Generator-函数" class="headerlink" title="14. Generator 函数"></a>14. Generator 函数</h3><ul><li>生成器函数可以暂停和恢复执行，提供了一种更灵活的异步编程方式。</li></ul><h2 id="9-深浅拷贝-以及实现的方式"><a href="#9-深浅拷贝-以及实现的方式" class="headerlink" title="9.深浅拷贝  以及实现的方式"></a>9.深浅拷贝  以及实现的方式</h2><h3 id="1-浅拷贝（Shallow-Copy）"><a href="#1-浅拷贝（Shallow-Copy）" class="headerlink" title="1. 浅拷贝（Shallow Copy）"></a>1. 浅拷贝（Shallow Copy）</h3><p>浅拷贝只复制对象的第一层属性，对于嵌套的对象或数组，它只是复制了引用，而不是实际的数据。因此，修改拷贝后的对象会影响到原对象。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>使用 Object.assign()</strong></p><p><strong>使用扩展运算符 …</strong></p><p><strong>使用 Array.prototype.slice() 或 Array.prototype.concat()</strong></p><h3 id="2-深拷贝（Deep-Copy）"><a href="#2-深拷贝（Deep-Copy）" class="headerlink" title="2.深拷贝（Deep Copy）"></a>2.深拷贝（Deep Copy）</h3><p>深拷贝会递归地复制对象的所有层级，确保拷贝后的对象与原对象完全独立，修改拷贝后的对象不会影响原对象。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>使用 JSON.parse() 和 JSON.stringify()</strong></p><ul><li>这是最简单的方法，但有一定的局限性，例如不能处理函数、循环引用和 <code>undefined</code>。</li></ul><p><strong>使用递归函数</strong></p><ul><li>这种方法可以处理更复杂的情况，包括函数、循环引用等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj; <span class="comment">// null or undefined</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="keyword">return</span> obj; <span class="comment">// 或者可以选择不复制函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj); <span class="comment">// 处理循环引用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      target[key] = <span class="title function_">deepCopy</span>(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125;, <span class="attr">d</span>: [<span class="number">3</span>, <span class="number">4</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title function_">deepCopy</span>(original);</span><br><span class="line"></span><br><span class="line">deepCopy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125;, d: [3, 4] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopy); <span class="comment">// &#123; a: 1, b: &#123; c: 3 &#125;, d: [3, 4] &#125;</span></span><br></pre></td></tr></table></figure><p><strong>使用第三方库</strong></p><ul><li>有许多第三方库提供了深拷贝的功能，如 <code>lodash</code> 的 <code>_.cloneDeep</code>。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>浅拷贝</strong>：只复制对象的第一层属性，对于嵌套的对象或数组，复制的是引用。修改拷贝后的对象可能会影响到原对象。</li><li>实现方式：<code>Object.assign()</code>、扩展运算符 <code>...</code>、<code>Array.prototype.slice()</code> 或 <code>Array.prototype.concat()</code>。</li><li><strong>深拷贝</strong>：递归地复制对象的所有层级，确保拷贝后的对象与原对象完全独立。修改拷贝后的对象不会影响原对象。</li><li>实现方式：<code>JSON.parse()</code> 和 <code>JSON.stringify()</code>、递归函数、第三方库（如 <code>lodash</code> 的 <code>_.cloneDeep</code>）。</li></ul><h2 id="10-实现promisify"><a href="#10-实现promisify" class="headerlink" title="10.实现promisify"></a>10.实现promisify</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **实现一个promisify()方法** </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promisify</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args,<span class="function">(<span class="params">err,reslut</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(reslut)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用promisify前</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用promisify后</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-HTTP2和HTTP3的区别&quot;&gt;&lt;a href=&quot;#1-HTTP2和HTTP3的区别&quot; class=&quot;headerlink&quot; title=&quot;1.HTTP2和HTTP3的区别&quot;&gt;&lt;/a&gt;1.HTTP2和HTTP3的区别&lt;/h2&gt;&lt;p&gt;HTTP/1.0、HTTP/</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-10-8</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d6.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d6.html</id>
    <published>2024-10-08T13:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-canvas实现贪吃蛇"><a href="#1-canvas实现贪吃蛇" class="headerlink" title="1.canvas实现贪吃蛇"></a>1.canvas实现贪吃蛇</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#mycanvas</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">100px</span> auto;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mycanvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> direction=<span class="number">2</span>;  <span class="comment">//方向 0表示左，1表示上，2表示右，3表示下</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">//计时器</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> len = <span class="number">10</span>; <span class="comment">//蛇的长度</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 蛇的初始位置</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> x=<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> y=<span class="number">8</span>; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> speed = <span class="number">100</span>;  <span class="comment">//速度</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> size = <span class="number">8</span>; <span class="comment">// 每一节蛇的大小</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> map=[]; <span class="comment">//用于存储蛇的运动轨迹</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 食物坐标</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> foodX;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> foodY;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">game</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span>=<span class="string">&#x27;green&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置运动方向进行绘制</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">switch</span>(direction)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">0</span>:</span></span><br><span class="line"><span class="language-javascript">            x=x-size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="language-javascript">            y=y-size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="language-javascript">            x=x+size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="language-javascript">            y=y+size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 边界碰撞检测</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(x&gt;=canvas.<span class="property">width</span> || x&lt;<span class="number">0</span> || y&gt;=canvas.<span class="property">height</span> || y&lt;<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;game over&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          location.<span class="title function_">reload</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 自身碰撞检测</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> carch = map.<span class="title function_">some</span>(<span class="function"><span class="params">ele</span>=&gt;</span>ele.<span class="property">x</span>===x&amp;&amp;ele.<span class="property">y</span>===y);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(carch)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;game over&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          location.<span class="title function_">reload</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(map.<span class="property">length</span>&gt;len)&#123; <span class="comment">//数据长度大于蛇的长度</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 删除数组中的第一个元素 并且 擦除画板该区域</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">let</span> first = map.<span class="title function_">shift</span>();</span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="title function_">clearRect</span>(first.<span class="property">x</span>,first.<span class="property">y</span>,size,size);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        map.<span class="title function_">push</span>(&#123;x,y&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(x,y,size,size);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console.log(map);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 判断蛇是否吃到食物</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(foodX==x&amp;&amp; foodY==y)&#123;</span></span><br><span class="line"><span class="language-javascript">          len++;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">getFood</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        foodX = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">50</span>)*<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript">        foodY = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">50</span>)*<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> has = map.<span class="title function_">some</span>(<span class="function"><span class="params">ele</span>=&gt;</span>ele.<span class="property">x</span>===foodX &amp;&amp; ele.<span class="property">y</span>===foodY);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(has)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span>=<span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(foodX,foodY,size,size);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      timer = <span class="built_in">setInterval</span>(game,speed);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 键盘时间用于改变方向</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">onkeyup</span>=<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(e.<span class="property">keyCode</span>&gt;=<span class="number">37</span> &amp;&amp; e.<span class="property">keyCode</span>&lt;=<span class="number">40</span>)</span></span><br><span class="line"><span class="language-javascript">          direction=e.<span class="property">keyCode</span>-<span class="number">37</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;mycanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串的排列"><a href="#2-字符串的排列" class="headerlink" title="2.字符串的排列"></a>2.字符串的排列</h2><p>详细描述<br>给你两个字符串 s1和s2，写一个函数来判断s2 是否包含 s1的排列。如果是，返回 true;否则，返回 false 。换句话说，s1的排列之一是 s2的子串 。<br>提示:<br>1&lt;= s1 .length, s2.length &lt;= 104。s1和 s2 仅包含小写字母<br>示例1<br>输入  “ab”,”eidbaooo”<br>输出 true<br>说明 s2 包含 s1的排列之一(“ba”)</p><p>可以使用滑动窗口和哈希计数的方法来解决</p><p>思路</p><ol><li>使用两个频率数组 <code>count1</code> 和 <code>count2</code> 来存储 <code>s1</code> 和 <code>s2</code> 中相应窗口内字符的频率。</li></ol><p><code>count1</code> 记录 <code>s1</code> 中每个字符的频率。</p><p><code>count2</code> 记录 <code>s2</code> 中当前窗口的字符频率。</p><ol><li>初始时，设置一个长度为 <code>s1.length()</code> 的窗口在 <code>s2</code> 上，然后滑动这个窗口检查 <code>count2</code> 是否和 <code>count1</code> 相等。 如果相等，说明当前窗口中的字符是 <code>s1</code> 的一个排列，返回 <code>true</code>。</li><li>如果整个 <code>s2</code> 都没有找到符合条件的子串，返回 <code>false</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">length</span>() &gt; s2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">count2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组 s1 和 s2 中的第一个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        count1[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否初始窗口匹配</span></span><br><span class="line">    <span class="keyword">if</span> (count1 == count2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在s2上进行窗口滑动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">length</span>(); i &lt; s2.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 增加新的字符到滑动窗口中</span></span><br><span class="line">        count2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="comment">// 移除旧的字符（窗口中的第一个）</span></span><br><span class="line">        count2[s2[i - s1.<span class="built_in">length</span>()] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (count1 == count2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;eidbaooo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkInclusion</span>(s1, s2)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-寻找目标值"><a href="#3-寻找目标值" class="headerlink" title="3.寻找目标值"></a>3.寻找目标值</h2><p>详细描述<br>m*n的二维数组 plants 记录了园林景观的植物排布情况，具有以下特性:<br>每行中，每棵植物的右侧相邻植物不矮于该植物;<br>每列中，每棵植物的下侧相邻植物不矮于该植物。<br>请判断 plants 中是否存在目标高度值 target.提示:<br>0&lt;=n&lt;=1000<br>0&lt;=m&lt;=1000<br>示例1<br>输入<br>[[2,3,6,8],[4,5,8,9],[5,9,10,12]],8<br>输出<br>true</p><p>这个问题的二维数组有行和列都递增的性质，可以使用一种高效的算法——从矩阵的右上角或者左下角开始搜索，以避免线性搜索。</p><p><strong>1. 从右上角开始</strong>：在矩阵的右上角元素 <code>(0, n-1)</code> 开始，如果这个元素等于目标值 <code>target</code>，则返回 <code>true</code>。如果这个元素大于 <code>target</code>，那么可以排除当前列，向左移动；如果这个元素小于 <code>target</code>，则可以排除当前行，向下移动。</p><p><strong>2.不断移动</strong>直到找到目标值或者移动到矩阵的边界之外，此时可以确定目标值不存在于矩阵中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; plants, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (plants.<span class="built_in">empty</span>() || plants[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = plants.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = plants[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右上角开始搜索</span></span><br><span class="line">    <span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (plants[row][col] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plants[row][col] &gt; target) &#123;</span><br><span class="line">            col--; <span class="comment">// 移动到左边一列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++; <span class="comment">// 移动到下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没有找到目标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; plants = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">searchMatrix</span>(plants, target)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中</p><ul><li>如果当前元素等于 <code>target</code>，返回 <code>true</code>。</li><li>如果当前元素大于 <code>target</code>，向左移动一列。</li><li>如果当前元素小于 <code>target</code>，向下移动一行。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-canvas实现贪吃蛇&quot;&gt;&lt;a href=&quot;#1-canvas实现贪吃蛇&quot; class=&quot;headerlink&quot; title=&quot;1.canvas实现贪吃蛇&quot;&gt;&lt;/a&gt;1.canvas实现贪吃蛇&lt;/h2&gt;&lt;figure class=&quot;highlight html</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-10-2</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d5.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d5.html</id>
    <published>2024-10-02T23:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>WebSocket是一种协议  实时通讯利器</p><p>设计用于提供低延迟、全双工和长期运行的连接</p><p>WebSocket出现前的解决方案</p><p>轮询：客户端定期向服务器发送请求</p><p>长轮询：在客户端发出请求后，保持连接打开，等待新数据响应后再关闭连接</p><p>Comet：保持长连接，在返回请求后继续保持连接打开</p><p>WebSocket的优势</p><p>双向实时通信：允许在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的应用程序里，比http更加高效</p><p>降低延迟：链接一旦建立便会保持开放，数据可以在客户端和服务器之间以比http更低的延迟进行传输</p><p>更高效的资源利用：可以减少重复请求和响应的开销，因为它的连接只需要建立一次</p><p>为什么需要心跳机制？</p><p>为了保持 WebSocket 稳定的长连接，在连接建立之后，服务器和客户端之间通过心跳包来保持连接状态，以防止连接因为长时间没有数据传输而被切断。</p><p>一种特殊的数据包!</p><p>不包含任何实际数据，仅用来维持连接状态</p><p>一个空数据帧</p><p>定期发送，确保链接仍然有效，避免长时间没有数据传输而被中断</p><p>如果一段时间内没有收到对方的心跳包，就可以认为连接已经断开</p><p>WebSocket 的限制</p><p>不提供加密功能：如果有安全上的需求，需采用其他方式来确保安全性，如:SSL协议，设置黑白名单</p><p>不支持古老的浏览器：不支持IE10 以前的版本。需要使用 AJAX或者其他方式来进行替代</p><p>优化很重要：保持长连接需要服务器不断地维护和处理连接状态，需要优化性能</p><h2 id="什么是promise？"><a href="#什么是promise？" class="headerlink" title="什么是promise？"></a>什么是promise？</h2><p>是一种用于管理异步操作的对象基于状态机的概念，可以处于三种状态</p><p>Pending-等待中</p><p>Fulfilled-已完成</p><p>Rejected-已拒绝</p><p>Promise引入链式调用</p><p>更流程地处理多个异步操作，避免深陷层层嵌套的回调函数中</p><p>promise.all</p><p>使用场景：</p><p>需求：处理多个可能出现错误的异步操作，如果其中任何一个失败，就记录错误。</p><p>社交媒体应用发帖：</p><ul><li>用户可以创建帖子并上传多张照片</li><li>当用户提交时，同时上传所有照片</li><li>所有图片上传完成后，才能创建帖子</li></ul><p>promise.race</p><p>参数也是一个数组，返回结果是一个Promise对象，Promise状态为数组中最先返回结果的状态</p><p>实际应用：</p><ul><li>先尝试本地缓存</li><li>如果时间过久则获取服务器</li></ul><h2 id="浏览器存储-Cookie-Local-Storage-Session-Storage"><a href="#浏览器存储-Cookie-Local-Storage-Session-Storage" class="headerlink" title="浏览器存储: Cookie + Local Storage + Session Storage"></a>浏览器存储: Cookie + Local Storage + Session Storage</h2><p>http是一种无状态的协议 实际web应用中需要保存状态信息</p><p>cookie 是由服务端产生的内容，发送到浏览器保存本地，Cookie被来回传递，所以它主要就用于记录用户的 会话状态、身份验证和跟踪用户的行为等。</p><p>Cookie优点：</p><ul><li>在浏览器和服务器间来回传递，适用于跟踪用户行为</li><li>可以手动设置过期时间，灵活调节存储时间</li></ul><p>缺点：</p><ul><li>每次请求都会携带Cookie数据，增加流量浪费性能</li><li>在http中明文传输不够安全，容易被篡改</li><li>存储容量小，一般为4KB</li></ul><p>localStorage优点：</p><ul><li>存储容量较大，一般为 5M</li><li>存储的数据在客户端浏览器可以永久保存，不担心丢失</li><li>操作方便，API友好能通过 JavaScript 直接访问</li></ul><p>缺点：</p><ul><li>一网站只能访问自己域下的 LS</li><li>不支持在不同浏览器间共享数据</li></ul><p>sessionStorage优点：</p><ul><li>数据只存储在客户端</li><li>刷新页面仍有原来会话数据</li><li>每个标签/窗口间数据独立</li></ul><p>缺点：</p><ul><li>不适合长期存储</li><li>数据不共享，使用场景有限</li></ul><p>什么时候能用到SessionStorage</p><ul><li>假设有一个多步骤表单流程</li><li>用户在填写过程中可以点击 上一步/下一步 修改数据</li><li>使用 Session Storage 暂存内容</li></ul><p>三者相同点：都保存在浏览器端、不支持跨域</p><p>不同点</p><div class="table-container"><table><thead><tr><th></th><th>Cookie</th><th>localstorage</th><th>SessionStorage</th></tr></thead><tbody><tr><td>存储内容是否发送到服务器</td><td>每次请求都会发送</td><td>只保存本地，不与服务器发送任何交互</td><td>只保存本地，不与服务器发送任何交互</td></tr><tr><td>数据存储大小上的不同</td><td>不能超过4KB</td><td>可以达到5MB</td><td>可以达到5MB</td></tr><tr><td>存储数据有效期限不同</td><td>需要自行设置失效时间</td><td>永久有效</td><td>关闭浏览器前有效</td></tr><tr><td>作用域不同</td><td>同源同窗口都是共享的</td><td>同源同窗口都是共享的</td><td>不同窗口不共享</td></tr></tbody></table></div><p>选择Cookie：在客户端和服务器之间共享数据+长期存储<br>选择Local Storage：只在客户端长期存储 +无需与服务器交互<br>选择Session Storage：只在客户端 + 会话期间暂存</p><h2 id="https-网络传输协议"><a href="#https-网络传输协议" class="headerlink" title="https:网络传输协议"></a>https:网络传输协议</h2><p>加密的两种基本类型</p><p>对称加密：加密方与解密方共用一套秘钥</p><p>非对称加密：基于成对的密钥对，加密方与解密方分别持有公钥与私钥</p><p>对称加密弊端：很难安全地告知双方这套秘钥</p><p>非对称加密弊端：所需算力远大于对称加密</p><p>重点：HTTPS 正是通过先利用非对称加密传输对称加密的密钥</p><p>再利用对称加密传输实际内容这样的方式，保证了它的安全性</p><p>电子证书：就是由第三方机构开具的证明，其中写明了xx公钥属于xx域名</p><p>如果你要访问的是这个域名，证书上就是你要使用的公钥</p><p>明文传输密码没什么安全隐患？当然也不是，  https 网络传输一个基本的安全保障</p><p>https下依然会受到中间人攻击，采用更多层次的加密手段，代表着更高的破解成本，也会带来更安全地信息传输 </p><p>HTTPS 是个应用层的协议，在明文内容离开和到达浏览器的时候，浏览器已经分别完成了加密与解密</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;websocket&quot;&gt;&lt;a href=&quot;#websocket&quot; class=&quot;headerlink&quot; title=&quot;websocket&quot;&gt;&lt;/a&gt;websocket&lt;/h2&gt;&lt;p&gt;WebSocket是一种协议  实时通讯利器&lt;/p&gt;
&lt;p&gt;设计用于提供低延迟、全双</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-27</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d4.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d4.html</id>
    <published>2024-09-27T12:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应"><a href="#1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应" class="headerlink" title="1.实现 两列布局  左边固定，右边自适应 两边高度随内容自适应"></a>1.实现 两列布局  左边固定，右边自适应 两边高度随内容自适应</h2><ul><li><strong>Flexbox</strong> 和 <strong>Grid</strong>：现代布局方法，易于实现和维护。</li><li><strong>浮动（Float）</strong>：传统方法，适用于简单的布局。</li><li><strong>绝对定位（Absolute Positioning）</strong>：适用于需要精确控制位置的布局。</li><li><strong>表格布局（Table Layout）</strong>：模拟表格的布局方式，适用于需要对齐的布局。</li><li><strong>多列布局（Multi-column Layout）</strong>：主要用于文本内容的多列显示，也可以用来实现两列布局。</li></ul><p>选择哪种方法取决于你的具体需求和个人偏好。现代项目中，推荐使用 Flexbox 或 Grid 布局，因为它们提供了更多的灵活性和更好的浏览器支持。</p><h2 id="2-ul中包含两个-li-再生成-里面是，h1中的内容是Hello！然后将这个li插入到ul的头部"><a href="#2-ul中包含两个-li-再生成-里面是，h1中的内容是Hello！然后将这个li插入到ul的头部" class="headerlink" title="2.ul中包含两个 li 再生成,里面是，h1中的内容是Hello！然后将这个li插入到ul的头部"></a>2.ul中包含两个 li 再生成<li>,里面是<h1>，h1中的内容是Hello！然后将这个li插入到ul的头部</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 &lt;li&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> newLi = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 &lt;h1&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> newH1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            newH1.<span class="property">textContent</span> = <span class="string">&#x27;Hello!&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将 &lt;h1&gt; 插入到 &lt;li&gt; 中</span></span></span><br><span class="line"><span class="language-javascript">            newLi.<span class="title function_">appendChild</span>(newH1);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            ul.<span class="title function_">insertBefore</span>(newLi, ul.<span class="property">firstChild</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面是我的思路  代码简单 思路清晰 hhh</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 innerHTML 方法将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            list.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;li&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/li&gt;&#x27;</span> + list.<span class="property">innerHTML</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 insertAdjacentHTML 方法将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            list.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterbegin&#x27;</span>, <span class="string">&#x27;&lt;li&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/li&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-在微前端架构中，为了避免父级项目和子集项目之间的样式冲突"><a href="#3-在微前端架构中，为了避免父级项目和子集项目之间的样式冲突" class="headerlink" title="3.在微前端架构中，为了避免父级项目和子集项目之间的样式冲突"></a>3.在微前端架构中，为了避免父级项目和子集项目之间的样式冲突</h2><p>可以采取以下措施：</p><ol><li><strong>使用 CSS Modules</strong>：将样式作用域化。</li><li><strong>使用 scoped 样式</strong>：限制样式的作用范围。</li><li><strong>使用命名空间</strong>：为样式添加前缀或命名空间。</li><li><strong>使用 Shadow DOM</strong>：完全隔离样式。</li><li><strong>使用第三方库</strong>：利用微前端框架提供的工具和配置。</li></ol><p>通过这些方法，可以有效地管理和避免样式冲突，确保微前端项目的顺利运行。</p><h2 id="4-基于canvas技术实现在线签名和画板功能"><a href="#4-基于canvas技术实现在线签名和画板功能" class="headerlink" title="4.基于canvas技术实现在线签名和画板功能"></a>4.基于canvas技术实现在线签名和画板功能</h2><p>项目输出：</p><p>分为主画板，悬浮板，签名板 三块内容</p><p>功能从签名画板开始，一般是需要先获取签名画板并且初始化canvas画布（首先获取canvas元素，canvas元素.getContext(‘2d’)获取到的是canvas对象）</p><p>然后签名板功能需要监听鼠标事件，来完成书写。从以下三部分去考虑：</p><ol><li>当鼠标按下mousedown的时候，先确定起点位置 moveTo可以确定起点，但也要注意一个问题（clientX是相对屏幕的位置，我们需要的是相对于画板的位置 这里得用 offsetX）</li></ol><p>注意：此处 每次按下 beginPath() 每次绘制需要是一条新路径（如果不考虑这点 后面什么改变颜色 线条粗细 会有问题</p><ol><li>鼠标移动mousemove的时候，并且是在鼠标按下的时候 需要不断的加新点，光加点还不行，要连点成线。一边lineTo一边stroke</li><li>当鼠标松开的时候 关闭开关 不再回绘制了</li></ol><p>画完之后，是确认与清除功能</p><p>清除整个签名画板 用clearRect函数，从起点开始，清除一个宽高多少的矩形范围</p><p>确认的话，将绘制的签名转绘到悬浮板上，floatCtx.drawImage(sign,0,0,200,80)</p><p>然后通过拖动浮层板调整签名在主画板的位置</p><p>在点击确认导出的时候，将浮层画板的签名转绘到主画板上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">save</span>(<span class="params"></span>)&#123;</span><br><span class="line">mainCtx.<span class="title function_">drawImage</span>(float,left.<span class="property">value</span>,top.<span class="property">value</span>,<span class="number">200</span>,<span class="number">80</span>)</span><br><span class="line">    <span class="keyword">let</span> base64=main.<span class="title function_">toDataURL</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(base64);</span><br><span class="line">    <span class="comment">// 把拿到的base64发送给后端保存起来就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浅谈前端拖拽功能</p><p>前端组件 VueDraggable VueDraggablePlus  完全继承了 之前的Sortable.js的所有功能</p><p><a href="https://search.bilibili.com/all?from_source=webcommentline_search&amp;keyword=element%20plus&amp;seid=9318871269317883971">element plus</a>的拖拽实现不错，不借助定位  packages/hooks/use-draggable</p><p><a href="https://github.com/element-plus/element-plus/blob/dev/packages/hooks/use-draggable/index.ts">https://github.com/element-plus/element-plus/blob/dev/packages/hooks/use-draggable/index.ts</a></p><p>而传统实现拖拽的思路是：大方向主要是在mousedown，mousemove，mouseup的状态下，记录当前鼠标的坐标<code>startX=e.clientX</code>,<code>startY=e.clientY</code>;当前元素的左上角坐标<code>this.initialX=this.$refs.draggable.offsetLeft;</code> <code>this.initialY=this.$refs.draggable.offsetTop;</code></p><p>而后 在鼠标移动的过程中，需要去计算 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const deltaX = e.clientX - this.startX;</span><br><span class="line">const deltaY = e.clientY - this.startY; // 通过鼠标移动的距离计算</span><br><span class="line">const newX = this.initalX+deltaX;</span><br><span class="line">const newY = this.initalY+deltaY;</span><br></pre></td></tr></table></figure><p>鼠标松开时，解除拖拽状态</p><h2 id="5-页面输入-url-到页面渲染都发生了什么"><a href="#5-页面输入-url-到页面渲染都发生了什么" class="headerlink" title="5.页面输入 url 到页面渲染都发生了什么"></a>5.页面输入 url 到页面渲染都发生了什么</h2><ol><li>输入url </li><li>DNS解析</li><li>建立tcp连接</li><li>SSL/TLS握手（https）</li><li>发送http请求</li><li>服务器处理请求生成响应</li><li>浏览器接收http响应</li><li>解析html（构建 DOM树 CSSOM树  渲染树）</li><li>布局和绘制</li><li>加载资源</li></ol><h2 id="6-包装对象"><a href="#6-包装对象" class="headerlink" title="6.包装对象"></a>6.包装对象</h2><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object()</li><li>Function()</li><li>RegExp()</li><li>Date()</li><li>Error()</li><li>Symbol()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 构造函数创建出来的对象，封装了基本类型值 abc</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// &quot;object&quot;</span></span><br><span class="line">a.<span class="property">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf - 拿到封装对象里的基本类型数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应&quot;&gt;&lt;a href=&quot;#1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应&quot; class=&quot;headerlink&quot; title=&quot;1.实现 两列布局  左边固定，右边自适应 两边高度随内容自</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-26</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d3.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d3.html</id>
    <published>2024-09-26T22:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？"><a href="#1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？" class="headerlink" title="1.场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？"></a>1.场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？</h3><p> 可以使用 <strong>getter/setter</strong> 或 <strong>Proxy</strong> 来监控属性的变化 </p><ol><li>通过定义对象的 getter 和 setter 来监控 <code>a</code> 的变化，并在其被修改时更新 <code>c</code> 和 <code>d</code>。   </li><li>通过 Proxy 可以拦截对对象的所有操作，包括属性的读取和写入。  </li></ol><h3 id="2-场景：实现两行两列"><a href="#2-场景：实现两行两列" class="headerlink" title="2.场景：实现两行两列"></a>2.场景：实现两行两列</h3><p>grid flex float table  通常推荐使用 Flexbox 或 Grid</p><h3 id="3-弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思"><a href="#3-弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思" class="headerlink" title="3.弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思"></a>3.弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思</h3><p>它实际上包含了三个属性：<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>。具体来说，<code>flex: 1;</code> 的完整形式是 <code>flex: 1 1 0;</code>。</p><p><strong>flex-grow：</strong>默认值是0，定义了子元素在主轴方向上的增长比例。如果可用空间多于所需空间，子元素将根据这个比例增长。设置值为<code>1</code> 表示该子元素可以增长，增长的比例为1。如果有多个子元素都设置了相同的 <code>flex-grow</code> 值，它们将平均分配剩余空间。</p><p><strong>flex-shrink</strong>：默认值1，定义了子元素在主轴方向上的收缩比例。如果可用空间不足，子元素将根据这个比例收缩。设置值为<code>1</code> 表示该子元素可以收缩，收缩的比例为1。如果有多个子元素都设置了相同的 <code>flex-shrink</code> 值，它们将平均分配不足的空间。</p><p><strong>flex-basis</strong>：默认值是auto，定义了子元素在主轴方向上的初始大小，可以是固定值（如 <code>100px</code>）或百分比（如 <code>50%</code>），也可以是 <code>auto</code>。设置值为<code>0</code> 表示子元素的初始大小为0。这意味着子元素将完全依赖于 <code>flex-grow</code> 和 <code>flex-shrink</code> 来确定其最终大小。</p><h3 id="4-同源策略是什么？CORS涉及到的参数有哪些？"><a href="#4-同源策略是什么？CORS涉及到的参数有哪些？" class="headerlink" title="4.同源策略是什么？CORS涉及到的参数有哪些？"></a>4.同源策略是什么？CORS涉及到的参数有哪些？</h3><p>仅当它们的协议、域名和端口号都相同，两个URL被认为是同源的</p><p>同源策略的主要目的是防止恶意网站读取其他网站的敏感数据。例如，当用户在一个浏览器窗口中登录了银行网站，而同时打开了另一个窗口访问了恶意网站，如果没有同源策略的保护，恶意网站可能尝试通过 JavaScript 访问银行网站的数据，从而导致用户信息泄露。</p><p>CORS（跨源资源共享）：是一种机制，它使用额外的 HTTP 头来告诉浏览器允许一个域上的 Web 应用程序去请求另一个域上的选定资源。这种机制为服务器提供了更细粒度的控制，允许它们指定哪些外部来源可以访问它们的资源。</p><h3 id="5-ES6中你知道哪些数据结构？"><a href="#5-ES6中你知道哪些数据结构？" class="headerlink" title="5.ES6中你知道哪些数据结构？"></a>5.ES6中你知道哪些数据结构？</h3><p><code>Map</code>是一个键值对的集合，其中键和值可以是任意类型。</p><p><code>Set</code>是一个存储唯一值的集合，不允许重复。</p><p><code>WeakMap</code>是一个键值对的集合，其中键必须是对象，值可以是任意类型。</p><p><code>WeakSet</code> 是一个存储唯一对象的集合，不允许重复。</p><p>Array数组，虽然数组不是 ES6 新引入的数据结构，但在 ES6 中，数组新增了一些有用的方法，如 <code>find</code>、<code>findIndex</code>、<code>includes</code> 等。</p><p>String字符串，虽然字符串也不是新的数据结构，但 ES6 为字符串增加了一些新的方法，如 <code>startsWith</code>、<code>endsWith</code>、<code>includes</code> 等。</p><p><code>Symbol</code>是一种新的原始数据类型，用于创建唯一的标识符。</p><p>主要用途是确保对象属性的名称不会发生冲突，特别是在大型应用程序或多个模块协同工作时。</p><p><code>Symbol</code> 可以用于创建私有属性，这些属性不会被意外地访问或修改。</p><h3 id="6-map和set的区别？以及map的key值可以是什么"><a href="#6-map和set的区别？以及map的key值可以是什么" class="headerlink" title="6.map和set的区别？以及map的key值可以是什么"></a>6.map和set的区别？以及map的key值可以是什么</h3><p><code>Map</code> 是一个键值对的集合，其中键和值可以是任意类型。</p><p><code>Set</code> 是一个存储唯一值的集合，不允许重复。</p><ul><li><code>Map</code> 提供了 <code>set</code>、<code>get</code> 、<code>has</code>等方法。</li><li><code>Set</code> 提供了 <code>add</code>、<code>delete</code>、<code>has</code> 等方法。</li></ul><h3 id="7-weakSet和Set有什么区别？"><a href="#7-weakSet和Set有什么区别？" class="headerlink" title="7.weakSet和Set有什么区别？"></a>7.weakSet和Set有什么区别？</h3><p><code>Set</code> 和 <code>WeakSet</code> 都是用于存储唯一值的集合，但 <code>Set</code> 更通用，可以存储任何类型的值，而 <code>WeakSet</code> 只能存储对象且对象是弱引用的。选择使用哪一个取决于你的具体需求。如果你需要存储任意类型的唯一值并且需要强引用，使用 <code>Set</code>；如果你需要存储对象且希望这些对象在没有其他引用时可以被垃圾回收，使用 <code>WeakSet</code>。</p><h3 id="8-Vue的双向绑定的原理"><a href="#8-Vue的双向绑定的原理" class="headerlink" title="8.Vue的双向绑定的原理"></a>8.Vue的双向绑定的原理</h3><p>Vue 的双向绑定主要依赖于两个关键技术：<strong>数据劫持</strong>（Data Binding）<strong>和发布订阅模式</strong>（Observer Pattern）</p><ol><li>数据劫持<ul><li>Vue使用Object.defineProperty(vue3中使用proxy)来劫持对象的属性，从而在数据发生变化时触发相应的更新操作。</li><li>在 Vue 2.x 中，Vue 使用 <code>Object.defineProperty</code> 来劫持对象的属性。每当数据对象的属性被访问或修改时，Vue 都能捕获到这些操作，并执行相应的逻辑。</li><li>在 Vue 3 中，Vue 使用 <code>Proxy</code> 来劫持对象的属性。<code>Proxy</code> 相比 <code>Object.defineProperty</code> 更加强大，可以拦截更多的操作，并且不需要递归遍历对象的所有属性。</li></ul></li><li>发布/订阅模式<ul><li>Vue 使用发布/订阅模式来实现视图和数据之间的通信。当数据发生变化时，Vue 会通知所有订阅者（即视图中的相关部分），这些订阅者会根据新的数据重新渲染视图。</li><li>观察者负责监听数据的变化。当数据发生变化时，观察者会通知所有订阅者。</li><li>订阅者负责更新视图。当数据发生变化时，订阅者会接收到通知并更新视图。</li></ul></li><li>模版编译<ul><li>Vue 的模板编译器会解析模板中的指令和表达式，并生成相应的渲染函数。在渲染过程中，Vue 会创建观察者和订阅者，从而实现数据和视图的双向绑定。</li></ul></li></ol><p>Vue 的双向数据绑定主要通过数据劫持和发布/订阅模式实现。数据劫持通过 <code>Object.defineProperty</code> 或 <code>Proxy</code> 劫持对象的属性，使其在数据变化时能够触发相应的更新操作。发布/订阅模式通过观察者和订阅者实现数据和视图之间的通信，确保数据变化时视图能够及时更新。模板编译器则负责解析模板中的指令和表达式，生成渲染函数，并创建观察者和订阅者。</p><h3 id="9-浏览器事件循环"><a href="#9-浏览器事件循环" class="headerlink" title="9.浏览器事件循环"></a>9.浏览器事件循环</h3><p>事件循环是浏览器处理异步任务的一种机制。它确保了浏览器可以在处理用户交互、网络请求、定时器等异步任务的同时，还能保持页面的响应性。</p><p>在单线程的 JavaScript 环境中，所有的代码都是按顺序执行的。但是，有些任务（如网络请求、定时器、用户输入等）需要等待一段时间才能完成。如果没有事件循环，浏览器就会在等待这些任务完成时阻塞，导致页面卡顿。事件循环的作用就是让这些异步任务在后台执行，不会阻塞主线程，从而保持页面的流畅。</p><ul><li><strong>任务队列</strong>：存放宏任务，如 <code>setTimeout</code>、点击事件、事件请求等。</li><li><strong>微任务队列</strong>：存放微任务，如 <code>Promise</code> 回调等。</li><li><strong>事件循环</strong>：每次执行一个宏任务后，清空微任务队列，然后进行渲染，再取下一个宏任务，如此循环。</li></ul><h3 id="10-浏览器缓存"><a href="#10-浏览器缓存" class="headerlink" title="10.浏览器缓存"></a>10.浏览器缓存</h3><p><strong>缓存类型：</strong></p><p><strong>强缓存</strong></p><p>强缓存是指浏览器在请求资源时，直接从本地缓存中读取资源，而不会向服务器发送请求。强缓存主要依赖于 HTTP 响应头中的 <code>Cache-Control</code> 和 <code>Expires</code> 字段。</p><p>Cache-Control</p><ul><li><code>max-age=&lt;seconds&gt;</code>：表示资源在本地缓存中的最大有效时间（以秒为单位）。例如，<code>Cache-Control: max-age=3600</code> 表示资源在本地缓存中有效 1 小时。</li><li><code>no-cache</code>：表示在每次请求资源时，浏览器都会向服务器发送请求，但服务器可能会返回 304 Not Modified 状态码，告诉浏览器使用缓存中的资源。</li><li><code>no-store</code>：表示浏览器不应缓存该资源。</li></ul><p>Expires</p><ul><li>表示资源在本地缓存中的过期时间，是一个具体的日期和时间。例如，<code>Expires: Wed, 21 Oct 2021 07:28:00 GMT</code>。如果同时存在 <code>Cache-Control</code> 和 <code>Expires</code>，优先使用 <code>Cache-Control</code>。</li></ul><p><strong>协商缓存</strong></p><p>协商缓存是指浏览器在请求资源时，会向服务器发送请求，但服务器可以根据资源的最新状态决定是否返回新的资源。协商缓存主要依赖于 HTTP 请求头中的 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 字段，以及响应头中的 <code>ETag</code> 和 <code>Last-Modified</code> 字段。</p><p><strong>缓存策略</strong>：</p><ul><li><strong>强缓存优先</strong>：浏览器首先检查强缓存是否有效，如果有效则直接使用缓存中的资源；如果无效，则进入协商缓存阶段。</li><li><strong>协商缓存</strong>：浏览器向服务器发送请求，服务器根据资源的最新状态决定是否返回新的资源。</li></ul><h3 id="11-怎么做缓存？前端这块怎么实现？"><a href="#11-怎么做缓存？前端这块怎么实现？" class="headerlink" title="11.怎么做缓存？前端这块怎么实现？"></a>11.怎么做缓存？前端这块怎么实现？</h3><p>前端实现缓存的方式有很多，主要包括通过 HTTP 缓存、Service Worker、本地存储（如 localStorage、sessionStorage、IndexedDB）等。下面详细介绍这些方法及其具体实现。</p><ol><li>HTTP 缓存是最常见的缓存方式，通过设置 HTTP 响应头来控制浏览器的缓存行为。</li><li>强缓存和协商缓存属于http缓存中的</li><li>Service Worker 是一种运行在浏览器后台的脚本，可以拦截和处理网络请求，实现离线缓存和资源预加载。</li><li>本地存储，<code>localStorage</code> 和 <code>sessionStorage</code> 是两种简单的键值对存储方式，适合存储少量数据。</li><li><code>IndexedDB</code> 是一种更复杂的本地存储方式，适合存储大量结构化数据。</li></ol><h3 id="12-箭头函数的特点"><a href="#12-箭头函数的特点" class="headerlink" title="12.箭头函数的特点"></a>12.箭头函数的特点</h3><ol><li>简洁的语法</li><li>没有自己的this</li><li>不能作为构造函数</li><li>没有arguments对象</li><li>没有原型属性</li><li>this绑定不可变</li><li>不能使用yield命令</li></ol><h3 id="13-HTTP2和HTTP3新增了哪些功能"><a href="#13-HTTP2和HTTP3新增了哪些功能" class="headerlink" title="13.HTTP2和HTTP3新增了哪些功能"></a>13.HTTP2和HTTP3新增了哪些功能</h3><p>HTTP/2 主要关注于提高现有网络基础设施上的性能，通过多路复用、头部压缩和服务端推送等技术显著改善了用户体验。而 HTTP/3 则是在此基础上进一步利用新的传输层协议 QUIC，解决了 TCP 协议的一些固有问题，如握手延迟和连接迁移等，从而提供了更加流畅和高效的网络体验。</p><h3 id="14-websocket是什么-它的应用场景是什么"><a href="#14-websocket是什么-它的应用场景是什么" class="headerlink" title="14.websocket是什么? 它的应用场景是什么"></a>14.websocket是什么? 它的应用场景是什么</h3><p>WebSocket 作为一种高效、低延迟的双向通信协议，特别适合于需要实时交互的应用场景。</p><p><strong>主要特点</strong></p><ol><li><strong>全双工通信</strong>：</li></ol><ul><li><ul><li>WebSocket 提供了真正的双向通信能力，即客户端和服务器可以同时发送和接收数据，而不需要像传统 HTTP 那样每次通信都需要发起一个新的请求。</li></ul></li></ul><ol><li><strong>低延迟</strong>：</li></ol><ul><li><ul><li>由于 WebSocket 连接是一直保持打开状态的，因此数据交换几乎是即时的，消除了 HTTP 请求/响应模型中的延迟。</li></ul></li></ul><ol><li><strong>轻量级</strong>：</li></ol><ul><li><ul><li>相比于传统的 HTTP 协议，WebSocket 的头部信息更小，减少了不必要的网络流量。</li></ul></li></ul><ol><li><strong>支持多种数据格式</strong>：</li></ol><ul><li><ul><li>WebSocket 可以传输文本数据和二进制数据，这使得它可以适用于各种应用场景。</li></ul></li></ul><p><strong>应用场景</strong></p><ol><li><strong>实时聊天应用</strong>：</li></ol><ul><li><ul><li>实时聊天是最常见的 WebSocket 应用场景之一。无论是个人聊天还是群聊，WebSocket 都能确保消息的即时传递。</li></ul></li></ul><ol><li><strong>在线游戏</strong>：</li></ol><ul><li><ul><li>在线多人游戏通常需要低延迟和高频率的数据交换，WebSocket 能够很好地满足这一需求，提供流畅的游戏体验。</li></ul></li></ul><ol><li><strong>实时协作工具</strong>：</li></ol><ul><li><ul><li>如在线文档编辑器、代码协作平台等，需要多个用户同时操作同一个文件或项目，WebSocket 可以实现实时同步更新。</li></ul></li></ul><ol><li><strong>实时数据分析和监控</strong>：</li></ol><ul><li><ul><li>对于需要实时更新数据的仪表盘或监控系统，WebSocket 可以快速地将最新的数据推送到客户端，使用户能够及时做出反应。</li></ul></li></ul><h3 id="15-CSS动画-怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？"><a href="#15-CSS动画-怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？" class="headerlink" title="15.CSS动画  怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？"></a>15.CSS动画  怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？</h3><ol><li>定义关键帧动画：使用 <code>@keyframes</code> 规则来定义动画的关键帧。关键帧指定了动画在特定时间点的状态。</li></ol><ol><li>应用动画：使用 <code>animation</code> 属性将定义好的动画应用到元素上，并设置动画的播放次数。</li><li>控制动画播放次数<ul><li><code>animation-iteration-count</code> 属性可以设置动画的播放次数。默认值是 <code>1</code>，表示只播放一次。</li><li><code>forwards</code> 值可以确保动画结束后保持最后一个关键帧的状态。</li></ul></li></ol><h3 id="16-JS原型链-怎么给Array原型数组添加方法"><a href="#16-JS原型链-怎么给Array原型数组添加方法" class="headerlink" title="16.JS原型链   怎么给Array原型数组添加方法"></a>16.JS原型链   怎么给Array原型数组添加方法</h3><p><strong>原型链</strong>：当尝试访问一个对象的属性时，JavaScript 会首先在对象本身上查找该属性。如果找不到，就会在对象的原型上查找，依此类推，直到找到该属性或到达原型链的末端（即 <code>null</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 average 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">average</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 处理空数组</span></span><br><span class="line">  <span class="keyword">const</span> total = <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> total / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">average</span>()); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h3 id="17-闭包"><a href="#17-闭包" class="headerlink" title="17.闭包"></a>17.闭包</h3><p>闭包是在一个函数内部创建另一个函数，并且内部函数可以访问外部函数的变量和参数。即使外部函数已经执行完毕，内部函数仍然可以访问这些变量。</p><h4 id="闭包的优点"><a href="#闭包的优点" class="headerlink" title="闭包的优点"></a>闭包的优点</h4><ol><li><strong>数据封装</strong>：闭包可以用来封装变量，防止外部直接访问和修改。</li><li><strong>持久状态</strong>：闭包可以保持函数执行后的状态，使得函数可以记住之前的执行情况。</li><li><strong>模块化</strong>：闭包可以用于实现模块化编程，隐藏内部实现细节。</li></ol><h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><ol><li><strong>内存泄漏</strong>：如果闭包不当使用，可能会导致内存泄漏，因为闭包会持有对外部变量的引用，使得这些变量不能被垃圾回收。</li><li><strong>性能影响</strong>：闭包可能会增加内存和性能开销，特别是在大量使用闭包的情况下。</li></ol><p>闭包的核心在于内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。</p><h3 id="18-v-model的原理"><a href="#18-v-model的原理" class="headerlink" title="18.v-model的原理"></a>18.v-model的原理</h3><p><code>v-model</code> 是 Vue.js 中实现双向数据绑定的一种便捷方式。它通过 <code>v-bind</code> 和 <code>v-on</code> 的组合，将表单元素的值与 Vue 实例的数据属性绑定在一起，实现了数据的双向同步。</p><p>响应式设计的核心原理包括使用媒体查询来根据设 备特性应用不同的样式，使用灵活的布局技术（如百分比单位、弹性单位、Flexbox 和 Grid）来创建可伸缩的布局，以及确保图像和其他媒体元素在不同屏幕尺寸下保持比例并自动调整大小。通过这些技术，可以确保网页在不同设备和屏幕尺寸上提供良好的用户体验。</p><h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><ol><li>给一个数，判断是斐波那契数列数列的第几个数，如果不存在于斐波那契数列中，则返回-1</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.生成斐波那契数列，直到生成的数大于或等于给定的数。</span></span><br><span class="line"><span class="comment">// 2.检查生成的数列中是否存在给定的数。</span></span><br><span class="line"><span class="comment">// 3.如果存在，返回它的位置；如果不存在，返回 -1。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 生成斐波那契数列，直到生成的数大于或等于 n</span></span><br><span class="line">    <span class="keyword">let</span> fibSequence = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (fibSequence[fibSequence.<span class="property">length</span> - <span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">        fibSequence.<span class="title function_">push</span>(fibSequence[fibSequence.<span class="property">length</span> - <span class="number">1</span>] + fibSequence[fibSequence.<span class="property">length</span> - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 n 是否在斐波那契数列中</span></span><br><span class="line">    <span class="keyword">const</span> index = fibSequence.<span class="title function_">indexOf</span>(n);</span><br><span class="line">    <span class="keyword">return</span> index !== -<span class="number">1</span> ? index : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>压缩字符串 aaaabbbaaacccdd =&gt; a4b3a3c3d2  怎么实现</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compressString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> currentChar = s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === currentChar) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">`<span class="subst">$&#123;currentChar&#125;</span><span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line">            currentChar = s[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最后一个字符及其计数</span></span><br><span class="line">    result += <span class="string">`<span class="subst">$&#123;currentChar&#125;</span><span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> inputStr = <span class="string">&quot;aaaabbbaaacccdd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> compressedStr = <span class="title function_">compressString</span>(inputStr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(compressedStr);  <span class="comment">// 输出: a4b3a3c3d2</span></span><br></pre></td></tr></table></figure><ol><li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li></ol><p>说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 输入:  </span></span><br><span class="line"><span class="comment">// nums1 = [1,2,3,0,0,0], m = 3  </span></span><br><span class="line"><span class="comment">// nums2 = [2,5,6], n = 3  </span></span><br><span class="line"><span class="comment">// 输出: [1,2,2,3,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>)&#123;</span><br><span class="line">  <span class="comment">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span></span><br><span class="line">  <span class="keyword">let</span> i = m-<span class="number">1</span>, j = n-<span class="number">1</span>, k = m + n -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当两个数组都没遍历完时，指针同步移动</span></span><br><span class="line">  <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 取较大的值，从末尾往前填补</span></span><br><span class="line">    <span class="keyword">if</span>(nums1[i] &gt;= nums2[j])&#123;</span><br><span class="line">      nums1[k] = nums1[i]</span><br><span class="line">      i--;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      nums1[k] = nums2[j]</span><br><span class="line">      j--;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nums2 留下的情况，特殊处理一下</span></span><br><span class="line">  <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    nums1[k] = nums2[j]</span><br><span class="line">    j--;</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每3秒打印一个helloworld，总共执行4次</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  repeatFunc = <span class="title function_">repeat</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">4</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeatFunc</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每3秒打印一个helloworld，总计执行4次</span></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">repeat</span>(<span class="params">fn, count, timeout</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span>  <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span>  num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span>  timer</span><br><span class="line">            timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                 num++</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= count) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>()</span><br><span class="line">                    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="title function_">fn</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">            &#125;, timeout);</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？&quot;&gt;&lt;a href=&quot;#1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-25</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d2.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d2.html</id>
    <published>2024-09-25T22:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码性能指标"><a href="#代码性能指标" class="headerlink" title="代码性能指标"></a>代码性能指标</h2><p><strong>健壮性</strong>:出现预期之外的情况，是否可控<br><strong>可复用性</strong>:后面出现同样功能，能否复用<br><strong>可拓展性</strong>:新功能是否容易拓展加入<br><strong>耦合度</strong>:模块发生变动，是否会相互影响<br><strong>简洁性</strong>:代码量的多少<br><strong>算法复杂度</strong>:实现某个操作需要的步骤<br><strong>可读性</strong>:他人阅读是否易懂</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p><strong>单一职责</strong>:一个模块应该只有一个职责<br><strong>最少知道</strong>:两个模块互相知道越少越好<br><strong>开闭原则</strong>:对修改关闭，对拓展开放<br><strong>接口隔离</strong>:一个模块不应该有他不需要的方法<br><strong>里氏替换原则</strong>: 基类可以被任何子类替换<br><strong>依赖倒置</strong>:实依赖抽象，不依赖具体</p><p>单一职责：对应于所有的语言中，我们之前说过编程本质上就是设计好模块和模块的沟通。而单一职责原则是我们设计模块应该做什么的最基本考虑。这个模块只负责自己的事，如果有额外事情，应该在独立为其他模块，而不应该在模块里增加。</p><p>最少知道：低耦合使我们永远追求的目标，而低耦合的前提就是两个模块之间不需要过多的业务相关，最好一个模块只需要掉另一个模块的接口就行。</p><p>开闭原则：对拓展开放，对修改关闭。我们平常去设计模块，如果以后有变更可能。可以准备一个拓展处可以是一个参数，也可以是一个方法。我们改代码也是一个道理，改动以前老代码，尽量新增而不要去修改。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><ol><li>创建型：怎么创建模块或对象的技巧</li><li>结构型：怎么设计一个模块的对外接口，以及和其他模块的组织结构</li><li>行为型：怎么解决模块之间的沟通问题，模块怎么沟通更低耦合</li></ol><h2 id="几道笔试题"><a href="#几道笔试题" class="headerlink" title="几道笔试题"></a>几道笔试题</h2><p>编写一个函数flattenArray，接收一个嵌套数组作为参数，返回一个一维数组。</p><p>示例输入:[1,[2,[3,4]],5]</p><p>示例编出:[1,2,3,4,5]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123;<span class="attr">input</span>:process.<span class="property">stdin</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> iter = r1[symbol.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span>(<span class="params"></span>)=&gt;(<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fattenArray</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">flat,toFlatten</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flat.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(toFlatten)?<span class="title function_">fattenArray</span>(toFlatten):toFlatten);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> line;</span><br><span class="line">  <span class="keyword">while</span>(line=<span class="keyword">await</span> <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> inputArray = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(line);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title function_">fattenArray</span>(inputArray);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 Stack 类，实现 push、pop方法</p><p>示例操作:stack.push(1); stack.push(2);console.log(stack.pop());示例输出:2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个 Stack 类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=[];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">ele</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>===<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求数组中的最大值 可以用一个循环 但也可用一行代码  Math.max(…arr);</p><p>如何翻转一个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br></pre></td></tr></table></figure><p>找出任意html中的所有不重复的html标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findUniqueTags</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用一个 Set 数据结构来存储不重复的标签名称</span></span><br><span class="line">  <span class="keyword">const</span> tags = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有节点，并收集标签名称</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>) &#123;</span><br><span class="line">      tags.<span class="title function_">add</span>(node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>()); <span class="comment">// 保存标签名，统一转为小写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历子节点</span></span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(traverse);</span><br><span class="line">  &#125;)(<span class="variable language_">document</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(tags); <span class="comment">// 将 Set 转换为数组并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该函数来获取所有不重复的 HTML 标签</span></span><br><span class="line"><span class="keyword">const</span> uniqueTags = <span class="title function_">findUniqueTags</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueTags);</span><br></pre></td></tr></table></figure><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li>在函数中去调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(walker)&#125;</span><br><span class="line"><span class="title function_">get</span>()</span><br><span class="line">get.<span class="title function_">call</span>(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure><ol><li>函数作为对象的方法被调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;walker&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在跑步`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">run</span>()</span><br><span class="line">person.<span class="property">run</span>.<span class="title function_">call</span>(person)</span><br></pre></td></tr></table></figure><p>就这两种情况，一种是在函数中去调用，指向window。一种是函数作为对象的方法被调用</p><p>vue响应式原理  也是双向绑定的原理</p><h2 id="vue响应式原理-也是双向绑定的原理"><a href="#vue响应式原理-也是双向绑定的原理" class="headerlink" title="vue响应式原理  也是双向绑定的原理"></a>vue响应式原理  也是双向绑定的原理</h2><p>Vue2 中的响应式系统 </p><ol><li><strong>数据劫持</strong></li></ol><ul><li>当你在 Vue 的 <code>data</code> 中定义一个对象，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code>，Vue 会使用 <code>Object.defineProperty</code> 把 <code>name</code> 属性变成一个“响应式”属性。</li><li>这意味着 Vue 在幕后对 <code>name</code> 属性进行了“劫持”，它添加了“getter”和“setter”。当你读取 <code>name</code> 时，Vue 的“getter”函数会被触发；当你修改 <code>name</code> 时，Vue 的“setter”函数会被触发。</li></ul><ol><li><strong>依赖收集</strong></li></ol><ul><li>每个“响应式”属性都有一个“依赖收集器”（一个数组或 Set），用来存储所有依赖于该属性的“观察者”（即订阅者）。</li><li>当你在模板中使用 <code>&#123;&#123; name &#125;&#125;</code> 绑定了一个数据，Vue 会把这个模板当作“观察者”，注册到 <code>name</code> 属性的依赖收集器中。</li><li>当 <code>name</code> 改变时，Vue 会通知它的所有“观察者”，重新计算和更新视图。</li></ul><ol><li><strong>通知更新</strong></li></ol><ul><li>当数据被修改时，Vue 的“setter”会被触发。<code>setter</code> 函数会告诉依赖收集器，让它的所有“观察者”重新执行，从而更新视图。  </li></ul><p>Vue 3 中的变化  </p><p>在 Vue 3 中，响应式系统用 <code>Proxy</code> 代替了 <code>Object.defineProperty</code>，这带来了以下优势  </p><ol><li><strong>性能提升</strong></li></ol><ul><li><code>Proxy</code> 可以直接劫持整个对象，而不是遍历每个属性，因此更高效。</li></ul><ol><li><strong>支持更多类型的数据</strong></li></ol><ul><li><code>Proxy</code> 可以监听对象的新增或删除属性，而 <code>Object.defineProperty</code> 不行。</li></ul><ol><li><strong>更好的可扩展性</strong></li></ol><ul><li>Vue 3 的响应式系统能处理更多场景，例如嵌套对象、数组操作等复杂数据结构。</li></ul><p>Vue 的响应式系统通过数据劫持和发布-订阅模式实现了自动跟踪数据变化并更新视图的功能，使得开发者不需要手动操作 DOM，从而提升了开发效率和用户体验。  </p><p>其中vue中双向绑定的实现</p><p>表单元素上的v-model</p><p>.sync修饰符  <a v-bind:title.sync="data"/></p><p>自定义组件上的v-model，v-bind:value  v-on:input</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码性能指标&quot;&gt;&lt;a href=&quot;#代码性能指标&quot; class=&quot;headerlink&quot; title=&quot;代码性能指标&quot;&gt;&lt;/a&gt;代码性能指标&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;健壮性&lt;/strong&gt;:出现预期之外的情况，是否可控&lt;br&gt;&lt;strong&gt;可复用性&lt;/s</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-23复盘</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d1.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d1.html</id>
    <published>2024-09-23T23:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-场景题"><a href="#1-场景题" class="headerlink" title="1.场景题"></a>1.场景题</h2><p>写一个 5 4 3 2 1 的倒计时效果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int count =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> countdown=<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span>(count===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(countdown)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>用setTimeout也行，别忘了clearInterval</p><p>然后用防抖函数来优化触发计时 当然也有其他很多方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func,time</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">//清除上一次的延时</span></span><br><span class="line">    timeout=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args) <span class="comment">// 在指定时间后执行函数</span></span><br><span class="line">    &#125;,time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖函数经常用于输入框搜索，防止用户每次按键都触发搜索请求</p><p>调用 需要的是返回的函数</p><p>const countdown = debounce(countdown, 500); // 500ms 防抖</p><p>然后后面直接调用countdown函数即可</p><p>一般防抖应用场景：</p><ul><li>搜索框输入时的搜索建议</li><li>窗口大小调整时的性能优化（resize 事件） </li><li>滚动事件中减少页面的滚动处理次数（scroll 事件）  </li></ul><h2 id="2-几道八股"><a href="#2-几道八股" class="headerlink" title="2.几道八股"></a>2.几道八股</h2><h3 id="1-em-rem"><a href="#1-em-rem" class="headerlink" title="1.em rem"></a>1.em rem</h3><p>常用于响应式设计，以便元素能够根据不同设备的屏幕尺寸动态调整大小  </p><p><code>em</code> 单位    相对父元素的字体大小    层级继承  </p><p><code>rem</code> 单位   <strong>相对于根元素的字体大小</strong>：<code>rem</code> 是相对<strong>根元素</strong>（即 <code>&lt;html&gt;</code> 元素）的字体大小，通常浏览器默认的根元素字体大小是 <code>16px</code>，除非手动修改。  </p><p><strong>不受父元素影响</strong>：与 <code>em</code> 不同，<code>rem</code> 不会随着父元素的字体大小变化，它只受根元素字体大小的影响，保持一致性。  </p><ul><li><code>em</code>：相对于<strong>父元素</strong>的字体大小，具有层级继承性，适用于需要随父元素动态变化的场景。</li><li><code>rem</code>：相对于<strong>根元素</strong>的字体大小，确保元素在页面上保持一致的相对尺寸，适用于需要全局一致性、响应式设计的场景。</li></ul><h3 id="2-npm-pnpm区别"><a href="#2-npm-pnpm区别" class="headerlink" title="2.npm ,pnpm区别"></a>2.npm ,pnpm区别</h3><p>JavaScript 包管理器   用于安装、管理、更新项目依赖库。它们的目标类似，但在实现和性能上有一些显著的区别。  </p><p><code>npm</code> 的特点：   深度嵌套的依赖   重复安装   缓存机制   锁定文件  </p><p><code>pnpm</code> 是一个更高效的包管理器，旨在解决 <code>npm</code> 中的一些性能问题，尤其是在磁盘空间和安装速度方面。  </p><p><code>pnpm</code> 的特点：   硬链接和符号链接   严格模式的依赖解析  </p><p><strong>性能优势</strong>：由于 <code>pnpm</code> 依赖缓存和符号链接，安装速度通常会比 <code>npm</code> 更快，尤其是在重复安装的场景下。  </p><h3 id="3-package-lock-json作用"><a href="#3-package-lock-json作用" class="headerlink" title="3.package.lock.json作用"></a>3.package.lock.json作用</h3><p><strong>锁定项目中安装的依赖包的具体版本</strong>，以确保在不同的环境或不同的开发者机器上，安装的依赖包版本完全一致，从而避免因依赖包版本不一致而引发的问题。  </p><p><strong>锁定依赖版本</strong>：</p><ul><li><code>package.json</code> 文件中通常会指定依赖包的版本范围（比如 <code>&quot;^1.0.0&quot;</code> 表示允许安装 1.x.x 的任何版本），但这意味着在不同时间或环境下，安装的依赖版本可能会有所不同。</li><li><code>package-lock.json</code> 文件记录了每个依赖的<strong>确切版本</strong>，包括所有直接和间接（transitive）依赖的版本。通过这个文件，<code>npm</code> 能确保每次安装时，依赖的版本都固定不变。</li></ul><p><strong>加快安装速度</strong>：  </p><p><code>package-lock.json</code> 文件中保存了所有依赖的源地址（registry URL），并记录了包的完整性校验（integrity hash）  </p><p> 可以确保所有人安装的依赖版本是一致的</p><h4 id="package-lock-json-与-package-json-的区别："><a href="#package-lock-json-与-package-json-的区别：" class="headerlink" title="package-lock.json 与 package.json 的区别："></a><code>package-lock.json</code> 与 <code>package.json</code> 的区别：</h4><ul><li>package.json：用于声明项目的直接依赖项及其版本范围，表示项目希望使用的依赖版本。开发者手动编辑和维护这个文件。</li><li>package-lock.json：自动生成，记录了依赖项及其子依赖项的确切版本，用于确保安装时依赖关系完全一致。这个文件不需要手动修改。</li></ul><h3 id="4-浏览器缓存有哪些"><a href="#4-浏览器缓存有哪些" class="headerlink" title="4.浏览器缓存有哪些"></a>4.浏览器缓存有哪些</h3><ol><li>HTTP 缓存  cache</li><li>浏览器存储   LocalStorage   SessionStorage   IndexedDB  </li></ol><p>cookie作用</p><p><strong>跨会话状态保持</strong>：Cookie 可以在多个会话间保存信息，使得用户在再次访问网站时可以恢复先前的状态或数据</p><p>Cookie 是一种在客户端存储小型数据的有效方式，用于会话管理和用户个性化设置，但在使用时需要注意安全性和隐私问题。随着 Web 存储技术的发展，开发者可以根据具体需求选择合适的存储方案。</p><h4 id="5-http-和-https"><a href="#5-http-和-https" class="headerlink" title="5.http 和 https"></a>5.http 和 https</h4><p>HTTPS（Hypertext Transfer Protocol Secure）是 HTTP 的安全版本，通过 SSL/TLS（安全套接层/传输层安全协议）来加密在客户端和服务器之间传输的数据。  </p><p>1.客户端请求：客户端（通常是浏览器）向服务器发送一个请求，发起一个安全连接的请求，使用https协议</p><p>2.服务器响应：服务器接受到请求后，返回其数字证书给客户端。数字证书中包含了服务器的公钥和由受信任的证书颁发机构（CA）签名的信息</p><p>3.证书验证：客户端收到数字证书后，会进行验证（验证证书是否有效，证书是否由受信任的CA签发，证书中的域名是否与访问的域名匹配）</p><p>4.生成会话秘钥：如果证书验证通过，客户端会生成一个随机的对称秘钥，用于加密接下来的通信。 客户端使用服务器的公钥对会话密钥进行加密，并将其发送给服务器 。</p><p>5.服务器解密会话秘钥：服务器使用其私钥解密客户端发送的会话秘钥，从而获得对称秘钥</p><p>6.建立安全连接：客户端和服务器端拥有了相同的会话秘钥，可以使用其进行后续的数据传输。所有通过https传输的数据都会使用该会话秘钥进行对称加密。</p><p>7.数据传输：在会话期间，客户端和服务器之间的所有通信都是加密的，保证了数据的机密性和完整性。</p><p>8.结束连接：当会话结束时，客户端和服务器可以选择关闭连接。也可以选择在未来的请求中重新使用相同的会话密钥或重新进行握手，生成新的会话密钥。 </p><h3 id="6-XSS-跨站脚本攻击"><a href="#6-XSS-跨站脚本攻击" class="headerlink" title="6.XSS(跨站脚本攻击)"></a>6.XSS(跨站脚本攻击)</h3><p>XSS 是指攻击者通过在网页中注入恶意脚本，来盗取用户的敏感信息或进行其他恶意操作。</p><p>白名单过滤 ：只允许特定格式的输入，拒绝不符合的输入。比如对于电子邮件、URL、数字等输入字段，使用正则表达式进行验证。   </p><p><strong>特殊字符转义</strong>：在输出到 HTML、JavaScript 或 CSS 中之前，对特殊字符进行转义，例如将 <code>&lt;</code> 转为 <code>&amp;lt;</code>，<code>&gt;</code> 转为 <code>&amp;gt;</code>，以防止注入。  </p><p><strong>文本内容插入</strong>：使用安全的 DOM 操作方法，如 <code>textContent</code> 或 <code>innerText</code>，而不是 <code>innerHTML</code>，避免直接插入 HTML 内容。  </p><p><strong>避免 eval()</strong>：避免使用 <code>eval()</code>、<code>setTimeout()</code> 和 <code>setInterval()</code> 等会执行字符串代码的函数。  </p><p><strong>设置 CSP 头部</strong>：通过设置 HTTP 头部 <code>Content-Security-Policy</code>，限制网页上允许加载的资源，例如只允许加载特定源的脚本。这可以有效防止外部脚本的执行。  </p><h3 id="7-vue组件的通信方式"><a href="#7-vue组件的通信方式" class="headerlink" title="7.vue组件的通信方式"></a>7.vue组件的通信方式</h3><ol><li><p>父子组件通信</p><p>父组件通过 props 将数据传递给子组件。  </p><p>子组件通过 <code>$emit</code> 触发事件，父组件可以监听这些事件。  </p></li><li><p>兄弟组件通信</p><p>通过父组件  作为桥梁 来让两个子组件进行通信</p><p>Event Bus    使用一个中央事件总线（Event Bus）来进行通信。</p></li><li><p>全局状态管理    </p><p>Vuex   用 Vuex 进行全局状态管理，适合大型应用。  </p><p>Provide/Inject   在祖先组件中提供数据，后代组件可以注入这些数据</p></li></ol><h3 id="8-灰度测试"><a href="#8-灰度测试" class="headerlink" title="8.灰度测试"></a>8.灰度测试</h3><p><strong>灰度测试（Gray Release）是一种逐步发布新功能或版本的方法，通过将新功能仅向部分用户开放，从而监控其在真实环境中的表现和用户反馈。这种方式可以有效降低新版本发布的风险，确保新功能的稳定性和可靠性。</strong>  </p><p><strong>灰度测试的特点</strong> </p><p><strong>1.逐步发布</strong>  ：将新功能或版本逐步推向用户，而不是一次性向所有用户发布。</p><p><strong>2.用户分组</strong>  ：可以根据用户的地域、用户行为、使用频率等，将用户分为不同的组，向特定组推出新功能。</p><p><strong>3.监控与反馈</strong>  ：实时监控新版本的性能、用户行为和反馈，及时发现问题并进行调整。</p><p><strong>灰度测试的流程  ：</strong></p><ul><li><strong>选择目标用户</strong>：确定哪些用户将参与灰度测试。这可以基于用户的地理位置、使用习惯或其他特征。</li><li><strong>发布新版本</strong>：向选定的用户群体发布新功能或版本。</li><li><strong>监控与收集数据</strong></li></ul><ul><li><ul><li><strong>监控应用的性能指标（如响应时间、错误率等）。</strong></li><li><strong>收集用户反馈和行为数据。</strong></li></ul></li></ul><ul><li><strong>评估结果</strong>  ：分析收集到的数据，判断新功能是否成功，是否需要进一步改进。</li><li><strong>全量发布</strong>  ：如果新功能表现良好，可以逐步向所有用户发布；如果存在问题，可以对其进行修复后再发布。</li></ul><h3 id="灰度测试的优势"><a href="#灰度测试的优势" class="headerlink" title="灰度测试的优势"></a><strong>灰度测试的优势</strong></h3><ul><li><strong>风险控制</strong>：通过逐步推出新功能，可以及时发现问题并减少对所有用户的影响。</li><li><strong>用户反馈</strong>：可以更快地收集用户对新功能的反馈，便于进行改进和调整。</li><li><strong>资源节约</strong>：可以更有效地利用资源，集中在新功能的优化上，降低后期维护成本。</li></ul><h3 id="灰度测试的应用场景"><a href="#灰度测试的应用场景" class="headerlink" title="灰度测试的应用场景"></a><strong>灰度测试的应用场景</strong></h3><ul><li><strong>新功能发布</strong>：在新功能上线之前，进行灰度测试以验证其可用性和稳定性。</li><li><strong>版本更新</strong>：在产品进行重大版本更新时，可以先进行灰度发布，降低风险。</li><li><strong>市场推广</strong>：在推广新产品或服务时，可以选择特定用户进行测试，以评估市场反应。</li></ul><p>灰度测试是一种有效的产品发布策略，可以帮助开发团队在控制风险的同时，优化用户体验。通过合理设计和实施灰度测试，可以在保证软件质量的同时，提升用户满意度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-场景题&quot;&gt;&lt;a href=&quot;#1-场景题&quot; class=&quot;headerlink&quot; title=&quot;1.场景题&quot;&gt;&lt;/a&gt;1.场景题&lt;/h2&gt;&lt;p&gt;写一个 5 4 3 2 1 的倒计时效果 &lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-20复盘</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d0.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d0.html</id>
    <published>2024-09-23T21:54:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-浏览器输入URL会发生什么"><a href="#1-浏览器输入URL会发生什么" class="headerlink" title="1.浏览器输入URL会发生什么"></a>1.浏览器输入URL会发生什么</h2><p><strong>1.URL 解析</strong></p><p> <strong>用户输入的 URL 会被解析为不同的部分</strong>  </p><ul><li><strong>协议（Scheme）</strong>：如 <code>http:// 或 https://</code></li><li><strong>域名（Host）</strong>：如 <code>www.example.com</code></li><li><strong>路径（Path）：指向特定资源，如</strong> <code>/page</code></li><li><strong>查询参数（Query String）</strong>：如  <code>?id=123&amp;sort=asc</code></li><li><strong>端口号（Port）（可选）</strong>：如 :80  或  :443（默认为 80 或 443）</li></ul><p><strong>2.DNS 解析</strong></p><p> <strong>浏览器会通过 DNS（域名系统）将输入的域名解析为服务器的 IP 地址。</strong></p><ol><li><strong>浏览器首先查询本地缓存（DNS 缓存、操作系统缓存）是否有这个域名的 IP。</strong></li><li><strong>如果没有命中缓存，浏览器会向 DNS 服务器发出请求，递归查询获取目标 IP 地址。</strong></li><li><strong>得到 IP 地址后，浏览器才能继续与目标服务器通信。</strong></li></ol><p><strong>3. 建立 TCP 连接</strong>  </p><ul><li><strong>通过 IP 地址，浏览器与目标服务器之间建立 TCP 连接，默认使用 HTTP 的 80 端口或 HTTPS 的 443 端口。</strong></li><li><strong>浏览器和服务器会进行 三次握手 过程，确保双方可以进行可靠的数据传输</strong></li><li><strong>客户端发送 SYN 请求。</strong></li><li><strong>服务器响应 SYN-ACK。</strong></li><li><strong>客户端发送 ACK，连接建立。</strong></li></ul><p><strong>4. TLS/SSL 握手（如果是 HTTPS）</strong>  </p><ul><li><strong>如果使用 HTTPS 协议，TCP 连接建立后，客户端和服务器之间还要进行</strong> TLS/SSL 握手。</li><li><strong>该过程用于加密通信，确保数据传输的安全性：</strong></li></ul><ol><li><strong>浏览器请求服务器的证书。</strong></li><li><strong>服务器返回证书（包括公钥）。</strong></li><li><strong>浏览器验证证书是否合法，并生成会话密钥。</strong></li><li><strong>双方使用对称加密的方式进行加密数据交换。</strong></li></ol><p><strong>5. 发送 HTTP 请求</strong>  </p><p> <strong>连接建立后，浏览器会发送一个 HTTP 请求 给服务器，请求的内容包括：</strong>  </p><ul><li><strong>请求方法</strong>（如 GET、POST)</li><li><strong>请求的 URL 路径</strong></li><li><strong>请求头信息（如浏览器的 User-Agent、Cookie、缓存等信息）</strong></li><li><strong>如果是 POST 请求，还会包括请求体（如表单数据）</strong></li></ul><p><strong>6. 服务器处理请求</strong>  </p><ul><li><strong>根据 URL 路径查找对应的资源（如 HTML 文件、API 数据）。</strong></li><li><strong>如果需要，则查询数据库、执行业务逻辑等。</strong></li><li><strong>服务器根据处理结果生成 HTTP 响应，通常包括状态码、响应头和响应体。</strong></li></ul><p><strong>7. 返回 HTTP 响应</strong>  </p><p> <strong>服务器返回的 HTTP 响应 包含  :</strong></p><ul><li><strong>状态码</strong>：表示请求的结果（如 200 表示成功，404 表示未找到资源，500 表示服务器错误等）。</li><li><strong>响应头</strong>：包括内容类型（如 Content-Type: text/html）、缓存控制、Cookie 等信息。</li><li><strong>响应体</strong>：即请求的实际内容（如 HTML 页面、JSON 数据、图片等）。</li></ul><p><strong>8. 浏览器渲染页面</strong>  </p><p> <strong>浏览器接收到 HTTP 响应后，开始渲染页面，主要流程如下  :</strong></p><ol><li><strong>解析 HTML：将 HTML 文档解析为 DOM（文档对象模型）树。</strong>  </li><li><strong>解析 CSS：下载并解析样式表，生成 CSSOM（CSS 对象模型）树。</strong>  </li><li><strong>构建渲染树：将 DOM 树与 CSSOM 树结合，生成渲染树，决定每个元素的样式与位置。</strong>  </li><li><strong>布局与绘制：计算每个元素的位置和大小，并将其绘制到屏幕上。</strong>  </li><li><strong>执行 JavaScript：浏览器解析并执行 HTML 中的</strong> <script> <strong>标签，可能会改变 DOM 树的结构并触发重新渲染。</strong>  </li><li><strong>处理资源请求：如果页面中有外部资源（如图片、视频、CSS、JS 文件），浏览器会发起新的 HTTP 请求来下载这些资源。</strong> </li></ol><p><strong>9. 后续请求与优化</strong>  </p><ul><li><strong>浏览器会根据 HTML 中的</strong> <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code><strong>,</strong> <code>&lt;link&gt;</code> 等标签继续发起新的 HTTP 请求。</li><li><strong>浏览器还会利用缓存机制、预加载（preload）、懒加载等技术优化页面加载速度和用户体验。</strong></li></ul><h2 id="2-第一次渲染和第二次渲染怎么做优化？"><a href="#2-第一次渲染和第二次渲染怎么做优化？" class="headerlink" title="2.第一次渲染和第二次渲染怎么做优化？"></a>2.第一次渲染和第二次渲染怎么做优化？</h2><p> 第一次渲染优化（首次加载优化）   </p><p>第一次渲染指的是用户第一次访问页面时，从输入 URL 到页面完全加载和呈现的过程。这个过程通常包括网络请求、资源下载和页面渲染等步骤。  </p><ol><li>减少关键资源的大小和数量</li></ol><ul><li>压缩资源：通过 gzip、Brotli 压缩 HTML、CSS、JavaScript 等文件，减少文件体积。</li><li>代码拆分（Code Splitting）：将 JavaScript 拆分成多个小文件，按需加载（如 Webpack 的 <code>splitChunks</code>）。</li><li>减少 CSS 阻塞：使用关键 CSS（Critical CSS），只加载页面首屏显示所需的样式，推迟加载非关键 CSS。</li></ul><ol><li>减少 HTTP 请求  </li></ol><ul><li>合并 CSS 和 JavaScript 文件：减少 HTTP 请求数量。</li><li>使用 HTTP/2 或 HTTP/3：通过并行加载多个资源，减少排队等待时间。</li><li>减少图像数量：合并小图标为雪碧图（sprite），或使用 CSS 生成图形。</li></ul><ol><li>使用内容分发网络（CDN）  </li></ol><p>将静态资源（CSS、JavaScript、图片等）托管在 CDN 上，减少资源的加载时间，特别是对于全球用户，提高资源的访问速度。  </p><ol><li>优化图像加载  </li></ol><ul><li>延迟加载（Lazy Load）：只在用户滚动到视图范围内时加载图像或其他媒体资源，减少首次渲染时加载的资源量。</li><li>图像优化：使用合适的图片格式（如 WebP），并根据不同设备提供不同分辨率的图片。</li></ul><ol><li>减少 JavaScript 负担  </li></ol><ul><li>异步加载 JavaScript：使用 <code>async</code> 或 <code>defer</code> 属性，避免阻塞页面渲染。  </li><li>树摇（Tree Shaking）：通过工具（如 Webpack）去除未使用的代码，减少打包后的文件大小。  </li><li>预加载关键资源：使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 提前加载关键资源，如字体、重要的 JavaScript 和 CSS 文件。  </li></ul><ol><li>预渲染和服务器端渲染（SSR）</li></ol><ul><li>SSR：将页面预先在服务器端渲染成 HTML，用户访问时不需要等待浏览器解析和执行 JavaScript，可以立即看到页面内容。</li><li>静态生成（Static Generation）：对于不频繁变化的页面，生成静态 HTML，减少服务器处理时间。</li><li>预渲染（Prerendering）：对于常访问的页面，可以在用户请求之前在服务器预渲染，并缓存渲染结果。</li></ul><ol><li>减少渲染阻塞资源  </li></ol><ul><li>CSS 优化：将关键 CSS 内联到 HTML 文件中，减少额外请求；推迟加载不重要的 CSS 文件。</li><li><p>移除阻塞 JavaScript：将不需要立即执行的脚本放置到页面底部，或使用 <code>defer</code>、<code>async</code> 来延迟加载。</p><p>第二次渲染优化（重复访问时的渲染优化）  </p><p>第二次渲染指的是用户再次访问同一个页面或应用时的加载过程。重点在于利用缓存、减少不必要的重复请求和渲染，提升加载速度。  </p></li></ul><ol><li>使用浏览器缓存</li></ol><ol><li>启用浏览器存储机制</li></ol><ol><li>Lazy Load 继续发挥作用</li></ol><ol><li>预缓存和预加载</li></ol><ol><li>减少重新计算与重绘</li></ol><ol><li>使用 HTTP/2 和 HTTP/3  </li></ol><h2 id="3-场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能"><a href="#3-场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能" class="headerlink" title="3.场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能"></a>3.场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能</h2><ol><li>防抖（Debounce）或者节流（Throttle）机制  </li></ol><p>为了避免用户短时间内频繁触发点赞请求，可以采用<strong>防抖</strong>或<strong>节流</strong>来控制操作的频率：</p><ul><li><strong>防抖（Debounce）</strong>：用户每次点击都会触发点赞操作，但在设定时间内，如果用户再次点击，则重置计时，只有在设定时间内不再点击时才会真正触发点赞请求。这种方法适合处理短时间内的多次点击，最终只会执行一次操作。</li><li><strong>节流（Throttle）</strong>：限制用户每隔一定时间才能触发点赞操作，比如设置 500 毫秒的时间间隔，避免用户在短时间内频繁操作，从而减少请求频率。这对于频繁操作较多的情况下非常有用。</li></ul><p>2.乐观更新</p><p> 为了提升用户体验，页面可以<strong>在用户点击时立即更新状态</strong>，而无需等待服务器返回结果。这样即使用户连续点击，页面的响应依然很快，然后后台异步处理请求。乐观更新可以结合防抖或者节流机制一起使用。</p><p>具体实现如下：</p><ol><li><strong>立即更新界面</strong>：当用户点击点赞按钮时，页面立即更新状态（例如切换点赞图标）。</li><li><strong>异步发送请求</strong>：在后台异步发送点赞/取消点赞请求，更新服务器的点赞状态。</li><li><strong>错误处理</strong>：如果请求失败，回滚本地状态，恢复为原始状态。</li></ol><ol><li>合并请求  </li></ol><p>如果用户在短时间内多次点击，可以考虑将多个操作合并为一个请求，从而减少向服务器发送的请求次数，降低服务器压力。</p><p>具体做法是，<strong>在短时间内批量处理点击事件</strong>，将多次点击操作合并成一次请求，最后的状态取决于用户的最终操作结果。</p><ul><li>例如：用户短时间内点击了 5 次，实际上只会发出一次请求，且最终根据点击次数的奇偶性来决定是点赞还是取消点赞。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖函数（Debounce）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流函数（Throttle）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - lastCall &gt;= interval) &#123;</span><br><span class="line">      lastCall = now;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设点赞操作是 likePost</span></span><br><span class="line"><span class="keyword">const</span> handleLike = <span class="title function_">debounce</span>(likePost, <span class="number">300</span>); <span class="comment">// 或者使用 throttle</span></span><br></pre></td></tr></table></figure><h2 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常见的传输层协议，它们的主要区别在于连接模式、可靠性、数据传输方式等。下面列出了它们在多个方面的区别：  </p><ol><li>连接与无连接  </li><li>可靠性  </li></ol><ol><li>有序性</li></ol><ul><li><strong>TCP</strong>：保证数据包按顺序到达接收端。即使数据包以不同顺序到达，TCP 也会对它们进行重新排序，确保数据的顺序性。</li><li><strong>UDP</strong>：不保证数据的顺序性。UDP 数据报可能会乱序到达接收端，接收端需要自行处理数据顺序问题。</li></ul><ol><li><p>数据传输方式  </p><p><strong>TCP</strong>：基于<strong>字节流    UDP：基于报文</strong></p></li><li><p>速度与效率</p></li></ol><ul><li>TCP：由于其需要建立连接、确认和重传机制，TCP 的可靠性较高，但这些特性会带来一定的开销，因此速度较慢，效率较低。</li><li>UDP：因为没有连接建立、确认和重传机制，UDP 协议非常轻量且传输速度快，非常适合要求低延迟或高实时性的数据传输。</li></ul><h2 id="5-说一说promise"><a href="#5-说一说promise" class="headerlink" title="5.说一说promise"></a>5.说一说promise</h2><p><code>Promise</code> 是 JavaScript 中的一种异步编程解决方案，用于处理异步操作并避免回调地狱。<code>Promise</code> 代表一个未来可能完成或失败的操作，以及它完成后的返回值或失败原因。  </p><p>一个 <code>Promise</code> 对象有三种状态：</p><ol><li><strong>Pending</strong>（进行中）：初始状态，操作尚未完成。</li><li><strong>Fulfilled</strong>（已成功）：操作成功完成，并返回了一个值。</li><li><p><strong>Rejected</strong>（已失败）：操作失败，并返回了一个原因</p><p>一旦 <code>Promise</code> 状态变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变（不可逆）  </p><p>Promise 的用法  </p></li><li><p>创建 Promise  </p></li></ol><p>可以通过 <code>new Promise</code> 构造函数创建一个 <code>Promise</code> 对象，传入一个执行器（executor）函数，该函数有两个参数：</p><ul><li><code>resolve</code>: 当操作成功时调用，并传递结果。</li><li><code>reject</code>: 当操作失败时调用，并传递错误原因。</li></ul><ol><li>使用 <code>.then()</code> 和 <code>.catch()</code></li></ol><p><code>Promise</code> 的结果通过 <code>.then()</code> 方法处理。当 <code>Promise</code> 成功（fulfilled）时，会执行 <code>.then()</code> 中的回调函数；当 <code>Promise</code> 失败（rejected）时，会执行 <code>.catch()</code> 中的回调函数。  </p><ol><li>finally()</li></ol><p><code>.finally()</code> 方法用于在 <code>Promise</code> 结束后（无论是成功还是失败）执行某个回调函数，常用于清理资源等操作。</p><h3 id="Promise-链式调用"><a href="#Promise-链式调用" class="headerlink" title="Promise 链式调用"></a><strong>Promise 链式调用</strong></h3><p><code>Promise</code> 支持链式调用，即可以在一个 <code>.then()</code> 之后继续调用另一个 <code>.then()</code>，这样多个异步操作可以按顺序执行。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h3><p><code>Promise.all()</code> 方法用于并行处理多个 <code>Promise</code>，它接受一个包含多个 <code>Promise</code> 的可迭代对象（如数组）。当所有 <code>Promise</code> 都成功时，<code>Promise.all()</code> 返回一个包含每个 <code>Promise</code> 成功结果的数组；如果有任何一个 <code>Promise</code> 失败，则返回该失败原因。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h3><p><code>Promise.race()</code> 方法接受多个 <code>Promise</code>，并返回最先完成的那个 <code>Promise</code>，无论是成功还是失败。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h3><p><code>Promise.any()</code> 方法接受多个 <code>Promise</code>，只要其中有一个 <code>Promise</code> 成功，返回该 <code>Promise</code> 的结果。如果所有的 <code>Promise</code> 都失败，它会返回一个包含所有错误的聚合错误。</p><p><code>async/await</code> 是 <code>Promise</code> 的语法糖    让异步操作看起来像同步代码。  </p><ol><li>Promise 是基础：</li></ol><ul><li><code>Promise</code> 是一种对象，代表异步操作的最终完成（或失败）及其结果。</li><li><code>async/await</code> 的本质依赖于 <code>Promise</code>，每个 <code>async</code> 函数实际上都返回一个 <code>Promise</code>，即使你没有显式地返回 <code>Promise</code> 对象。</li></ul><ol><li>async/await 是 Promise 的语法糖：</li></ol><ul><li>使用 <code>async/await</code> 可以让异步代码看起来像同步代码，更加直观易读。</li><li><code>await</code> 后面的表达式需要是一个返回 <code>Promise</code> 的函数，<code>await</code> 会暂停该 <code>async</code> 函数的执行，直到 <code>Promise</code> 解决（resolve）或拒绝（reject），然后继续执行。</li></ul><h2 id="6-函数柯里化"><a href="#6-函数柯里化" class="headerlink" title="6.函数柯里化"></a>6.函数柯里化</h2><p>柯里化（Currying）是一种将接受多个参数的函数转换为一系列接受单一参数的函数的技术。它使函数可以部分应用其参数，即每次调用函数时传入一个参数，返回一个新函数，该新函数等待下一个参数，直到所有参数都传入后，函数执行并返回结果。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arity = fn.<span class="property">length</span>; <span class="comment">// 获取函数的参数个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的参数数量小于函数的参数数量，返回一个新的函数，继续接受参数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args); <span class="comment">// 如果参数足够，调用原始函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...nextArgs</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curried</span>(...args, ...nextArgs); <span class="comment">// 合并参数并继续调用</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们可以通过一个例子来测试这个柯里化函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-浏览器输入URL会发生什么&quot;&gt;&lt;a href=&quot;#1-浏览器输入URL会发生什么&quot; class=&quot;headerlink&quot; title=&quot;1.浏览器输入URL会发生什么&quot;&gt;&lt;/a&gt;1.浏览器输入URL会发生什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.URL 解析&lt;/</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>7-29</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d9.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d9.html</id>
    <published>2024-07-29T10:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>代码如下：<strong>这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 递归法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，返回它的最大深度 3 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p><p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度。</p><p>所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        depth++; <span class="comment">// 记录深度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。</p><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录最小深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p>翻转一棵二叉树。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>其实就把每一个节点的左右孩子交换一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++代码迭代法（前序遍历）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 节点处理</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历是不行的"><a href="#中序遍历是不行的" class="headerlink" title="中序遍历是不行的"></a>中序遍历是不行的</h3><p><strong>因为使用递归的中序遍历，某些节点的左右孩子会翻转两次</strong></p><p>如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);         <span class="comment">// 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102.二叉树的层序遍历&quot;&gt;&lt;/a&gt;102.二叉树的层序遍历&lt;/h2&gt;&lt;p&gt;给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-28</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d8.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d8.html</id>
    <published>2024-07-28T15:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><p>二叉树结构定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h2 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h2><p>我们先看一下前序遍历。</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h2><p>再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p><p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了</strong>  其实就那两行代码交换执行顺序就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><h2 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h2><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>那么问题又来了，难道二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历改变代码顺序就可以实现中序 和 后序）？</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的递归遍历&quot;&gt;&lt;a href=&quot;#二叉树的递归遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的递归遍历&quot;&gt;&lt;/a&gt;二叉树的递归遍历&lt;/h1&gt;&lt;p&gt;二叉树结构定义&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-27</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d7.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d7.html</id>
    <published>2024-07-27T10:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><ul><li>输入: “(]”</li><li>输出: false</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。</p><p>如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p><p>先来分析一下 这里有三种不匹配的情况，</p><ol><li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。</li><li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。</li><li>第三种情况，字符串里右方向的括号多余了，所以不匹配。</li></ol><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p><p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h1><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：”abbaca”</li><li>输出：”ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>用栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。</p><p>然后再去做对应的消除操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><p>当然可以拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">empty</span>() || result.<span class="built_in">back</span>() != s) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)，返回值不计空间复杂度</li></ul><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h1><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, “ * “]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li></ul><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p><p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. 有效的括号&quot;&gt;&lt;/a&gt;20. 有效的括号&lt;/h1&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-26</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d6.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d6.html</id>
    <published>2024-07-26T10:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-右旋字符串"><a href="#1-右旋字符串" class="headerlink" title="1.右旋字符串"></a>1.右旋字符串</h1><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><p>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><p>输出：输出共一行，为进行了右旋转操作后的字符串。</p><p>数据范围：1 &lt;= k &lt; 10000, 1 &lt;= s.length &lt; 10000;</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>下意识会想到申请一个额外的数组空间，就能很简单的实现</p><p>使用整体反转+局部反转就可以实现反转单词顺序的目的。</p><p>其实是分为前后两部分 分别进行reverse操作，然后最后对整个数组进行reverse操作，就达到了所需效果</p><p>亦或是，先进行整体的reverse，再分别进行前后两部分单独的reverse</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>(); <span class="comment">//获取长度</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + len - n); <span class="comment">// 先反转前一段，长度len-n ，注意这里是和版本一的区别</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + len - n, s.<span class="built_in">end</span>()); <span class="comment">// 再反转后一段</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 整体反转</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-459-重复的子字符串"><a href="#2-459-重复的子字符串" class="headerlink" title="2. 459.重复的子字符串"></a>2. 459.重复的子字符串</h1><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><ul><li>输入: “abab”</li><li>输出: True</li><li>解释: 可由子字符串 “ab” 重复两次构成。</li></ul><p>示例 2:</p><ul><li>输入: “aba”</li><li>输出: False</li></ul><p>示例 3:</p><ul><li>输入: “abcabcabcabc”</li><li>输出: True</li><li>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。）</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>暴力的解法， 就是一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。</p><h3 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h3><p>当一个字符串s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定也是由前后相同的子串组成。</p><p>那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><p>以上证明的充分性，接下来证明必要性：</p><p>如果有一个字符串s，在 s + s 拼接后， 不算首尾字符，如果能凑成s字符串，说明s 一定是重复子串组成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string t = s + s;</span><br><span class="line">    t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>()); t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">find</span>(s) != std::string::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// r</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数， 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。</p><h1 id="3-232-用栈实现队列"><a href="#3-232-用栈实现队列" class="headerlink" title="3.232.用栈实现队列"></a>3.232.用栈实现队列</h1><p>使用栈实现队列的下列操作：</p><p>push(x) — 将一个元素放入队列的尾部。<br>pop() — 从队列首部移除元素。<br>peek() — 返回队列首部的元素。<br>empty() — 返回队列是否为空。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>使用栈来模拟队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span> (stOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从stIn导入数据直到stIn为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">                stIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">        stOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>(); <span class="comment">// 直接使用已有的pop函数</span></span><br><span class="line">        stOut.<span class="built_in">push</span>(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stIn.<span class="built_in">empty</span>() &amp;&amp; stOut.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-225-用队列实现栈"><a href="#4-225-用队列实现栈" class="headerlink" title="4.225. 用队列实现栈"></a>4.225. 用队列实现栈</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时获得的元素就是栈顶的元素了</span></span><br><span class="line">        que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());    <span class="comment">// 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-右旋字符串&quot;&gt;&lt;a href=&quot;#1-右旋字符串&quot; class=&quot;headerlink&quot; title=&quot;1.右旋字符串&quot;&gt;&lt;/a&gt;1.右旋字符串&lt;/h1&gt;&lt;p&gt;字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-25</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d5.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d5.html</id>
    <published>2024-07-25T18:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p><p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p><p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为：”the sky is blue “</p><ul><li>移除多余空格 : “the sky is blue”</li><li>字符串反转：”eulb si yks eht”</li><li>单词反转：”blue is sky the”</li></ul><p>这样我们就完成了翻转字符串里的单词。</p><p>注意：开头 中间 结尾 都会有多余的空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;151-翻转字符串里的单词&quot;&gt;&lt;a href=&quot;#151-翻转字符串里的单词&quot; class=&quot;headerlink&quot; title=&quot;151.翻转字符串里的单词&quot;&gt;&lt;/a&gt;151.翻转字符串里的单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-24</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d4.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d4.html</id>
    <published>2024-07-24T18:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = -<span class="number">1</span>, r = s.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">while</span>(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;  <span class="comment">// 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span>(++l &lt; --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p><p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p><p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p><p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p><p>样例输入：a1b2c3</p><p>样例输出：anumberbnumbercnumber</p><p>数据范围：1 &lt;= s.length &lt; 10000。</p><p>思路：<strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="type">int</span> sOldIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> sNewIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从后往前将数字替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (sOldIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[sOldIndex] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[sNewIndex--] = s[sOldIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            sOldIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344.反转字符串&quot;&gt;&lt;/a&gt;344.反转字符串&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-23</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d3.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d3.html</id>
    <published>2024-07-23T18:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><p>给定四个包含整数的队列列表 A , B , C , D ，计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D [l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>原因:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个单元如下:</p><ol><li>（0，0，0，1）-&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>（1，1，0，0）-&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p>本题解答步骤：</p><ol><li>首先定义一个unordered_map，key放a和b两数之和，value放a和b两数之和出现的次数。</li><li>遍历大A和大B的集群，统计两个集群元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用于统计a+b+c+d = 0出现的次数。</li><li>再遍历大C和大D内存，找到如果0-(c+d)在map中出现过的话，就用count把map中key对应的值来统计出现次数。</li><li>最后返回统计值count就可以了</li></ol><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap; <span class="comment">//key:a+b的数值，value:a+b数值出现的次数</span></span><br><span class="line">        <span class="comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : B) &#123;</span><br><span class="line">                umap[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计a+b+c+d = 0 出现的次数</span></span><br><span class="line">        <span class="comment">// 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span> - (c + d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间度：O(n^2)，最坏情况下A和B的值复杂度各不相同，相加产生的数字个数为n^2</li></ul><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> twoSumMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计nums1和nums2数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n1 <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> n2 <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = n1 + n2;</span><br><span class="line">            twoSumMap.<span class="title function_">set</span>(sum, (twoSumMap.<span class="title function_">get</span>(sum) || <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n3 <span class="keyword">of</span> nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> n4 <span class="keyword">of</span> nums4) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = n3 + n4;</span><br><span class="line">            count += (twoSumMap.<span class="title function_">get</span>(<span class="number">0</span> - sum) || <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为题目说只有小写字母，那可以采用空间换取时间的存储策略，用一个长度为26的磁盘记录来杂志里字母出现的次数。</p><p>然后再用 ransomNote 去验证该阵列是否包含 ransomNote 所需要的所有字母。</p><p>依然是存储在缓存法中的应用。</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            cnt[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">             <span class="keyword">if</span> (cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (cnt[i] &lt; 0)</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JS代码-1"><a href="#JS代码-1" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">ransomNote</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">magazine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>), </span><br><span class="line">        base = <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> magazine) &#123;  <span class="comment">// 记录 magazine里各个字符出现次数</span></span><br><span class="line">        strArr[s.<span class="title function_">charCodeAt</span>() - base]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> ransomNote) &#123; <span class="comment">// 对应的字符个数做--操作</span></span><br><span class="line">        <span class="keyword">const</span> index = s.<span class="title function_">charCodeAt</span>() - base;</span><br><span class="line">        <span class="keyword">if</span>(!strArr[index]) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果没记录过直接返回false</span></span><br><span class="line">        strArr[index]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p>思路：</p><p><strong>其实这个问题使用哈希法的</strong>操作并不十分合适，因为在去重的时候有很多需要注意的细节，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法在使用两层进行循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也可以在leetcode上通过，但是程序的执行时间依然比较长。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针高效法无法哈希法一些</strong>，那么来讲解一下具体实现的思路。</p><p>拿这个nums队列来举例，首先将队列排序，然后有一层进行循环，i从下标0的位置开始，同时在i+1的位置上定义一个下标left，在队列末尾定义下标right位置上。</p><p>仍然还是在吞吐量中找到 abc 使得 a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left和right呢，如果nums[i] + nums[left] + nums[right] &gt; 0就说明此时三数之和大了，因为CPU是排序后了，所以right下标就应该应该向左移动，这样才能得到三数之和一小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明此时三数之和小了，左就向右移动，才能让三数之和大一些，直到左与右相满足。</p><p>时间复杂度：O(n^2)。</p><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度： O(1)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 将数组排序</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i + <span class="number">1</span>, r = len - <span class="number">1</span>, iNum = nums[i]</span><br><span class="line">        <span class="comment">// 数组排过序，如果第一个数大于0直接返回res</span></span><br><span class="line">        <span class="keyword">if</span> (iNum &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (iNum == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">let</span> lNum = nums[l], rNum = nums[r], threeSum = iNum + lNum + rNum</span><br><span class="line">            <span class="comment">// 三数之和小于0，则左指针向右移动</span></span><br><span class="line">            <span class="keyword">if</span> (threeSum &lt; <span class="number">0</span>) l++ </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (threeSum &gt; <span class="number">0</span>) r--</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([iNum, lNum, rNum])</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>])&#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">                l++</span><br><span class="line">                r--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>一般来说哈希表都是用来快速判断一个元素是否出现集合里</strong>。</p><p>对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用。</p><p>哈希函数是把传入的key映射到符号表的索引上。</p><p>哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组（大小是受限的）</li><li>set（集合）</li><li>map（映射）</li></ul><p>在C++语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同</p><p>例如什么时候用std::set，什么时候用std::multiset，什么时候用std::unordered_set，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>没有限制数值的大小，就无法使用数组来做哈希表了</p><p><strong>主要因为如下两点：</strong></p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ul><p>所以此时一样的做映射的话，就可以使用set了。</p><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 使用unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>在两数之和中，map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>map是一种<code>&lt;key, value&gt;</code>的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p><p>C++提供如下三种map：</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p>std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）</p><p>1.两数之和中并不需要key有序，选择std::unordered_map 效率更高！</p><p>在454.四数相加中我们提到了其实需要哈希的地方都能找到map的身影。</p><p>关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而18. 四数之和，15.三数之和是一个数组（集合）里找到和为0的组合，可就难很多了！</p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><p>所以18. 四数之和，15.三数之和都推荐使用双指针法！</p><p><strong>强调：虽然map是万能的，以上详细介绍了什么时候用数组，什么时候用set</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;454-四数相加II&quot;&gt;&lt;a href=&quot;#454-四数相加II&quot; class=&quot;headerlink&quot; title=&quot;454.四数相加II&quot;&gt;&lt;/a&gt;454.四数相加II&lt;/h2&gt;&lt;p&gt;给定四个包含整数的队列列表 A , B , C , D ，计算有多少个元组 </summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-22</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d2.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d2.html</id>
    <published>2024-07-22T18:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>首先什么是哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实直白来讲其实数组就是一张哈希表。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先看暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。</p><p>暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。</p><p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><p>需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</p><p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串s中字符出现的次数，统计出来了。</p><p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。</p><p>那么最后检查一下，<strong>record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。</strong></p><p>最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。</p><p>时间复杂度为O(n)，空间上因为定义的是一个常量大小的辅助数组，所以空间复杂度为O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> !== t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> base = <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">        resSet[i.<span class="title function_">charCodeAt</span>() - base]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!resSet[i.<span class="title function_">charCodeAt</span>() - base]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        resSet[i.<span class="title function_">charCodeAt</span>() - base]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择</p><p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n + m) m 是最后要把 set转成vector</li><li>空间复杂度: O(n)</li></ul><p>本题后面 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：</p><ul><li>1 &lt;= nums1.length, nums2.length &lt;= 1000</li><li>0 &lt;= nums1[i], nums2[i] &lt;= 1000</li></ul><p>所以就可以 使用数组来做哈希表了， 因为数组都是 1000以内的。</p><p>对应C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 默认数值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123; <span class="comment">// nums1中出现的字母在hash数组中做记录</span></span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123; <span class="comment">// nums2中出现话，result记录</span></span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(m + n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据数组大小交换操作的数组</span></span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span> &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _ = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nums1Set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums1);</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="comment">// for(const n of nums2) &#123;</span></span><br><span class="line">    <span class="comment">//     nums1Set.has(n) &amp;&amp; resSet.add(n);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 循环 比 迭代器快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums2.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nums1Set.<span class="title function_">has</span>(nums2[i]) &amp;&amp; resSet.<span class="title function_">add</span>(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(resSet);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul><p>由于 <code>set.end()</code> 是一个表示集合末尾的迭代器（实际上是指向最后一个元素之后的位置），因此如果 <code>set.find(sum)</code> 返回的不是 <code>set.end()</code>，那么意味着 <code>sum</code> 的值在 <code>set</code> 中已经被找到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">            n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// n出现过，证明已陷入无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (m.<span class="title function_">has</span>(n)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        m.<span class="title function_">set</span>(n, <span class="number">1</span>)</span><br><span class="line">        n = <span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Set()更简洁</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        sum += (n % <span class="number">10</span>) ** <span class="number">2</span>;</span><br><span class="line">        n =  <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();   <span class="comment">// Set() 里的数是惟一的</span></span><br><span class="line">    <span class="comment">// 如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数</span></span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">1</span> &amp;&amp; !set.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">        set.<span class="title function_">add</span>(n);</span><br><span class="line">        n = <span class="title function_">getSum</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n === <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)</p><p>首先我再强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。应该想到使用哈希法了</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]); </span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">            <span class="comment">// map.insert(pair&lt;int, int&gt;(nums[i], i)); </span></span><br><span class="line">            map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;  <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">    <span class="keyword">if</span> (hash[target - nums[i]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, hash[target - nums[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    hash[nums[i]] = i;   <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表理论基础&quot;&gt;&lt;a href=&quot;#哈希表理论基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表理论基础&quot;&gt;&lt;/a&gt;哈希表理论基础&lt;/h2&gt;&lt;h3 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-21</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d1.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d1.html</id>
    <published>2024-07-21T18:30:00.000Z</published>
    <updated>2024-10-26T14:35:34.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p><p>初始时，cur指向虚拟头结点，然后进行修改指针的三步操作</p><p>对应的C++代码实现如下： </p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* result = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head), temp = ret;</span><br><span class="line">  <span class="keyword">while</span> (temp.<span class="property">next</span> &amp;&amp; temp.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = temp.<span class="property">next</span>.<span class="property">next</span>, pre = temp.<span class="property">next</span>;</span><br><span class="line">    pre.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span> = pre;</span><br><span class="line">    temp.<span class="property">next</span> = cur;</span><br><span class="line">    temp = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span> || head.<span class="property">next</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> after = head.<span class="property">next</span>;</span><br><span class="line">  head.<span class="property">next</span> = <span class="title function_">swapPairs</span>(after.<span class="property">next</span>);</span><br><span class="line">  after.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> after;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：</p><p>输入：head = [1,2], n = 1 输出：[1]</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><p>思路是这样的，但要注意一些细节。</p><p>定义fast指针和slow指针，初始值为虚拟头结点</p><p><strong>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）</strong></p><p>fast和slow同时移动，直到fast指向末尾</p><p>删除slow指向的下一个节点</p><p>此时不难写出如下:</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class="line">        <span class="comment">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class="line">        <span class="comment">// delete tmp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="JS代码-1"><a href="#JS代码-1" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建哨兵节点，简化解题逻辑</span></span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">  <span class="keyword">let</span> fast = dummyHead;</span><br><span class="line">  <span class="keyword">let</span> slow = dummyHead;</span><br><span class="line">  <span class="keyword">while</span> (n--) fast = fast.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">while</span> (fast.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    slow = slow.<span class="property">next</span>;</span><br><span class="line">    fast = fast.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>。 这里同学们要注意，交点不是数值相等，而是指针相等。</p><p>我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置。</p><p>此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。</p><p>否则循环退出返回空指针。</p><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n + m)</li><li>空间复杂度：O(1)</li></ul><h3 id="JS代码-2"><a href="#JS代码-2" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getListLen = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">       len++;</span><br><span class="line">       cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curA = headA,curB = headB,</span><br><span class="line">        lenA = <span class="title function_">getListLen</span>(headA),   <span class="comment">// 求链表A的长度</span></span><br><span class="line">        lenB = <span class="title function_">getListLen</span>(headB);  </span><br><span class="line">    <span class="keyword">if</span>(lenA &lt; lenB) &#123;       <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 交换变量注意加 “分号” ，两个数组交换变 量在同一个作用域下时</span></span><br><span class="line">        <span class="comment">// 如果不加分号，下面两条代码等同于一条代码: [curA, curB] = [lenB, lenA]</span></span><br><span class="line">        </span><br><span class="line">        [curA, curB] = [curB, curA];</span><br><span class="line">        [lenA, lenB] = [lenB, lenA];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = lenA - lenB;   <span class="comment">// 求长度差</span></span><br><span class="line">    <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>) &#123;       <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        curA = curA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(curA &amp;&amp; curA !== curB) &#123;  <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        curA = curA.<span class="property">next</span>;</span><br><span class="line">        curB = curB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p><p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p><p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p><p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p><h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p><p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><h3 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JS代码-3"><a href="#JS代码-3" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种循环实现方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先判断是否是环形链表</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow =head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span> &amp;&amp; fast!== slow) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast.<span class="property">next</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast !== slow) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow =head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast !== slow) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;24. 两两交换链表中的节点&lt;/h2&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
