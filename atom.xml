<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陶同学&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/85a0cbb73a82a62a3f9fc11c5e6f5f5c</icon>
  <subtitle>hhh</subtitle>
  <link href="https://daixueshengt.github.io/atom.xml" rel="self"/>
  
  <link href="https://daixueshengt.github.io/"/>
  <updated>2024-10-09T11:02:41.953Z</updated>
  <id>https://daixueshengt.github.io/</id>
  
  <author>
    <name>陶同学</name>
    <email>2568510567@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wed Oct 09 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d7.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d7.html</id>
    <published>2024-10-09T15:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP2和HTTP3的区别"><a href="#1-HTTP2和HTTP3的区别" class="headerlink" title="1.HTTP2和HTTP3的区别"></a>1.HTTP2和HTTP3的区别</h2><p>HTTP/1.0、HTTP/2 和 HTTP/3（实际上是基于 QUIC 协议）</p><p>HTTP 协议经历了多次更新以适应不断增长的需求，提高性能、安全性和效率</p><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>特点：</p><ul><li>每个请求都需要建立一个新的 TCP 连接。</li><li>无状态：每个请求之间是独立的。</li><li>支持基本的身份验证和缓存机制。</li></ul><p>限制：由于每次请求都要重新建立连接，导致了较高的延迟和资源消耗。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>特点：</p><ul><li>引入了持久连接，允许在一个 TCP 连接上发送多个请求。</li><li>支持管道化，即客户端可以在一个连接中发送多个请求而无需等待每个请求的响应。</li><li>增加了 Host 头部，支持在同一 IP 地址上托管多个域名。</li></ul><p>改进：显著减少了因频繁建立连接而产生的开销，提高了网页加载速度。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>特点：</p><ul><li>多路复用（Multiplexing）：允许多个请求同时在一个连接上进行，减少了阻塞。</li><li>二进制分帧层（Binary Framing Layer）：将数据分割成更小的消息和帧，提高了效率。</li><li>服务器推送（Server Push）：服务器可以主动向客户端推送资源，而不需要客户端先发起请求。</li><li>请求优先级（Request Prioritization）：客户端可以指定哪些资源优先加载。</li></ul><p>安全性：虽然 HTTP/2 不强制要求加密，但大多数实现都默认使用 HTTPS（即 TLS 加密）。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>特点：</p><ul><li>基于 QUIC 协议：QUIC 是一个基于 UDP 的多路复用网络传输协议，旨在减少延迟并提供更好的拥塞控制。</li><li>减少握手延迟：QUIC 允许零往返时间（0-RTT）连接建立，这意味着如果客户端之前与服务器通信过，则可以立即开始发送数据。</li><li>更好的网络条件适应性：QUIC 包含先进的拥塞控制算法，可以更好地适应不同的网络环境。</li></ul><p>优势：相比 HTTP/2，HTTP/3 在减少延迟、提高可靠性和安全性方面有了进一步的提升。</p><p>演进过程：</p><ul><li><strong>从 HTTP/1.0 到 HTTP/1.1</strong>：主要是解决了连接效率的问题，通过引入持久连接和管道化来减少延迟。</li><li><strong>从 HTTP/1.1 到 HTTP/2</strong>：重点在于提高并发处理能力和优化数据传输效率，引入了多路复用等关键技术。</li><li><strong>从 HTTP/2 到 HTTP/3</strong>：目标是进一步降低延迟和提高网络稳定性，特别是针对移动网络和高延迟网络环境进行了优化。</li></ul><h2 id="2-强缓存与协商缓存"><a href="#2-强缓存与协商缓存" class="headerlink" title="2.强缓存与协商缓存"></a>2.强缓存与协商缓存</h2><p>缓存可以减少对服务器的请求次数，减轻服务器负载，加快页面加载速度。根据缓存策略的不同，通常可以分为强缓存（Strong Caching）和协商缓存（Negotiated Caching）两种类型。</p><h3 id="强缓存（Strong-Caching）"><a href="#强缓存（Strong-Caching）" class="headerlink" title="强缓存（Strong Caching）"></a>强缓存（Strong Caching）</h3><p>强缓存是指浏览器直接从本地缓存中读取资源，而不需要与服务器进行任何通信。当用户再次访问同一个资源时，如果该资源在强缓存的有效期内，浏览器会直接使用缓存中的版本，不会向服务器发送请求。</p><p>强缓存主要依赖于以下两个HTTP头部字段：</p><p><strong>Expires</strong>：这个字段指定了资源的过期时间，是一个绝对时间点。如果 <code>Cache-Control</code> 和 <code>Expires</code> 同时存在，<code>Cache-Control</code> 的优先级更高。</p><p><strong>Cache-Control</strong>：这个字段用于指定缓存策略</p><h3 id="协商缓存（Negotiated-Caching）"><a href="#协商缓存（Negotiated-Caching）" class="headerlink" title="协商缓存（Negotiated Caching）"></a>协商缓存（Negotiated Caching）</h3><p>协商缓存是指当强缓存失效后，浏览器会向服务器发送一个带有特定头部的请求，询问资源是否有更新。如果资源没有变化，服务器会返回一个 304 Not Modified 状态码，告诉浏览器继续使用缓存中的资源；如果有更新，服务器则会返回新的资源。协商缓存主要依赖于以下两个HTTP头部字段：</p><p><strong>ETag (Entity Tag)</strong>：服务器为每个资源生成一个唯一的标识符（ETag）。当资源发生变化时，ETag 也会相应改变。客户端在请求时可以通过 <code>If-None-Match</code> 头部发送上次获取的 ETag 值，服务器根据这个值判断资源是否已更改。</p><p><strong>Last-Modified / If-Modified-Since</strong>：服务器在响应头中包含 <code>Last-Modified</code> 字段，表示资源最后修改的时间。客户端在下次请求时通过 <code>If-Modified-Since</code> 头部发送这个时间戳，服务器根据这个时间戳判断资源是否已更改。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>强缓存</strong>：适用于那些很少或永远不会改变的静态资源，如图片、CSS 文件、JavaScript 文件等。通过设置较长的 <code>max-age</code>，可以显著减少这些资源的加载时间。</li><li><strong>协商缓存</strong>：适用于那些可能会定期更新的动态资源。虽然每次请求都会与服务器进行一次简短的通信，但只有当资源确实发生变化时才会重新下载，因此仍然可以有效减少带宽使用和服务器负载。</li></ul><h2 id="3-304状态码和403状态码"><a href="#3-304状态码和403状态码" class="headerlink" title="3. 304状态码和403状态码"></a>3. 304状态码和403状态码</h2><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><ul><li>304状态码表示客户端请求的资源未被修改。这通常发生在客户端使用了协商缓存机制的情况下。</li><li>当客户端请求一个资源时，如果该资源在服务器上的最后修改时间与客户端缓存中的资源相同，服务器会返回304状态码，而不是重新发送资源内容。</li></ul><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><ul><li>403状态码表示服务器理解请求客户端的请求，但拒绝执行此请求。通常是因为客户端没有足够的权限访问请求的资源。</li><li>这个状态码表明请求本身没有问题，但服务器出于某种原因不允许访问。</li></ul><p><strong>使用场景</strong>：</p><ul><li>客户端尝试访问受保护的资源，但没有提供正确的认证信息或权限不足。</li><li>服务器配置禁止访问某些目录或文件。</li><li>客户端的IP地址被服务器列入黑名单。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>304 Not Modified</strong>：表示资源未被修改，客户端可以从缓存中读取资源。</li><li><strong>403 Forbidden</strong>：表示客户端没有权限访问请求的资源。</li></ul><h2 id="4-cdn缓存"><a href="#4-cdn缓存" class="headerlink" title="4.cdn缓存"></a>4.cdn缓存</h2><p>CDN（Content Delivery Network，内容分发网络）是一种用于加速互联网内容传输的技术。通过在全球范围内分布的服务器节点，CDN 可以将内容缓存到离用户最近的节点，从而减少数据传输的延迟和带宽消耗，提高用户的访问速度和体验。</p><p><strong>内容上传</strong>：原始服务器（Origin Server）将内容上传到 CDN 的中心节点。内容可以是静态资源（如图片、CSS、JavaScript 文件）或动态内容（如视频流、API 响应）。</p><p><strong>内容分发</strong>：就近访问内容</p><p><strong>用户请求</strong>：用户向 CDN 发起请求，通常是通过 DNS 解析将请求重定向到最近的边缘节点。边缘节点接收到请求后，首先检查本地缓存中是否有请求的资源</p><p><strong>缓存命中</strong>：如果边缘节点的缓存中有请求的资源，并且资源未过期，边缘节点直接将资源返回给用户。这种情况下，请求不会到达原始服务器，减少了原始服务器的负载。</p><p><strong>缓存未命中</strong>：</p><ul><li>如果边缘节点的缓存中没有请求的资源或资源已过期，边缘节点会向原始服务器发起请求。</li><li>原始服务器返回资源后，边缘节点将其缓存起来，并返回给用户。</li><li>下次有相同的请求时，边缘节点可以直接从缓存中提供资源。</li></ul><p>CDN 缓存通过将内容缓存到离用户最近的边缘节点，显著提高了内容的访问速度和用户体验。合理的缓存策略和管理方法可以进一步优化 CDN 的性能，减少原始服务器的负载，提高整体系统的稳定性和可靠性。</p><h2 id="5-css盒模型"><a href="#5-css盒模型" class="headerlink" title="5.css盒模型"></a>5.css盒模型</h2><p>盒子由四个部分组成：内容区域（content）、内边距（padding）、边框（border）和外边距（margin）。</p><p>在标准盒模型（Standard Box Model）中，元素的总宽度和高度计算如下：</p><ul><li><strong>总宽度</strong> = <code>content width</code> + <code>padding left</code> + <code>padding right</code> + <code>border left</code> + <code>border right</code> + <code>margin left</code> + <code>margin right</code></li></ul><p>为了更方便地控制元素的尺寸，CSS 提供了一个 <code>box-sizing</code> 属性，可以改变盒模型的计算方式。</p><ul><li><strong>content-box</strong>（默认值）：使用标准盒模型，宽度和高度仅包括内容区域。</li><li><strong>border-box</strong>：宽度和高度包括内容区域、内边距和边框，但不包括外边距。</li></ul><h2 id="6-给行内元素设置margin和padding"><a href="#6-给行内元素设置margin和padding" class="headerlink" title="6.给行内元素设置margin和padding"></a>6.给行内元素设置margin和padding</h2><h3 id="行内元素（inline-elements）"><a href="#行内元素（inline-elements）" class="headerlink" title="行内元素（inline elements）"></a>行内元素（inline elements）</h3><p>行内元素（inline elements）和块级元素（block elements）在CSS中的行为有所不同。行内元素通常用于文本中的内容，如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code> 等。对于行内元素，设置 <code>margin</code> 和 <code>padding</code> 的效果有一些限制，但并不是完全没有作用。下面详细说明行内元素设置 <code>margin</code> 和 <code>padding</code> 的效果和用法。</p><ul><li>行内元素的水平方向 <code>margin</code>（<code>margin-left</code> 和 <code>margin-right</code>）是有效的，可以用来增加元素之间的间距。</li></ul><ul><li>行内元素的垂直方向 <code>margin</code>（<code>margin-top</code> 和 <code>margin-bottom</code>）通常不起作用，因为行内元素不会影响其所在行的高度。</li></ul><ul><li>行内元素的水平方向 <code>padding</code>（<code>padding-left</code> 和 <code>padding-right</code>）是有效的，可以用来增加元素内部的间距。</li><li>行内元素的垂直方向 <code>padding</code>（<code>padding-top</code> 和 <code>padding-bottom</code>）也是有效的，但它们不会增加元素的高度，而是会影响行高的计算。</li></ul><h3 id="行内块级元素（inline-block）"><a href="#行内块级元素（inline-block）" class="headerlink" title="行内块级元素（inline-block）"></a>行内块级元素（inline-block）</h3><p>如果你希望行内元素的行为更像块级元素，可以将它们的 <code>display</code> 属性设置为 <code>inline-block</code>。这样，行内元素就可以同时具有行内元素和块级元素的特性，包括垂直方向的 <code>margin</code> 和 <code>padding</code> 也会生效。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>行内元素</strong>：<ul><li>水平方向的 <code>margin</code> 和 <code>padding</code> 是有效的。</li><li>垂直方向的 <code>margin</code> 通常不起作用。</li><li>垂直方向的 <code>padding</code> 是有效的，但不会增加元素的高度，而是影响行高的计算。</li></ul></li><li><strong>行内块级元素（display: inline-block）</strong>：<ul><li>所有方向的 <code>margin</code> 和 <code>padding</code> 都是有效的。</li></ul></li></ul><p>通过合理使用 <code>display: inline-block</code>，你可以更灵活地控制行内元素的布局和间距。</p><h2 id="7-js数据类型"><a href="#7-js数据类型" class="headerlink" title="7.js数据类型"></a>7.js数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>Undefined</strong>  <strong>Null</strong> <strong>Boolean</strong> <strong>Number </strong> <strong>String</strong>  <strong>Symbol</strong>    <strong>BigInt</strong></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>Object</strong> <strong>Array</strong>  <strong>Function</strong>  <strong>Date</strong>  <strong>RegExp</strong> </p><p>JavaScript 的数据类型分为基本数据类型和引用数据类型。基本数据类型包括 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code> 和 <code>bigint</code>，引用数据类型包括 <code>object</code>、<code>array</code>、<code>function</code>、<code>date</code> 和 <code>regexp</code>。</p><h2 id="8-es6新增特性"><a href="#8-es6新增特性" class="headerlink" title="8.es6新增特性"></a>8.es6新增特性</h2><h3 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1. 块级作用域"></a>1. 块级作用域</h3><p><strong>let 和 const 关键字</strong>：</p><ul><li><code>let</code>：声明块级作用域的变量，避免了 <code>var</code> 的变量提升问题。</li><li><code>const</code>：声明块级作用域的常量，一旦赋值就不能再改变。</li></ul><h3 id="2-解构赋值（Destructuring-Assignment）"><a href="#2-解构赋值（Destructuring-Assignment）" class="headerlink" title="2. 解构赋值（Destructuring Assignment）"></a>2. 解构赋值（Destructuring Assignment）</h3><ul><li>从数组和对象中提取数据并赋值给变量，使代码更简洁。</li></ul><h3 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3.模板字符串（Template Literals）"></a>3.模板字符串（Template Literals）</h3><ul><li>使用反引号（`）来创建多行字符串，并嵌入表达式。</li></ul><h3 id="4-默认参数（Default-Parameters）"><a href="#4-默认参数（Default-Parameters）" class="headerlink" title="4. 默认参数（Default Parameters）"></a>4. 默认参数（Default Parameters）</h3><ul><li>函数参数可以有默认值，如果调用时没有传入相应的参数，就使用默认值。</li></ul><h3 id="5-箭头函数（Arrow-Functions）"><a href="#5-箭头函数（Arrow-Functions）" class="headerlink" title="5.箭头函数（Arrow Functions）"></a>5.箭头函数（Arrow Functions）</h3><ul><li>简化函数的书写方式，没有自己的 <code>this</code> 上下文，继承外层函数的 <code>this</code> 值。</li></ul><h3 id="6-类（Classes）"><a href="#6-类（Classes）" class="headerlink" title="6. 类（Classes）"></a>6. 类（Classes）</h3><ul><li>提供了一种更清晰的面向对象编程方式，简化了构造函数和原型链的使用。</li></ul><h3 id="7-模块（Modules）"><a href="#7-模块（Modules）" class="headerlink" title="7. 模块（Modules）"></a>7. 模块（Modules）</h3><ul><li>支持模块化编程，可以导入和导出模块。</li></ul><h3 id="8-扩展运算符（Spread-Operator）"><a href="#8-扩展运算符（Spread-Operator）" class="headerlink" title="8. 扩展运算符（Spread Operator）"></a>8. 扩展运算符（Spread Operator）</h3><ul><li>用于展开数组或对象，方便操作和传递参数。</li></ul><h3 id="9-剩余参数（Rest-Parameters）"><a href="#9-剩余参数（Rest-Parameters）" class="headerlink" title="9. 剩余参数（Rest Parameters）"></a>9. 剩余参数（Rest Parameters）</h3><ul><li>用于收集函数中的多余参数，形成一个数组。</li></ul><h3 id="10-Set-和-Map"><a href="#10-Set-和-Map" class="headerlink" title="10. Set 和 Map"></a>10. Set 和 Map</h3><ul><li><strong>Set</strong>：表示一个值的集合，其中的值唯一且不重复。</li><li><strong>Map</strong>：表示一个键值对的集合，其中键的类型不受限制。</li></ul><h3 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. Promise</h3><ul><li>用于异步操作的处理，提供更清晰的错误处理和链式调用。</li></ul><h3 id="12-Symbol"><a href="#12-Symbol" class="headerlink" title="12. Symbol"></a>12. Symbol</h3><ul><li>表示独一无二的值，常用于对象属性的键，避免命名冲突。</li></ul><h3 id="13-Iterator-和-For-of-循环"><a href="#13-Iterator-和-For-of-循环" class="headerlink" title="13. Iterator 和 For-of 循环"></a>13. Iterator 和 For-of 循环</h3><ul><li><strong>Iterator</strong>：提供了一种统一的遍历接口。</li><li><strong>For-of 循环</strong>：用于遍历可迭代对象（如数组、字符串、Map、Set 等）。</li></ul><h3 id="14-Generator-函数"><a href="#14-Generator-函数" class="headerlink" title="14. Generator 函数"></a>14. Generator 函数</h3><ul><li>生成器函数可以暂停和恢复执行，提供了一种更灵活的异步编程方式。</li></ul><h2 id="9-深浅拷贝-以及实现的方式"><a href="#9-深浅拷贝-以及实现的方式" class="headerlink" title="9.深浅拷贝  以及实现的方式"></a>9.深浅拷贝  以及实现的方式</h2><h3 id="1-浅拷贝（Shallow-Copy）"><a href="#1-浅拷贝（Shallow-Copy）" class="headerlink" title="1. 浅拷贝（Shallow Copy）"></a>1. 浅拷贝（Shallow Copy）</h3><p>浅拷贝只复制对象的第一层属性，对于嵌套的对象或数组，它只是复制了引用，而不是实际的数据。因此，修改拷贝后的对象会影响到原对象。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>使用 Object.assign()</strong></p><p><strong>使用扩展运算符 …</strong></p><p><strong>使用 Array.prototype.slice() 或 Array.prototype.concat()</strong></p><h3 id="2-深拷贝（Deep-Copy）"><a href="#2-深拷贝（Deep-Copy）" class="headerlink" title="2.深拷贝（Deep Copy）"></a>2.深拷贝（Deep Copy）</h3><p>深拷贝会递归地复制对象的所有层级，确保拷贝后的对象与原对象完全独立，修改拷贝后的对象不会影响原对象。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>使用 JSON.parse() 和 JSON.stringify()</strong></p><ul><li>这是最简单的方法，但有一定的局限性，例如不能处理函数、循环引用和 <code>undefined</code>。</li></ul><p><strong>使用递归函数</strong></p><ul><li>这种方法可以处理更复杂的情况，包括函数、循环引用等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj; <span class="comment">// null or undefined</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="keyword">return</span> obj; <span class="comment">// 或者可以选择不复制函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj); <span class="comment">// 处理循环引用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      target[key] = <span class="title function_">deepCopy</span>(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125;, <span class="attr">d</span>: [<span class="number">3</span>, <span class="number">4</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title function_">deepCopy</span>(original);</span><br><span class="line"></span><br><span class="line">deepCopy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125;, d: [3, 4] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopy); <span class="comment">// &#123; a: 1, b: &#123; c: 3 &#125;, d: [3, 4] &#125;</span></span><br></pre></td></tr></table></figure><p><strong>使用第三方库</strong></p><ul><li>有许多第三方库提供了深拷贝的功能，如 <code>lodash</code> 的 <code>_.cloneDeep</code>。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>浅拷贝</strong>：只复制对象的第一层属性，对于嵌套的对象或数组，复制的是引用。修改拷贝后的对象可能会影响到原对象。</li><li>实现方式：<code>Object.assign()</code>、扩展运算符 <code>...</code>、<code>Array.prototype.slice()</code> 或 <code>Array.prototype.concat()</code>。</li><li><strong>深拷贝</strong>：递归地复制对象的所有层级，确保拷贝后的对象与原对象完全独立。修改拷贝后的对象不会影响原对象。</li><li>实现方式：<code>JSON.parse()</code> 和 <code>JSON.stringify()</code>、递归函数、第三方库（如 <code>lodash</code> 的 <code>_.cloneDeep</code>）。</li></ul><h2 id="10-实现promisify"><a href="#10-实现promisify" class="headerlink" title="10.实现promisify"></a>10.实现promisify</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **实现一个promisify()方法** </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promisify</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args,<span class="function">(<span class="params">err,reslut</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(reslut)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用promisify前</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用promisify后</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-HTTP2和HTTP3的区别&quot;&gt;&lt;a href=&quot;#1-HTTP2和HTTP3的区别&quot; class=&quot;headerlink&quot; title=&quot;1.HTTP2和HTTP3的区别&quot;&gt;&lt;/a&gt;1.HTTP2和HTTP3的区别&lt;/h2&gt;&lt;p&gt;HTTP/1.0、HTTP/</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Tue Oct 08 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d6.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d6.html</id>
    <published>2024-10-08T13:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-canvas实现贪吃蛇"><a href="#1-canvas实现贪吃蛇" class="headerlink" title="1.canvas实现贪吃蛇"></a>1.canvas实现贪吃蛇</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#mycanvas</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">100px</span> auto;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mycanvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> direction=<span class="number">2</span>;  <span class="comment">//方向 0表示左，1表示上，2表示右，3表示下</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">//计时器</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> len = <span class="number">10</span>; <span class="comment">//蛇的长度</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 蛇的初始位置</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> x=<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> y=<span class="number">8</span>; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> speed = <span class="number">100</span>;  <span class="comment">//速度</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> size = <span class="number">8</span>; <span class="comment">// 每一节蛇的大小</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> map=[]; <span class="comment">//用于存储蛇的运动轨迹</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 食物坐标</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> foodX;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> foodY;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">game</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span>=<span class="string">&#x27;green&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置运动方向进行绘制</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">switch</span>(direction)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">0</span>:</span></span><br><span class="line"><span class="language-javascript">            x=x-size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="language-javascript">            y=y-size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="language-javascript">            x=x+size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="language-javascript">            y=y+size;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 边界碰撞检测</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(x&gt;=canvas.<span class="property">width</span> || x&lt;<span class="number">0</span> || y&gt;=canvas.<span class="property">height</span> || y&lt;<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;game over&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          location.<span class="title function_">reload</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 自身碰撞检测</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> carch = map.<span class="title function_">some</span>(<span class="function"><span class="params">ele</span>=&gt;</span>ele.<span class="property">x</span>===x&amp;&amp;ele.<span class="property">y</span>===y);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(carch)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;game over&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          location.<span class="title function_">reload</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(map.<span class="property">length</span>&gt;len)&#123; <span class="comment">//数据长度大于蛇的长度</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 删除数组中的第一个元素 并且 擦除画板该区域</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">let</span> first = map.<span class="title function_">shift</span>();</span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="title function_">clearRect</span>(first.<span class="property">x</span>,first.<span class="property">y</span>,size,size);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        map.<span class="title function_">push</span>(&#123;x,y&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(x,y,size,size);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console.log(map);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 判断蛇是否吃到食物</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(foodX==x&amp;&amp; foodY==y)&#123;</span></span><br><span class="line"><span class="language-javascript">          len++;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">getFood</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        foodX = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">50</span>)*<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript">        foodY = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">50</span>)*<span class="number">8</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> has = map.<span class="title function_">some</span>(<span class="function"><span class="params">ele</span>=&gt;</span>ele.<span class="property">x</span>===foodX &amp;&amp; ele.<span class="property">y</span>===foodY);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(has)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span>=<span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(foodX,foodY,size,size);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">getFood</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      timer = <span class="built_in">setInterval</span>(game,speed);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 键盘时间用于改变方向</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">onkeyup</span>=<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(e.<span class="property">keyCode</span>&gt;=<span class="number">37</span> &amp;&amp; e.<span class="property">keyCode</span>&lt;=<span class="number">40</span>)</span></span><br><span class="line"><span class="language-javascript">          direction=e.<span class="property">keyCode</span>-<span class="number">37</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;mycanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串的排列"><a href="#2-字符串的排列" class="headerlink" title="2.字符串的排列"></a>2.字符串的排列</h2><p>详细描述<br>给你两个字符串 s1和s2，写一个函数来判断s2 是否包含 s1的排列。如果是，返回 true;否则，返回 false 。换句话说，s1的排列之一是 s2的子串 。<br>提示:<br>1&lt;= s1 .length, s2.length &lt;= 104。s1和 s2 仅包含小写字母<br>示例1<br>输入  “ab”,”eidbaooo”<br>输出 true<br>说明 s2 包含 s1的排列之一(“ba”)</p><p>可以使用滑动窗口和哈希计数的方法来解决</p><p>思路</p><ol><li>使用两个频率数组 <code>count1</code> 和 <code>count2</code> 来存储 <code>s1</code> 和 <code>s2</code> 中相应窗口内字符的频率。</li></ol><p><code>count1</code> 记录 <code>s1</code> 中每个字符的频率。</p><p><code>count2</code> 记录 <code>s2</code> 中当前窗口的字符频率。</p><ol><li>初始时，设置一个长度为 <code>s1.length()</code> 的窗口在 <code>s2</code> 上，然后滑动这个窗口检查 <code>count2</code> 是否和 <code>count1</code> 相等。 如果相等，说明当前窗口中的字符是 <code>s1</code> 的一个排列，返回 <code>true</code>。</li><li>如果整个 <code>s2</code> 都没有找到符合条件的子串，返回 <code>false</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">length</span>() &gt; s2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">count2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组 s1 和 s2 中的第一个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        count1[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否初始窗口匹配</span></span><br><span class="line">    <span class="keyword">if</span> (count1 == count2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在s2上进行窗口滑动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">length</span>(); i &lt; s2.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 增加新的字符到滑动窗口中</span></span><br><span class="line">        count2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="comment">// 移除旧的字符（窗口中的第一个）</span></span><br><span class="line">        count2[s2[i - s1.<span class="built_in">length</span>()] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (count1 == count2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;eidbaooo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkInclusion</span>(s1, s2)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-寻找目标值"><a href="#3-寻找目标值" class="headerlink" title="3.寻找目标值"></a>3.寻找目标值</h2><p>详细描述<br>m*n的二维数组 plants 记录了园林景观的植物排布情况，具有以下特性:<br>每行中，每棵植物的右侧相邻植物不矮于该植物;<br>每列中，每棵植物的下侧相邻植物不矮于该植物。<br>请判断 plants 中是否存在目标高度值 target.提示:<br>0&lt;=n&lt;=1000<br>0&lt;=m&lt;=1000<br>示例1<br>输入<br>[[2,3,6,8],[4,5,8,9],[5,9,10,12]],8<br>输出<br>true</p><p>这个问题的二维数组有行和列都递增的性质，可以使用一种高效的算法——从矩阵的右上角或者左下角开始搜索，以避免线性搜索。</p><p><strong>1. 从右上角开始</strong>：在矩阵的右上角元素 <code>(0, n-1)</code> 开始，如果这个元素等于目标值 <code>target</code>，则返回 <code>true</code>。如果这个元素大于 <code>target</code>，那么可以排除当前列，向左移动；如果这个元素小于 <code>target</code>，则可以排除当前行，向下移动。</p><p><strong>2.不断移动</strong>直到找到目标值或者移动到矩阵的边界之外，此时可以确定目标值不存在于矩阵中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; plants, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (plants.<span class="built_in">empty</span>() || plants[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = plants.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = plants[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右上角开始搜索</span></span><br><span class="line">    <span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (plants[row][col] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plants[row][col] &gt; target) &#123;</span><br><span class="line">            col--; <span class="comment">// 移动到左边一列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++; <span class="comment">// 移动到下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没有找到目标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; plants = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">searchMatrix</span>(plants, target)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中</p><ul><li>如果当前元素等于 <code>target</code>，返回 <code>true</code>。</li><li>如果当前元素大于 <code>target</code>，向左移动一列。</li><li>如果当前元素小于 <code>target</code>，向下移动一行。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-canvas实现贪吃蛇&quot;&gt;&lt;a href=&quot;#1-canvas实现贪吃蛇&quot; class=&quot;headerlink&quot; title=&quot;1.canvas实现贪吃蛇&quot;&gt;&lt;/a&gt;1.canvas实现贪吃蛇&lt;/h2&gt;&lt;figure class=&quot;highlight html</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Wed Oct 02 2024 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d5.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d5.html</id>
    <published>2024-10-02T23:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>WebSocket是一种协议  实时通讯利器</p><p>设计用于提供低延迟、全双工和长期运行的连接</p><p>WebSocket出现前的解决方案</p><p>轮询：客户端定期向服务器发送请求</p><p>长轮询：在客户端发出请求后，保持连接打开，等待新数据响应后再关闭连接</p><p>Comet：保持长连接，在返回请求后继续保持连接打开</p><p>WebSocket的优势</p><p>双向实时通信：允许在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的应用程序里，比http更加高效</p><p>降低延迟：链接一旦建立便会保持开放，数据可以在客户端和服务器之间以比http更低的延迟进行传输</p><p>更高效的资源利用：可以减少重复请求和响应的开销，因为它的连接只需要建立一次</p><p>为什么需要心跳机制？</p><p>为了保持 WebSocket 稳定的长连接，在连接建立之后，服务器和客户端之间通过心跳包来保持连接状态，以防止连接因为长时间没有数据传输而被切断。</p><p>一种特殊的数据包!</p><p>不包含任何实际数据，仅用来维持连接状态</p><p>一个空数据帧</p><p>定期发送，确保链接仍然有效，避免长时间没有数据传输而被中断</p><p>如果一段时间内没有收到对方的心跳包，就可以认为连接已经断开</p><p>WebSocket 的限制</p><p>不提供加密功能：如果有安全上的需求，需采用其他方式来确保安全性，如:SSL协议，设置黑白名单</p><p>不支持古老的浏览器：不支持IE10 以前的版本。需要使用 AJAX或者其他方式来进行替代</p><p>优化很重要：保持长连接需要服务器不断地维护和处理连接状态，需要优化性能</p><h2 id="什么是promise？"><a href="#什么是promise？" class="headerlink" title="什么是promise？"></a>什么是promise？</h2><p>是一种用于管理异步操作的对象基于状态机的概念，可以处于三种状态</p><p>Pending-等待中</p><p>Fulfilled-已完成</p><p>Rejected-已拒绝</p><p>Promise引入链式调用</p><p>更流程地处理多个异步操作，避免深陷层层嵌套的回调函数中</p><p>promise.all</p><p>使用场景：</p><p>需求：处理多个可能出现错误的异步操作，如果其中任何一个失败，就记录错误。</p><p>社交媒体应用发帖：</p><ul><li>用户可以创建帖子并上传多张照片</li><li>当用户提交时，同时上传所有照片</li><li>所有图片上传完成后，才能创建帖子</li></ul><p>promise.race</p><p>参数也是一个数组，返回结果是一个Promise对象，Promise状态为数组中最先返回结果的状态</p><p>实际应用：</p><ul><li>先尝试本地缓存</li><li>如果时间过久则获取服务器</li></ul><h2 id="浏览器存储-Cookie-Local-Storage-Session-Storage"><a href="#浏览器存储-Cookie-Local-Storage-Session-Storage" class="headerlink" title="浏览器存储: Cookie + Local Storage + Session Storage"></a>浏览器存储: Cookie + Local Storage + Session Storage</h2><p>http是一种无状态的协议 实际web应用中需要保存状态信息</p><p>cookie 是由服务端产生的内容，发送到浏览器保存本地，Cookie被来回传递，所以它主要就用于记录用户的 会话状态、身份验证和跟踪用户的行为等。</p><p>Cookie优点：</p><ul><li>在浏览器和服务器间来回传递，适用于跟踪用户行为</li><li>可以手动设置过期时间，灵活调节存储时间</li></ul><p>缺点：</p><ul><li>每次请求都会携带Cookie数据，增加流量浪费性能</li><li>在http中明文传输不够安全，容易被篡改</li><li>存储容量小，一般为4KB</li></ul><p>localStorage优点：</p><ul><li>存储容量较大，一般为 5M</li><li>存储的数据在客户端浏览器可以永久保存，不担心丢失</li><li>操作方便，API友好能通过 JavaScript 直接访问</li></ul><p>缺点：</p><ul><li>一网站只能访问自己域下的 LS</li><li>不支持在不同浏览器间共享数据</li></ul><p>sessionStorage优点：</p><ul><li>数据只存储在客户端</li><li>刷新页面仍有原来会话数据</li><li>每个标签/窗口间数据独立</li></ul><p>缺点：</p><ul><li>不适合长期存储</li><li>数据不共享，使用场景有限</li></ul><p>什么时候能用到SessionStorage</p><ul><li>假设有一个多步骤表单流程</li><li>用户在填写过程中可以点击 上一步/下一步 修改数据</li><li>使用 Session Storage 暂存内容</li></ul><p>三者相同点：都保存在浏览器端、不支持跨域</p><p>不同点</p><div class="table-container"><table><thead><tr><th></th><th>Cookie</th><th>localstorage</th><th>SessionStorage</th></tr></thead><tbody><tr><td>存储内容是否发送到服务器</td><td>每次请求都会发送</td><td>只保存本地，不与服务器发送任何交互</td><td>只保存本地，不与服务器发送任何交互</td></tr><tr><td>数据存储大小上的不同</td><td>不能超过4KB</td><td>可以达到5MB</td><td>可以达到5MB</td></tr><tr><td>存储数据有效期限不同</td><td>需要自行设置失效时间</td><td>永久有效</td><td>关闭浏览器前有效</td></tr><tr><td>作用域不同</td><td>同源同窗口都是共享的</td><td>同源同窗口都是共享的</td><td>不同窗口不共享</td></tr></tbody></table></div><p>选择Cookie：在客户端和服务器之间共享数据+长期存储<br>选择Local Storage：只在客户端长期存储 +无需与服务器交互<br>选择Session Storage：只在客户端 + 会话期间暂存</p><h2 id="https-网络传输协议"><a href="#https-网络传输协议" class="headerlink" title="https:网络传输协议"></a>https:网络传输协议</h2><p>加密的两种基本类型</p><p>对称加密：加密方与解密方共用一套秘钥</p><p>非对称加密：基于成对的密钥对，加密方与解密方分别持有公钥与私钥</p><p>对称加密弊端：很难安全地告知双方这套秘钥</p><p>非对称加密弊端：所需算力远大于对称加密</p><p>重点：HTTPS 正是通过先利用非对称加密传输对称加密的密钥</p><p>再利用对称加密传输实际内容这样的方式，保证了它的安全性</p><p>电子证书：就是由第三方机构开具的证明，其中写明了xx公钥属于xx域名</p><p>如果你要访问的是这个域名，证书上就是你要使用的公钥</p><p>明文传输密码没什么安全隐患？当然也不是，  https 网络传输一个基本的安全保障</p><p>https下依然会受到中间人攻击，采用更多层次的加密手段，代表着更高的破解成本，也会带来更安全地信息传输 </p><p>HTTPS 是个应用层的协议，在明文内容离开和到达浏览器的时候，浏览器已经分别完成了加密与解密</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;websocket&quot;&gt;&lt;a href=&quot;#websocket&quot; class=&quot;headerlink&quot; title=&quot;websocket&quot;&gt;&lt;/a&gt;websocket&lt;/h2&gt;&lt;p&gt;WebSocket是一种协议  实时通讯利器&lt;/p&gt;
&lt;p&gt;设计用于提供低延迟、全双</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-27</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d4.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d4.html</id>
    <published>2024-09-27T12:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应"><a href="#1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应" class="headerlink" title="1.实现 两列布局  左边固定，右边自适应 两边高度随内容自适应"></a>1.实现 两列布局  左边固定，右边自适应 两边高度随内容自适应</h2><ul><li><strong>Flexbox</strong> 和 <strong>Grid</strong>：现代布局方法，易于实现和维护。</li><li><strong>浮动（Float）</strong>：传统方法，适用于简单的布局。</li><li><strong>绝对定位（Absolute Positioning）</strong>：适用于需要精确控制位置的布局。</li><li><strong>表格布局（Table Layout）</strong>：模拟表格的布局方式，适用于需要对齐的布局。</li><li><strong>多列布局（Multi-column Layout）</strong>：主要用于文本内容的多列显示，也可以用来实现两列布局。</li></ul><p>选择哪种方法取决于你的具体需求和个人偏好。现代项目中，推荐使用 Flexbox 或 Grid 布局，因为它们提供了更多的灵活性和更好的浏览器支持。</p><h2 id="2-ul中包含两个-li-再生成-里面是，h1中的内容是Hello！然后将这个li插入到ul的头部"><a href="#2-ul中包含两个-li-再生成-里面是，h1中的内容是Hello！然后将这个li插入到ul的头部" class="headerlink" title="2.ul中包含两个 li 再生成,里面是，h1中的内容是Hello！然后将这个li插入到ul的头部"></a>2.ul中包含两个 li 再生成<li>,里面是<h1>，h1中的内容是Hello！然后将这个li插入到ul的头部</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 &lt;li&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> newLi = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 &lt;h1&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> newH1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            newH1.<span class="property">textContent</span> = <span class="string">&#x27;Hello!&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将 &lt;h1&gt; 插入到 &lt;li&gt; 中</span></span></span><br><span class="line"><span class="language-javascript">            newLi.<span class="title function_">appendChild</span>(newH1);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            ul.<span class="title function_">insertBefore</span>(newLi, ul.<span class="property">firstChild</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面是我的思路  代码简单 思路清晰 hhh</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 innerHTML 方法将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            list.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;li&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/li&gt;&#x27;</span> + list.<span class="property">innerHTML</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert LI at the Top of UL<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;insertLiAtTop()&quot;</span>&gt;</span>Insert LI at Top<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">insertLiAtTop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 &lt;ul&gt; 元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myList&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 insertAdjacentHTML 方法将新的 &lt;li&gt; 插入到 &lt;ul&gt; 的头部</span></span></span><br><span class="line"><span class="language-javascript">            list.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterbegin&#x27;</span>, <span class="string">&#x27;&lt;li&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/li&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-在微前端架构中，为了避免父级项目和子集项目之间的样式冲突"><a href="#3-在微前端架构中，为了避免父级项目和子集项目之间的样式冲突" class="headerlink" title="3.在微前端架构中，为了避免父级项目和子集项目之间的样式冲突"></a>3.在微前端架构中，为了避免父级项目和子集项目之间的样式冲突</h2><p>可以采取以下措施：</p><ol><li><strong>使用 CSS Modules</strong>：将样式作用域化。</li><li><strong>使用 scoped 样式</strong>：限制样式的作用范围。</li><li><strong>使用命名空间</strong>：为样式添加前缀或命名空间。</li><li><strong>使用 Shadow DOM</strong>：完全隔离样式。</li><li><strong>使用第三方库</strong>：利用微前端框架提供的工具和配置。</li></ol><p>通过这些方法，可以有效地管理和避免样式冲突，确保微前端项目的顺利运行。</p><h2 id="4-基于canvas技术实现在线签名和画板功能"><a href="#4-基于canvas技术实现在线签名和画板功能" class="headerlink" title="4.基于canvas技术实现在线签名和画板功能"></a>4.基于canvas技术实现在线签名和画板功能</h2><p>项目输出：</p><p>分为主画板，悬浮板，签名板 三块内容</p><p>功能从签名画板开始，一般是需要先获取签名画板并且初始化canvas画布（首先获取canvas元素，canvas元素.getContext(‘2d’)获取到的是canvas对象）</p><p>然后签名板功能需要监听鼠标事件，来完成书写。从以下三部分去考虑：</p><ol><li>当鼠标按下mousedown的时候，先确定起点位置 moveTo可以确定起点，但也要注意一个问题（clientX是相对屏幕的位置，我们需要的是相对于画板的位置 这里得用 offsetX）</li></ol><p>注意：此处 每次按下 beginPath() 每次绘制需要是一条新路径（如果不考虑这点 后面什么改变颜色 线条粗细 会有问题</p><ol><li>鼠标移动mousemove的时候，并且是在鼠标按下的时候 需要不断的加新点，光加点还不行，要连点成线。一边lineTo一边stroke</li><li>当鼠标松开的时候 关闭开关 不再回绘制了</li></ol><p>画完之后，是确认与清除功能</p><p>清除整个签名画板 用clearRect函数，从起点开始，清除一个宽高多少的矩形范围</p><p>确认的话，将绘制的签名转绘到悬浮板上，floatCtx.drawImage(sign,0,0,200,80)</p><p>然后通过拖动浮层板调整签名在主画板的位置</p><p>在点击确认导出的时候，将浮层画板的签名转绘到主画板上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">save</span>(<span class="params"></span>)&#123;</span><br><span class="line">mainCtx.<span class="title function_">drawImage</span>(float,left.<span class="property">value</span>,top.<span class="property">value</span>,<span class="number">200</span>,<span class="number">80</span>)</span><br><span class="line">    <span class="keyword">let</span> base64=main.<span class="title function_">toDataURL</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(base64);</span><br><span class="line">    <span class="comment">// 把拿到的base64发送给后端保存起来就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浅谈前端拖拽功能</p><p>前端组件 VueDraggable VueDraggablePlus  完全继承了 之前的Sortable.js的所有功能</p><p><a href="https://search.bilibili.com/all?from_source=webcommentline_search&amp;keyword=element%20plus&amp;seid=9318871269317883971">element plus</a>的拖拽实现不错，不借助定位  packages/hooks/use-draggable</p><p><a href="https://github.com/element-plus/element-plus/blob/dev/packages/hooks/use-draggable/index.ts">https://github.com/element-plus/element-plus/blob/dev/packages/hooks/use-draggable/index.ts</a></p><p>而传统实现拖拽的思路是：大方向主要是在mousedown，mousemove，mouseup的状态下，记录当前鼠标的坐标<code>startX=e.clientX</code>,<code>startY=e.clientY</code>;当前元素的左上角坐标<code>this.initialX=this.$refs.draggable.offsetLeft;</code> <code>this.initialY=this.$refs.draggable.offsetTop;</code></p><p>而后 在鼠标移动的过程中，需要去计算 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const deltaX = e.clientX - this.startX;</span><br><span class="line">const deltaY = e.clientY - this.startY; // 通过鼠标移动的距离计算</span><br><span class="line">const newX = this.initalX+deltaX;</span><br><span class="line">const newY = this.initalY+deltaY;</span><br></pre></td></tr></table></figure><p>鼠标松开时，解除拖拽状态</p><h2 id="5-页面输入-url-到页面渲染都发生了什么"><a href="#5-页面输入-url-到页面渲染都发生了什么" class="headerlink" title="5.页面输入 url 到页面渲染都发生了什么"></a>5.页面输入 url 到页面渲染都发生了什么</h2><ol><li>输入url </li><li>DNS解析</li><li>建立tcp连接</li><li>SSL/TLS握手（https）</li><li>发送http请求</li><li>服务器处理请求生成响应</li><li>浏览器接收http响应</li><li>解析html（构建 DOM树 CSSOM树  渲染树）</li><li>布局和绘制</li><li>加载资源</li></ol><h2 id="6-包装对象"><a href="#6-包装对象" class="headerlink" title="6.包装对象"></a>6.包装对象</h2><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object()</li><li>Function()</li><li>RegExp()</li><li>Date()</li><li>Error()</li><li>Symbol()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 构造函数创建出来的对象，封装了基本类型值 abc</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// &quot;object&quot;</span></span><br><span class="line">a.<span class="property">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf - 拿到封装对象里的基本类型数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应&quot;&gt;&lt;a href=&quot;#1-实现-两列布局-左边固定，右边自适应-两边高度随内容自适应&quot; class=&quot;headerlink&quot; title=&quot;1.实现 两列布局  左边固定，右边自适应 两边高度随内容自</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-26</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d3.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d3.html</id>
    <published>2024-09-26T22:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？"><a href="#1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？" class="headerlink" title="1.场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？"></a>1.场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？</h3><p> 可以使用 <strong>getter/setter</strong> 或 <strong>Proxy</strong> 来监控属性的变化 </p><ol><li>通过定义对象的 getter 和 setter 来监控 <code>a</code> 的变化，并在其被修改时更新 <code>c</code> 和 <code>d</code>。   </li><li>通过 Proxy 可以拦截对对象的所有操作，包括属性的读取和写入。  </li></ol><h3 id="2-场景：实现两行两列"><a href="#2-场景：实现两行两列" class="headerlink" title="2.场景：实现两行两列"></a>2.场景：实现两行两列</h3><p>grid flex float table  通常推荐使用 Flexbox 或 Grid</p><h3 id="3-弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思"><a href="#3-弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思" class="headerlink" title="3.弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思"></a>3.弹性布局里面，flex：1是哪些参数的缩写？都表示什么意思</h3><p>它实际上包含了三个属性：<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>。具体来说，<code>flex: 1;</code> 的完整形式是 <code>flex: 1 1 0;</code>。</p><p><strong>flex-grow：</strong>默认值是0，定义了子元素在主轴方向上的增长比例。如果可用空间多于所需空间，子元素将根据这个比例增长。设置值为<code>1</code> 表示该子元素可以增长，增长的比例为1。如果有多个子元素都设置了相同的 <code>flex-grow</code> 值，它们将平均分配剩余空间。</p><p><strong>flex-shrink</strong>：默认值1，定义了子元素在主轴方向上的收缩比例。如果可用空间不足，子元素将根据这个比例收缩。设置值为<code>1</code> 表示该子元素可以收缩，收缩的比例为1。如果有多个子元素都设置了相同的 <code>flex-shrink</code> 值，它们将平均分配不足的空间。</p><p><strong>flex-basis</strong>：默认值是auto，定义了子元素在主轴方向上的初始大小，可以是固定值（如 <code>100px</code>）或百分比（如 <code>50%</code>），也可以是 <code>auto</code>。设置值为<code>0</code> 表示子元素的初始大小为0。这意味着子元素将完全依赖于 <code>flex-grow</code> 和 <code>flex-shrink</code> 来确定其最终大小。</p><h3 id="4-同源策略是什么？CORS涉及到的参数有哪些？"><a href="#4-同源策略是什么？CORS涉及到的参数有哪些？" class="headerlink" title="4.同源策略是什么？CORS涉及到的参数有哪些？"></a>4.同源策略是什么？CORS涉及到的参数有哪些？</h3><p>仅当它们的协议、域名和端口号都相同，两个URL被认为是同源的</p><p>同源策略的主要目的是防止恶意网站读取其他网站的敏感数据。例如，当用户在一个浏览器窗口中登录了银行网站，而同时打开了另一个窗口访问了恶意网站，如果没有同源策略的保护，恶意网站可能尝试通过 JavaScript 访问银行网站的数据，从而导致用户信息泄露。</p><p>CORS（跨源资源共享）：是一种机制，它使用额外的 HTTP 头来告诉浏览器允许一个域上的 Web 应用程序去请求另一个域上的选定资源。这种机制为服务器提供了更细粒度的控制，允许它们指定哪些外部来源可以访问它们的资源。</p><h3 id="5-ES6中你知道哪些数据结构？"><a href="#5-ES6中你知道哪些数据结构？" class="headerlink" title="5.ES6中你知道哪些数据结构？"></a>5.ES6中你知道哪些数据结构？</h3><p><code>Map</code>是一个键值对的集合，其中键和值可以是任意类型。</p><p><code>Set</code>是一个存储唯一值的集合，不允许重复。</p><p><code>WeakMap</code>是一个键值对的集合，其中键必须是对象，值可以是任意类型。</p><p><code>WeakSet</code> 是一个存储唯一对象的集合，不允许重复。</p><p>Array数组，虽然数组不是 ES6 新引入的数据结构，但在 ES6 中，数组新增了一些有用的方法，如 <code>find</code>、<code>findIndex</code>、<code>includes</code> 等。</p><p>String字符串，虽然字符串也不是新的数据结构，但 ES6 为字符串增加了一些新的方法，如 <code>startsWith</code>、<code>endsWith</code>、<code>includes</code> 等。</p><p><code>Symbol</code>是一种新的原始数据类型，用于创建唯一的标识符。</p><p>主要用途是确保对象属性的名称不会发生冲突，特别是在大型应用程序或多个模块协同工作时。</p><p><code>Symbol</code> 可以用于创建私有属性，这些属性不会被意外地访问或修改。</p><h3 id="6-map和set的区别？以及map的key值可以是什么"><a href="#6-map和set的区别？以及map的key值可以是什么" class="headerlink" title="6.map和set的区别？以及map的key值可以是什么"></a>6.map和set的区别？以及map的key值可以是什么</h3><p><code>Map</code> 是一个键值对的集合，其中键和值可以是任意类型。</p><p><code>Set</code> 是一个存储唯一值的集合，不允许重复。</p><ul><li><code>Map</code> 提供了 <code>set</code>、<code>get</code> 、<code>has</code>等方法。</li><li><code>Set</code> 提供了 <code>add</code>、<code>delete</code>、<code>has</code> 等方法。</li></ul><h3 id="7-weakSet和Set有什么区别？"><a href="#7-weakSet和Set有什么区别？" class="headerlink" title="7.weakSet和Set有什么区别？"></a>7.weakSet和Set有什么区别？</h3><p><code>Set</code> 和 <code>WeakSet</code> 都是用于存储唯一值的集合，但 <code>Set</code> 更通用，可以存储任何类型的值，而 <code>WeakSet</code> 只能存储对象且对象是弱引用的。选择使用哪一个取决于你的具体需求。如果你需要存储任意类型的唯一值并且需要强引用，使用 <code>Set</code>；如果你需要存储对象且希望这些对象在没有其他引用时可以被垃圾回收，使用 <code>WeakSet</code>。</p><h3 id="8-Vue的双向绑定的原理"><a href="#8-Vue的双向绑定的原理" class="headerlink" title="8.Vue的双向绑定的原理"></a>8.Vue的双向绑定的原理</h3><p>Vue 的双向绑定主要依赖于两个关键技术：<strong>数据劫持</strong>（Data Binding）<strong>和发布订阅模式</strong>（Observer Pattern）</p><ol><li>数据劫持<ul><li>Vue使用Object.defineProperty(vue3中使用proxy)来劫持对象的属性，从而在数据发生变化时触发相应的更新操作。</li><li>在 Vue 2.x 中，Vue 使用 <code>Object.defineProperty</code> 来劫持对象的属性。每当数据对象的属性被访问或修改时，Vue 都能捕获到这些操作，并执行相应的逻辑。</li><li>在 Vue 3 中，Vue 使用 <code>Proxy</code> 来劫持对象的属性。<code>Proxy</code> 相比 <code>Object.defineProperty</code> 更加强大，可以拦截更多的操作，并且不需要递归遍历对象的所有属性。</li></ul></li><li>发布/订阅模式<ul><li>Vue 使用发布/订阅模式来实现视图和数据之间的通信。当数据发生变化时，Vue 会通知所有订阅者（即视图中的相关部分），这些订阅者会根据新的数据重新渲染视图。</li><li>观察者负责监听数据的变化。当数据发生变化时，观察者会通知所有订阅者。</li><li>订阅者负责更新视图。当数据发生变化时，订阅者会接收到通知并更新视图。</li></ul></li><li>模版编译<ul><li>Vue 的模板编译器会解析模板中的指令和表达式，并生成相应的渲染函数。在渲染过程中，Vue 会创建观察者和订阅者，从而实现数据和视图的双向绑定。</li></ul></li></ol><p>Vue 的双向数据绑定主要通过数据劫持和发布/订阅模式实现。数据劫持通过 <code>Object.defineProperty</code> 或 <code>Proxy</code> 劫持对象的属性，使其在数据变化时能够触发相应的更新操作。发布/订阅模式通过观察者和订阅者实现数据和视图之间的通信，确保数据变化时视图能够及时更新。模板编译器则负责解析模板中的指令和表达式，生成渲染函数，并创建观察者和订阅者。</p><h3 id="9-浏览器事件循环"><a href="#9-浏览器事件循环" class="headerlink" title="9.浏览器事件循环"></a>9.浏览器事件循环</h3><p>事件循环是浏览器处理异步任务的一种机制。它确保了浏览器可以在处理用户交互、网络请求、定时器等异步任务的同时，还能保持页面的响应性。</p><p>在单线程的 JavaScript 环境中，所有的代码都是按顺序执行的。但是，有些任务（如网络请求、定时器、用户输入等）需要等待一段时间才能完成。如果没有事件循环，浏览器就会在等待这些任务完成时阻塞，导致页面卡顿。事件循环的作用就是让这些异步任务在后台执行，不会阻塞主线程，从而保持页面的流畅。</p><ul><li><strong>任务队列</strong>：存放宏任务，如 <code>setTimeout</code>、点击事件、事件请求等。</li><li><strong>微任务队列</strong>：存放微任务，如 <code>Promise</code> 回调等。</li><li><strong>事件循环</strong>：每次执行一个宏任务后，清空微任务队列，然后进行渲染，再取下一个宏任务，如此循环。</li></ul><h3 id="10-浏览器缓存"><a href="#10-浏览器缓存" class="headerlink" title="10.浏览器缓存"></a>10.浏览器缓存</h3><p><strong>缓存类型：</strong></p><p><strong>强缓存</strong></p><p>强缓存是指浏览器在请求资源时，直接从本地缓存中读取资源，而不会向服务器发送请求。强缓存主要依赖于 HTTP 响应头中的 <code>Cache-Control</code> 和 <code>Expires</code> 字段。</p><p>Cache-Control</p><ul><li><code>max-age=&lt;seconds&gt;</code>：表示资源在本地缓存中的最大有效时间（以秒为单位）。例如，<code>Cache-Control: max-age=3600</code> 表示资源在本地缓存中有效 1 小时。</li><li><code>no-cache</code>：表示在每次请求资源时，浏览器都会向服务器发送请求，但服务器可能会返回 304 Not Modified 状态码，告诉浏览器使用缓存中的资源。</li><li><code>no-store</code>：表示浏览器不应缓存该资源。</li></ul><p>Expires</p><ul><li>表示资源在本地缓存中的过期时间，是一个具体的日期和时间。例如，<code>Expires: Wed, 21 Oct 2021 07:28:00 GMT</code>。如果同时存在 <code>Cache-Control</code> 和 <code>Expires</code>，优先使用 <code>Cache-Control</code>。</li></ul><p><strong>协商缓存</strong></p><p>协商缓存是指浏览器在请求资源时，会向服务器发送请求，但服务器可以根据资源的最新状态决定是否返回新的资源。协商缓存主要依赖于 HTTP 请求头中的 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 字段，以及响应头中的 <code>ETag</code> 和 <code>Last-Modified</code> 字段。</p><p><strong>缓存策略</strong>：</p><ul><li><strong>强缓存优先</strong>：浏览器首先检查强缓存是否有效，如果有效则直接使用缓存中的资源；如果无效，则进入协商缓存阶段。</li><li><strong>协商缓存</strong>：浏览器向服务器发送请求，服务器根据资源的最新状态决定是否返回新的资源。</li></ul><h3 id="11-怎么做缓存？前端这块怎么实现？"><a href="#11-怎么做缓存？前端这块怎么实现？" class="headerlink" title="11.怎么做缓存？前端这块怎么实现？"></a>11.怎么做缓存？前端这块怎么实现？</h3><p>前端实现缓存的方式有很多，主要包括通过 HTTP 缓存、Service Worker、本地存储（如 localStorage、sessionStorage、IndexedDB）等。下面详细介绍这些方法及其具体实现。</p><ol><li>HTTP 缓存是最常见的缓存方式，通过设置 HTTP 响应头来控制浏览器的缓存行为。</li><li>强缓存和协商缓存属于http缓存中的</li><li>Service Worker 是一种运行在浏览器后台的脚本，可以拦截和处理网络请求，实现离线缓存和资源预加载。</li><li>本地存储，<code>localStorage</code> 和 <code>sessionStorage</code> 是两种简单的键值对存储方式，适合存储少量数据。</li><li><code>IndexedDB</code> 是一种更复杂的本地存储方式，适合存储大量结构化数据。</li></ol><h3 id="12-箭头函数的特点"><a href="#12-箭头函数的特点" class="headerlink" title="12.箭头函数的特点"></a>12.箭头函数的特点</h3><ol><li>简洁的语法</li><li>没有自己的this</li><li>不能作为构造函数</li><li>没有arguments对象</li><li>没有原型属性</li><li>this绑定不可变</li><li>不能使用yield命令</li></ol><h3 id="13-HTTP2和HTTP3新增了哪些功能"><a href="#13-HTTP2和HTTP3新增了哪些功能" class="headerlink" title="13.HTTP2和HTTP3新增了哪些功能"></a>13.HTTP2和HTTP3新增了哪些功能</h3><p>HTTP/2 主要关注于提高现有网络基础设施上的性能，通过多路复用、头部压缩和服务端推送等技术显著改善了用户体验。而 HTTP/3 则是在此基础上进一步利用新的传输层协议 QUIC，解决了 TCP 协议的一些固有问题，如握手延迟和连接迁移等，从而提供了更加流畅和高效的网络体验。</p><h3 id="14-websocket是什么-它的应用场景是什么"><a href="#14-websocket是什么-它的应用场景是什么" class="headerlink" title="14.websocket是什么? 它的应用场景是什么"></a>14.websocket是什么? 它的应用场景是什么</h3><p>WebSocket 作为一种高效、低延迟的双向通信协议，特别适合于需要实时交互的应用场景。</p><p><strong>主要特点</strong></p><ol><li><strong>全双工通信</strong>：</li></ol><ul><li><ul><li>WebSocket 提供了真正的双向通信能力，即客户端和服务器可以同时发送和接收数据，而不需要像传统 HTTP 那样每次通信都需要发起一个新的请求。</li></ul></li></ul><ol><li><strong>低延迟</strong>：</li></ol><ul><li><ul><li>由于 WebSocket 连接是一直保持打开状态的，因此数据交换几乎是即时的，消除了 HTTP 请求/响应模型中的延迟。</li></ul></li></ul><ol><li><strong>轻量级</strong>：</li></ol><ul><li><ul><li>相比于传统的 HTTP 协议，WebSocket 的头部信息更小，减少了不必要的网络流量。</li></ul></li></ul><ol><li><strong>支持多种数据格式</strong>：</li></ol><ul><li><ul><li>WebSocket 可以传输文本数据和二进制数据，这使得它可以适用于各种应用场景。</li></ul></li></ul><p><strong>应用场景</strong></p><ol><li><strong>实时聊天应用</strong>：</li></ol><ul><li><ul><li>实时聊天是最常见的 WebSocket 应用场景之一。无论是个人聊天还是群聊，WebSocket 都能确保消息的即时传递。</li></ul></li></ul><ol><li><strong>在线游戏</strong>：</li></ol><ul><li><ul><li>在线多人游戏通常需要低延迟和高频率的数据交换，WebSocket 能够很好地满足这一需求，提供流畅的游戏体验。</li></ul></li></ul><ol><li><strong>实时协作工具</strong>：</li></ol><ul><li><ul><li>如在线文档编辑器、代码协作平台等，需要多个用户同时操作同一个文件或项目，WebSocket 可以实现实时同步更新。</li></ul></li></ul><ol><li><strong>实时数据分析和监控</strong>：</li></ol><ul><li><ul><li>对于需要实时更新数据的仪表盘或监控系统，WebSocket 可以快速地将最新的数据推送到客户端，使用户能够及时做出反应。</li></ul></li></ul><h3 id="15-CSS动画-怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？"><a href="#15-CSS动画-怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？" class="headerlink" title="15.CSS动画  怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？"></a>15.CSS动画  怎么实现一个位置到另一个位置的移动？动画怎么设置不循环播放？</h3><ol><li>定义关键帧动画：使用 <code>@keyframes</code> 规则来定义动画的关键帧。关键帧指定了动画在特定时间点的状态。</li></ol><ol><li>应用动画：使用 <code>animation</code> 属性将定义好的动画应用到元素上，并设置动画的播放次数。</li><li>控制动画播放次数<ul><li><code>animation-iteration-count</code> 属性可以设置动画的播放次数。默认值是 <code>1</code>，表示只播放一次。</li><li><code>forwards</code> 值可以确保动画结束后保持最后一个关键帧的状态。</li></ul></li></ol><h3 id="16-JS原型链-怎么给Array原型数组添加方法"><a href="#16-JS原型链-怎么给Array原型数组添加方法" class="headerlink" title="16.JS原型链   怎么给Array原型数组添加方法"></a>16.JS原型链   怎么给Array原型数组添加方法</h3><p><strong>原型链</strong>：当尝试访问一个对象的属性时，JavaScript 会首先在对象本身上查找该属性。如果找不到，就会在对象的原型上查找，依此类推，直到找到该属性或到达原型链的末端（即 <code>null</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 average 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">average</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 处理空数组</span></span><br><span class="line">  <span class="keyword">const</span> total = <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> total / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">average</span>()); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h3 id="17-闭包"><a href="#17-闭包" class="headerlink" title="17.闭包"></a>17.闭包</h3><p>闭包是在一个函数内部创建另一个函数，并且内部函数可以访问外部函数的变量和参数。即使外部函数已经执行完毕，内部函数仍然可以访问这些变量。</p><h4 id="闭包的优点"><a href="#闭包的优点" class="headerlink" title="闭包的优点"></a>闭包的优点</h4><ol><li><strong>数据封装</strong>：闭包可以用来封装变量，防止外部直接访问和修改。</li><li><strong>持久状态</strong>：闭包可以保持函数执行后的状态，使得函数可以记住之前的执行情况。</li><li><strong>模块化</strong>：闭包可以用于实现模块化编程，隐藏内部实现细节。</li></ol><h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><ol><li><strong>内存泄漏</strong>：如果闭包不当使用，可能会导致内存泄漏，因为闭包会持有对外部变量的引用，使得这些变量不能被垃圾回收。</li><li><strong>性能影响</strong>：闭包可能会增加内存和性能开销，特别是在大量使用闭包的情况下。</li></ol><p>闭包的核心在于内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。</p><h3 id="18-v-model的原理"><a href="#18-v-model的原理" class="headerlink" title="18.v-model的原理"></a>18.v-model的原理</h3><p><code>v-model</code> 是 Vue.js 中实现双向数据绑定的一种便捷方式。它通过 <code>v-bind</code> 和 <code>v-on</code> 的组合，将表单元素的值与 Vue 实例的数据属性绑定在一起，实现了数据的双向同步。</p><p>响应式设计的核心原理包括使用媒体查询来根据设 备特性应用不同的样式，使用灵活的布局技术（如百分比单位、弹性单位、Flexbox 和 Grid）来创建可伸缩的布局，以及确保图像和其他媒体元素在不同屏幕尺寸下保持比例并自动调整大小。通过这些技术，可以确保网页在不同设备和屏幕尺寸上提供良好的用户体验。</p><h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><ol><li>给一个数，判断是斐波那契数列数列的第几个数，如果不存在于斐波那契数列中，则返回-1</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.生成斐波那契数列，直到生成的数大于或等于给定的数。</span></span><br><span class="line"><span class="comment">// 2.检查生成的数列中是否存在给定的数。</span></span><br><span class="line"><span class="comment">// 3.如果存在，返回它的位置；如果不存在，返回 -1。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 生成斐波那契数列，直到生成的数大于或等于 n</span></span><br><span class="line">    <span class="keyword">let</span> fibSequence = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (fibSequence[fibSequence.<span class="property">length</span> - <span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">        fibSequence.<span class="title function_">push</span>(fibSequence[fibSequence.<span class="property">length</span> - <span class="number">1</span>] + fibSequence[fibSequence.<span class="property">length</span> - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 n 是否在斐波那契数列中</span></span><br><span class="line">    <span class="keyword">const</span> index = fibSequence.<span class="title function_">indexOf</span>(n);</span><br><span class="line">    <span class="keyword">return</span> index !== -<span class="number">1</span> ? index : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>压缩字符串 aaaabbbaaacccdd =&gt; a4b3a3c3d2  怎么实现</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compressString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> currentChar = s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === currentChar) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">`<span class="subst">$&#123;currentChar&#125;</span><span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line">            currentChar = s[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最后一个字符及其计数</span></span><br><span class="line">    result += <span class="string">`<span class="subst">$&#123;currentChar&#125;</span><span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> inputStr = <span class="string">&quot;aaaabbbaaacccdd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> compressedStr = <span class="title function_">compressString</span>(inputStr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(compressedStr);  <span class="comment">// 输出: a4b3a3c3d2</span></span><br></pre></td></tr></table></figure><ol><li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li></ol><p>说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 输入:  </span></span><br><span class="line"><span class="comment">// nums1 = [1,2,3,0,0,0], m = 3  </span></span><br><span class="line"><span class="comment">// nums2 = [2,5,6], n = 3  </span></span><br><span class="line"><span class="comment">// 输出: [1,2,2,3,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>)&#123;</span><br><span class="line">  <span class="comment">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span></span><br><span class="line">  <span class="keyword">let</span> i = m-<span class="number">1</span>, j = n-<span class="number">1</span>, k = m + n -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当两个数组都没遍历完时，指针同步移动</span></span><br><span class="line">  <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 取较大的值，从末尾往前填补</span></span><br><span class="line">    <span class="keyword">if</span>(nums1[i] &gt;= nums2[j])&#123;</span><br><span class="line">      nums1[k] = nums1[i]</span><br><span class="line">      i--;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      nums1[k] = nums2[j]</span><br><span class="line">      j--;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nums2 留下的情况，特殊处理一下</span></span><br><span class="line">  <span class="keyword">while</span>(j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    nums1[k] = nums2[j]</span><br><span class="line">    j--;</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每3秒打印一个helloworld，总共执行4次</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  repeatFunc = <span class="title function_">repeat</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">4</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeatFunc</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每3秒打印一个helloworld，总计执行4次</span></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">repeat</span>(<span class="params">fn, count, timeout</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span>  <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span>  num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span>  timer</span><br><span class="line">            timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                 num++</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= count) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>()</span><br><span class="line">                    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="title function_">fn</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">            &#125;, timeout);</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？&quot;&gt;&lt;a href=&quot;#1-场景：对象里有a、b、c、d四个属性，当a属性被修改时，需要联动的修改c、d两个属性，应该怎么做？&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-25</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d2.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d2.html</id>
    <published>2024-09-25T22:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码性能指标"><a href="#代码性能指标" class="headerlink" title="代码性能指标"></a>代码性能指标</h2><p><strong>健壮性</strong>:出现预期之外的情况，是否可控<br><strong>可复用性</strong>:后面出现同样功能，能否复用<br><strong>可拓展性</strong>:新功能是否容易拓展加入<br><strong>耦合度</strong>:模块发生变动，是否会相互影响<br><strong>简洁性</strong>:代码量的多少<br><strong>算法复杂度</strong>:实现某个操作需要的步骤<br><strong>可读性</strong>:他人阅读是否易懂</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p><strong>单一职责</strong>:一个模块应该只有一个职责<br><strong>最少知道</strong>:两个模块互相知道越少越好<br><strong>开闭原则</strong>:对修改关闭，对拓展开放<br><strong>接口隔离</strong>:一个模块不应该有他不需要的方法<br><strong>里氏替换原则</strong>: 基类可以被任何子类替换<br><strong>依赖倒置</strong>:实依赖抽象，不依赖具体</p><p>单一职责：对应于所有的语言中，我们之前说过编程本质上就是设计好模块和模块的沟通。而单一职责原则是我们设计模块应该做什么的最基本考虑。这个模块只负责自己的事，如果有额外事情，应该在独立为其他模块，而不应该在模块里增加。</p><p>最少知道：低耦合使我们永远追求的目标，而低耦合的前提就是两个模块之间不需要过多的业务相关，最好一个模块只需要掉另一个模块的接口就行。</p><p>开闭原则：对拓展开放，对修改关闭。我们平常去设计模块，如果以后有变更可能。可以准备一个拓展处可以是一个参数，也可以是一个方法。我们改代码也是一个道理，改动以前老代码，尽量新增而不要去修改。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><ol><li>创建型：怎么创建模块或对象的技巧</li><li>结构型：怎么设计一个模块的对外接口，以及和其他模块的组织结构</li><li>行为型：怎么解决模块之间的沟通问题，模块怎么沟通更低耦合</li></ol><h2 id="几道笔试题"><a href="#几道笔试题" class="headerlink" title="几道笔试题"></a>几道笔试题</h2><p>编写一个函数flattenArray，接收一个嵌套数组作为参数，返回一个一维数组。</p><p>示例输入:[1,[2,[3,4]],5]</p><p>示例编出:[1,2,3,4,5]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123;<span class="attr">input</span>:process.<span class="property">stdin</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> iter = r1[symbol.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span>(<span class="params"></span>)=&gt;(<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fattenArray</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">flat,toFlatten</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flat.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(toFlatten)?<span class="title function_">fattenArray</span>(toFlatten):toFlatten);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> line;</span><br><span class="line">  <span class="keyword">while</span>(line=<span class="keyword">await</span> <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> inputArray = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(line);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title function_">fattenArray</span>(inputArray);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 Stack 类，实现 push、pop方法</p><p>示例操作:stack.push(1); stack.push(2);console.log(stack.pop());示例输出:2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个 Stack 类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>=[];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">ele</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>===<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求数组中的最大值 可以用一个循环 但也可用一行代码  Math.max(…arr);</p><p>如何翻转一个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br></pre></td></tr></table></figure><p>找出任意html中的所有不重复的html标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findUniqueTags</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用一个 Set 数据结构来存储不重复的标签名称</span></span><br><span class="line">  <span class="keyword">const</span> tags = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有节点，并收集标签名称</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>) &#123;</span><br><span class="line">      tags.<span class="title function_">add</span>(node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>()); <span class="comment">// 保存标签名，统一转为小写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历子节点</span></span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(traverse);</span><br><span class="line">  &#125;)(<span class="variable language_">document</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(tags); <span class="comment">// 将 Set 转换为数组并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该函数来获取所有不重复的 HTML 标签</span></span><br><span class="line"><span class="keyword">const</span> uniqueTags = <span class="title function_">findUniqueTags</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueTags);</span><br></pre></td></tr></table></figure><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li>在函数中去调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(walker)&#125;</span><br><span class="line"><span class="title function_">get</span>()</span><br><span class="line">get.<span class="title function_">call</span>(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure><ol><li>函数作为对象的方法被调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;walker&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在跑步`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">run</span>()</span><br><span class="line">person.<span class="property">run</span>.<span class="title function_">call</span>(person)</span><br></pre></td></tr></table></figure><p>就这两种情况，一种是在函数中去调用，指向window。一种是函数作为对象的方法被调用</p><p>vue响应式原理  也是双向绑定的原理</p><h2 id="vue响应式原理-也是双向绑定的原理"><a href="#vue响应式原理-也是双向绑定的原理" class="headerlink" title="vue响应式原理  也是双向绑定的原理"></a>vue响应式原理  也是双向绑定的原理</h2><p>Vue2 中的响应式系统 </p><ol><li><strong>数据劫持</strong></li></ol><ul><li>当你在 Vue 的 <code>data</code> 中定义一个对象，例如 <code>&#123; name: &#39;Alice&#39; &#125;</code>，Vue 会使用 <code>Object.defineProperty</code> 把 <code>name</code> 属性变成一个“响应式”属性。</li><li>这意味着 Vue 在幕后对 <code>name</code> 属性进行了“劫持”，它添加了“getter”和“setter”。当你读取 <code>name</code> 时，Vue 的“getter”函数会被触发；当你修改 <code>name</code> 时，Vue 的“setter”函数会被触发。</li></ul><ol><li><strong>依赖收集</strong></li></ol><ul><li>每个“响应式”属性都有一个“依赖收集器”（一个数组或 Set），用来存储所有依赖于该属性的“观察者”（即订阅者）。</li><li>当你在模板中使用 <code>&#123;&#123; name &#125;&#125;</code> 绑定了一个数据，Vue 会把这个模板当作“观察者”，注册到 <code>name</code> 属性的依赖收集器中。</li><li>当 <code>name</code> 改变时，Vue 会通知它的所有“观察者”，重新计算和更新视图。</li></ul><ol><li><strong>通知更新</strong></li></ol><ul><li>当数据被修改时，Vue 的“setter”会被触发。<code>setter</code> 函数会告诉依赖收集器，让它的所有“观察者”重新执行，从而更新视图。  </li></ul><p>Vue 3 中的变化  </p><p>在 Vue 3 中，响应式系统用 <code>Proxy</code> 代替了 <code>Object.defineProperty</code>，这带来了以下优势  </p><ol><li><strong>性能提升</strong></li></ol><ul><li><code>Proxy</code> 可以直接劫持整个对象，而不是遍历每个属性，因此更高效。</li></ul><ol><li><strong>支持更多类型的数据</strong></li></ol><ul><li><code>Proxy</code> 可以监听对象的新增或删除属性，而 <code>Object.defineProperty</code> 不行。</li></ul><ol><li><strong>更好的可扩展性</strong></li></ol><ul><li>Vue 3 的响应式系统能处理更多场景，例如嵌套对象、数组操作等复杂数据结构。</li></ul><p>Vue 的响应式系统通过数据劫持和发布-订阅模式实现了自动跟踪数据变化并更新视图的功能，使得开发者不需要手动操作 DOM，从而提升了开发效率和用户体验。  </p><p>其中vue中双向绑定的实现</p><p>表单元素上的v-model</p><p>.sync修饰符  <a v-bind:title.sync="data"/></p><p>自定义组件上的v-model，v-bind:value  v-on:input</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码性能指标&quot;&gt;&lt;a href=&quot;#代码性能指标&quot; class=&quot;headerlink&quot; title=&quot;代码性能指标&quot;&gt;&lt;/a&gt;代码性能指标&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;健壮性&lt;/strong&gt;:出现预期之外的情况，是否可控&lt;br&gt;&lt;strong&gt;可复用性&lt;/s</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-23复盘</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d1.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d1.html</id>
    <published>2024-09-23T23:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-场景题"><a href="#1-场景题" class="headerlink" title="1.场景题"></a>1.场景题</h2><p>写一个 5 4 3 2 1 的倒计时效果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int count =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> countdown=<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span>(count===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(countdown)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>用setTimeout也行，别忘了clearInterval</p><p>然后用防抖函数来优化触发计时 当然也有其他很多方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func,time</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">//清除上一次的延时</span></span><br><span class="line">    timeout=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args) <span class="comment">// 在指定时间后执行函数</span></span><br><span class="line">    &#125;,time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖函数经常用于输入框搜索，防止用户每次按键都触发搜索请求</p><p>调用 需要的是返回的函数</p><p>const countdown = debounce(countdown, 500); // 500ms 防抖</p><p>然后后面直接调用countdown函数即可</p><p>一般防抖应用场景：</p><ul><li>搜索框输入时的搜索建议</li><li>窗口大小调整时的性能优化（resize 事件） </li><li>滚动事件中减少页面的滚动处理次数（scroll 事件）  </li></ul><h2 id="2-几道八股"><a href="#2-几道八股" class="headerlink" title="2.几道八股"></a>2.几道八股</h2><h3 id="1-em-rem"><a href="#1-em-rem" class="headerlink" title="1.em rem"></a>1.em rem</h3><p>常用于响应式设计，以便元素能够根据不同设备的屏幕尺寸动态调整大小  </p><p><code>em</code> 单位    相对父元素的字体大小    层级继承  </p><p><code>rem</code> 单位   <strong>相对于根元素的字体大小</strong>：<code>rem</code> 是相对<strong>根元素</strong>（即 <code>&lt;html&gt;</code> 元素）的字体大小，通常浏览器默认的根元素字体大小是 <code>16px</code>，除非手动修改。  </p><p><strong>不受父元素影响</strong>：与 <code>em</code> 不同，<code>rem</code> 不会随着父元素的字体大小变化，它只受根元素字体大小的影响，保持一致性。  </p><ul><li><code>em</code>：相对于<strong>父元素</strong>的字体大小，具有层级继承性，适用于需要随父元素动态变化的场景。</li><li><code>rem</code>：相对于<strong>根元素</strong>的字体大小，确保元素在页面上保持一致的相对尺寸，适用于需要全局一致性、响应式设计的场景。</li></ul><h3 id="2-npm-pnpm区别"><a href="#2-npm-pnpm区别" class="headerlink" title="2.npm ,pnpm区别"></a>2.npm ,pnpm区别</h3><p>JavaScript 包管理器   用于安装、管理、更新项目依赖库。它们的目标类似，但在实现和性能上有一些显著的区别。  </p><p><code>npm</code> 的特点：   深度嵌套的依赖   重复安装   缓存机制   锁定文件  </p><p><code>pnpm</code> 是一个更高效的包管理器，旨在解决 <code>npm</code> 中的一些性能问题，尤其是在磁盘空间和安装速度方面。  </p><p><code>pnpm</code> 的特点：   硬链接和符号链接   严格模式的依赖解析  </p><p><strong>性能优势</strong>：由于 <code>pnpm</code> 依赖缓存和符号链接，安装速度通常会比 <code>npm</code> 更快，尤其是在重复安装的场景下。  </p><h3 id="3-package-lock-json作用"><a href="#3-package-lock-json作用" class="headerlink" title="3.package.lock.json作用"></a>3.package.lock.json作用</h3><p><strong>锁定项目中安装的依赖包的具体版本</strong>，以确保在不同的环境或不同的开发者机器上，安装的依赖包版本完全一致，从而避免因依赖包版本不一致而引发的问题。  </p><p><strong>锁定依赖版本</strong>：</p><ul><li><code>package.json</code> 文件中通常会指定依赖包的版本范围（比如 <code>&quot;^1.0.0&quot;</code> 表示允许安装 1.x.x 的任何版本），但这意味着在不同时间或环境下，安装的依赖版本可能会有所不同。</li><li><code>package-lock.json</code> 文件记录了每个依赖的<strong>确切版本</strong>，包括所有直接和间接（transitive）依赖的版本。通过这个文件，<code>npm</code> 能确保每次安装时，依赖的版本都固定不变。</li></ul><p><strong>加快安装速度</strong>：  </p><p><code>package-lock.json</code> 文件中保存了所有依赖的源地址（registry URL），并记录了包的完整性校验（integrity hash）  </p><p> 可以确保所有人安装的依赖版本是一致的</p><h4 id="package-lock-json-与-package-json-的区别："><a href="#package-lock-json-与-package-json-的区别：" class="headerlink" title="package-lock.json 与 package.json 的区别："></a><code>package-lock.json</code> 与 <code>package.json</code> 的区别：</h4><ul><li>package.json：用于声明项目的直接依赖项及其版本范围，表示项目希望使用的依赖版本。开发者手动编辑和维护这个文件。</li><li>package-lock.json：自动生成，记录了依赖项及其子依赖项的确切版本，用于确保安装时依赖关系完全一致。这个文件不需要手动修改。</li></ul><h3 id="4-浏览器缓存有哪些"><a href="#4-浏览器缓存有哪些" class="headerlink" title="4.浏览器缓存有哪些"></a>4.浏览器缓存有哪些</h3><ol><li>HTTP 缓存  cache</li><li>浏览器存储   LocalStorage   SessionStorage   IndexedDB  </li></ol><p>cookie作用</p><p><strong>跨会话状态保持</strong>：Cookie 可以在多个会话间保存信息，使得用户在再次访问网站时可以恢复先前的状态或数据</p><p>Cookie 是一种在客户端存储小型数据的有效方式，用于会话管理和用户个性化设置，但在使用时需要注意安全性和隐私问题。随着 Web 存储技术的发展，开发者可以根据具体需求选择合适的存储方案。</p><h4 id="5-http-和-https"><a href="#5-http-和-https" class="headerlink" title="5.http 和 https"></a>5.http 和 https</h4><p>HTTPS（Hypertext Transfer Protocol Secure）是 HTTP 的安全版本，通过 SSL/TLS（安全套接层/传输层安全协议）来加密在客户端和服务器之间传输的数据。  </p><p>1.客户端请求：客户端（通常是浏览器）向服务器发送一个请求，发起一个安全连接的请求，使用https协议</p><p>2.服务器响应：服务器接受到请求后，返回其数字证书给客户端。数字证书中包含了服务器的公钥和由受信任的证书颁发机构（CA）签名的信息</p><p>3.证书验证：客户端收到数字证书后，会进行验证（验证证书是否有效，证书是否由受信任的CA签发，证书中的域名是否与访问的域名匹配）</p><p>4.生成会话秘钥：如果证书验证通过，客户端会生成一个随机的对称秘钥，用于加密接下来的通信。 客户端使用服务器的公钥对会话密钥进行加密，并将其发送给服务器 。</p><p>5.服务器解密会话秘钥：服务器使用其私钥解密客户端发送的会话秘钥，从而获得对称秘钥</p><p>6.建立安全连接：客户端和服务器端拥有了相同的会话秘钥，可以使用其进行后续的数据传输。所有通过https传输的数据都会使用该会话秘钥进行对称加密。</p><p>7.数据传输：在会话期间，客户端和服务器之间的所有通信都是加密的，保证了数据的机密性和完整性。</p><p>8.结束连接：当会话结束时，客户端和服务器可以选择关闭连接。也可以选择在未来的请求中重新使用相同的会话密钥或重新进行握手，生成新的会话密钥。 </p><h3 id="6-XSS-跨站脚本攻击"><a href="#6-XSS-跨站脚本攻击" class="headerlink" title="6.XSS(跨站脚本攻击)"></a>6.XSS(跨站脚本攻击)</h3><p>XSS 是指攻击者通过在网页中注入恶意脚本，来盗取用户的敏感信息或进行其他恶意操作。</p><p>白名单过滤 ：只允许特定格式的输入，拒绝不符合的输入。比如对于电子邮件、URL、数字等输入字段，使用正则表达式进行验证。   </p><p><strong>特殊字符转义</strong>：在输出到 HTML、JavaScript 或 CSS 中之前，对特殊字符进行转义，例如将 <code>&lt;</code> 转为 <code>&amp;lt;</code>，<code>&gt;</code> 转为 <code>&amp;gt;</code>，以防止注入。  </p><p><strong>文本内容插入</strong>：使用安全的 DOM 操作方法，如 <code>textContent</code> 或 <code>innerText</code>，而不是 <code>innerHTML</code>，避免直接插入 HTML 内容。  </p><p><strong>避免 eval()</strong>：避免使用 <code>eval()</code>、<code>setTimeout()</code> 和 <code>setInterval()</code> 等会执行字符串代码的函数。  </p><p><strong>设置 CSP 头部</strong>：通过设置 HTTP 头部 <code>Content-Security-Policy</code>，限制网页上允许加载的资源，例如只允许加载特定源的脚本。这可以有效防止外部脚本的执行。  </p><h3 id="7-vue组件的通信方式"><a href="#7-vue组件的通信方式" class="headerlink" title="7.vue组件的通信方式"></a>7.vue组件的通信方式</h3><ol><li><p>父子组件通信</p><p>父组件通过 props 将数据传递给子组件。  </p><p>子组件通过 <code>$emit</code> 触发事件，父组件可以监听这些事件。  </p></li><li><p>兄弟组件通信</p><p>通过父组件  作为桥梁 来让两个子组件进行通信</p><p>Event Bus    使用一个中央事件总线（Event Bus）来进行通信。</p></li><li><p>全局状态管理    </p><p>Vuex   用 Vuex 进行全局状态管理，适合大型应用。  </p><p>Provide/Inject   在祖先组件中提供数据，后代组件可以注入这些数据</p></li></ol><h3 id="8-灰度测试"><a href="#8-灰度测试" class="headerlink" title="8.灰度测试"></a>8.灰度测试</h3><p><strong>灰度测试（Gray Release）是一种逐步发布新功能或版本的方法，通过将新功能仅向部分用户开放，从而监控其在真实环境中的表现和用户反馈。这种方式可以有效降低新版本发布的风险，确保新功能的稳定性和可靠性。</strong>  </p><p><strong>灰度测试的特点</strong> </p><p><strong>1.逐步发布</strong>  ：将新功能或版本逐步推向用户，而不是一次性向所有用户发布。</p><p><strong>2.用户分组</strong>  ：可以根据用户的地域、用户行为、使用频率等，将用户分为不同的组，向特定组推出新功能。</p><p><strong>3.监控与反馈</strong>  ：实时监控新版本的性能、用户行为和反馈，及时发现问题并进行调整。</p><p><strong>灰度测试的流程  ：</strong></p><ul><li><strong>选择目标用户</strong>：确定哪些用户将参与灰度测试。这可以基于用户的地理位置、使用习惯或其他特征。</li><li><strong>发布新版本</strong>：向选定的用户群体发布新功能或版本。</li><li><strong>监控与收集数据</strong></li></ul><ul><li><ul><li><strong>监控应用的性能指标（如响应时间、错误率等）。</strong></li><li><strong>收集用户反馈和行为数据。</strong></li></ul></li></ul><ul><li><strong>评估结果</strong>  ：分析收集到的数据，判断新功能是否成功，是否需要进一步改进。</li><li><strong>全量发布</strong>  ：如果新功能表现良好，可以逐步向所有用户发布；如果存在问题，可以对其进行修复后再发布。</li></ul><h3 id="灰度测试的优势"><a href="#灰度测试的优势" class="headerlink" title="灰度测试的优势"></a><strong>灰度测试的优势</strong></h3><ul><li><strong>风险控制</strong>：通过逐步推出新功能，可以及时发现问题并减少对所有用户的影响。</li><li><strong>用户反馈</strong>：可以更快地收集用户对新功能的反馈，便于进行改进和调整。</li><li><strong>资源节约</strong>：可以更有效地利用资源，集中在新功能的优化上，降低后期维护成本。</li></ul><h3 id="灰度测试的应用场景"><a href="#灰度测试的应用场景" class="headerlink" title="灰度测试的应用场景"></a><strong>灰度测试的应用场景</strong></h3><ul><li><strong>新功能发布</strong>：在新功能上线之前，进行灰度测试以验证其可用性和稳定性。</li><li><strong>版本更新</strong>：在产品进行重大版本更新时，可以先进行灰度发布，降低风险。</li><li><strong>市场推广</strong>：在推广新产品或服务时，可以选择特定用户进行测试，以评估市场反应。</li></ul><p>灰度测试是一种有效的产品发布策略，可以帮助开发团队在控制风险的同时，优化用户体验。通过合理设计和实施灰度测试，可以在保证软件质量的同时，提升用户满意度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-场景题&quot;&gt;&lt;a href=&quot;#1-场景题&quot; class=&quot;headerlink&quot; title=&quot;1.场景题&quot;&gt;&lt;/a&gt;1.场景题&lt;/h2&gt;&lt;p&gt;写一个 5 4 3 2 1 的倒计时效果 &lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2024-9-20复盘</title>
    <link href="https://daixueshengt.github.io/posts/100fa4d0.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4d0.html</id>
    <published>2024-09-23T21:54:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-浏览器输入URL会发生什么"><a href="#1-浏览器输入URL会发生什么" class="headerlink" title="1.浏览器输入URL会发生什么"></a>1.浏览器输入URL会发生什么</h2><p><strong>1.URL 解析</strong></p><p> <strong>用户输入的 URL 会被解析为不同的部分</strong>  </p><ul><li><strong>协议（Scheme）</strong>：如 <code>http:// 或 https://</code></li><li><strong>域名（Host）</strong>：如 <code>www.example.com</code></li><li><strong>路径（Path）：指向特定资源，如</strong> <code>/page</code></li><li><strong>查询参数（Query String）</strong>：如  <code>?id=123&amp;sort=asc</code></li><li><strong>端口号（Port）（可选）</strong>：如 :80  或  :443（默认为 80 或 443）</li></ul><p><strong>2.DNS 解析</strong></p><p> <strong>浏览器会通过 DNS（域名系统）将输入的域名解析为服务器的 IP 地址。</strong></p><ol><li><strong>浏览器首先查询本地缓存（DNS 缓存、操作系统缓存）是否有这个域名的 IP。</strong></li><li><strong>如果没有命中缓存，浏览器会向 DNS 服务器发出请求，递归查询获取目标 IP 地址。</strong></li><li><strong>得到 IP 地址后，浏览器才能继续与目标服务器通信。</strong></li></ol><p><strong>3. 建立 TCP 连接</strong>  </p><ul><li><strong>通过 IP 地址，浏览器与目标服务器之间建立 TCP 连接，默认使用 HTTP 的 80 端口或 HTTPS 的 443 端口。</strong></li><li><strong>浏览器和服务器会进行 三次握手 过程，确保双方可以进行可靠的数据传输</strong></li><li><strong>客户端发送 SYN 请求。</strong></li><li><strong>服务器响应 SYN-ACK。</strong></li><li><strong>客户端发送 ACK，连接建立。</strong></li></ul><p><strong>4. TLS/SSL 握手（如果是 HTTPS）</strong>  </p><ul><li><strong>如果使用 HTTPS 协议，TCP 连接建立后，客户端和服务器之间还要进行</strong> TLS/SSL 握手。</li><li><strong>该过程用于加密通信，确保数据传输的安全性：</strong></li></ul><ol><li><strong>浏览器请求服务器的证书。</strong></li><li><strong>服务器返回证书（包括公钥）。</strong></li><li><strong>浏览器验证证书是否合法，并生成会话密钥。</strong></li><li><strong>双方使用对称加密的方式进行加密数据交换。</strong></li></ol><p><strong>5. 发送 HTTP 请求</strong>  </p><p> <strong>连接建立后，浏览器会发送一个 HTTP 请求 给服务器，请求的内容包括：</strong>  </p><ul><li><strong>请求方法</strong>（如 GET、POST)</li><li><strong>请求的 URL 路径</strong></li><li><strong>请求头信息（如浏览器的 User-Agent、Cookie、缓存等信息）</strong></li><li><strong>如果是 POST 请求，还会包括请求体（如表单数据）</strong></li></ul><p><strong>6. 服务器处理请求</strong>  </p><ul><li><strong>根据 URL 路径查找对应的资源（如 HTML 文件、API 数据）。</strong></li><li><strong>如果需要，则查询数据库、执行业务逻辑等。</strong></li><li><strong>服务器根据处理结果生成 HTTP 响应，通常包括状态码、响应头和响应体。</strong></li></ul><p><strong>7. 返回 HTTP 响应</strong>  </p><p> <strong>服务器返回的 HTTP 响应 包含  :</strong></p><ul><li><strong>状态码</strong>：表示请求的结果（如 200 表示成功，404 表示未找到资源，500 表示服务器错误等）。</li><li><strong>响应头</strong>：包括内容类型（如 Content-Type: text/html）、缓存控制、Cookie 等信息。</li><li><strong>响应体</strong>：即请求的实际内容（如 HTML 页面、JSON 数据、图片等）。</li></ul><p><strong>8. 浏览器渲染页面</strong>  </p><p> <strong>浏览器接收到 HTTP 响应后，开始渲染页面，主要流程如下  :</strong></p><ol><li><strong>解析 HTML：将 HTML 文档解析为 DOM（文档对象模型）树。</strong>  </li><li><strong>解析 CSS：下载并解析样式表，生成 CSSOM（CSS 对象模型）树。</strong>  </li><li><strong>构建渲染树：将 DOM 树与 CSSOM 树结合，生成渲染树，决定每个元素的样式与位置。</strong>  </li><li><strong>布局与绘制：计算每个元素的位置和大小，并将其绘制到屏幕上。</strong>  </li><li><strong>执行 JavaScript：浏览器解析并执行 HTML 中的</strong> <script> <strong>标签，可能会改变 DOM 树的结构并触发重新渲染。</strong>  </li><li><strong>处理资源请求：如果页面中有外部资源（如图片、视频、CSS、JS 文件），浏览器会发起新的 HTTP 请求来下载这些资源。</strong> </li></ol><p><strong>9. 后续请求与优化</strong>  </p><ul><li><strong>浏览器会根据 HTML 中的</strong> <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code><strong>,</strong> <code>&lt;link&gt;</code> 等标签继续发起新的 HTTP 请求。</li><li><strong>浏览器还会利用缓存机制、预加载（preload）、懒加载等技术优化页面加载速度和用户体验。</strong></li></ul><h2 id="2-第一次渲染和第二次渲染怎么做优化？"><a href="#2-第一次渲染和第二次渲染怎么做优化？" class="headerlink" title="2.第一次渲染和第二次渲染怎么做优化？"></a>2.第一次渲染和第二次渲染怎么做优化？</h2><p> 第一次渲染优化（首次加载优化）   </p><p>第一次渲染指的是用户第一次访问页面时，从输入 URL 到页面完全加载和呈现的过程。这个过程通常包括网络请求、资源下载和页面渲染等步骤。  </p><ol><li>减少关键资源的大小和数量</li></ol><ul><li>压缩资源：通过 gzip、Brotli 压缩 HTML、CSS、JavaScript 等文件，减少文件体积。</li><li>代码拆分（Code Splitting）：将 JavaScript 拆分成多个小文件，按需加载（如 Webpack 的 <code>splitChunks</code>）。</li><li>减少 CSS 阻塞：使用关键 CSS（Critical CSS），只加载页面首屏显示所需的样式，推迟加载非关键 CSS。</li></ul><ol><li>减少 HTTP 请求  </li></ol><ul><li>合并 CSS 和 JavaScript 文件：减少 HTTP 请求数量。</li><li>使用 HTTP/2 或 HTTP/3：通过并行加载多个资源，减少排队等待时间。</li><li>减少图像数量：合并小图标为雪碧图（sprite），或使用 CSS 生成图形。</li></ul><ol><li>使用内容分发网络（CDN）  </li></ol><p>将静态资源（CSS、JavaScript、图片等）托管在 CDN 上，减少资源的加载时间，特别是对于全球用户，提高资源的访问速度。  </p><ol><li>优化图像加载  </li></ol><ul><li>延迟加载（Lazy Load）：只在用户滚动到视图范围内时加载图像或其他媒体资源，减少首次渲染时加载的资源量。</li><li>图像优化：使用合适的图片格式（如 WebP），并根据不同设备提供不同分辨率的图片。</li></ul><ol><li>减少 JavaScript 负担  </li></ol><ul><li>异步加载 JavaScript：使用 <code>async</code> 或 <code>defer</code> 属性，避免阻塞页面渲染。  </li><li>树摇（Tree Shaking）：通过工具（如 Webpack）去除未使用的代码，减少打包后的文件大小。  </li><li>预加载关键资源：使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 提前加载关键资源，如字体、重要的 JavaScript 和 CSS 文件。  </li></ul><ol><li>预渲染和服务器端渲染（SSR）</li></ol><ul><li>SSR：将页面预先在服务器端渲染成 HTML，用户访问时不需要等待浏览器解析和执行 JavaScript，可以立即看到页面内容。</li><li>静态生成（Static Generation）：对于不频繁变化的页面，生成静态 HTML，减少服务器处理时间。</li><li>预渲染（Prerendering）：对于常访问的页面，可以在用户请求之前在服务器预渲染，并缓存渲染结果。</li></ul><ol><li>减少渲染阻塞资源  </li></ol><ul><li>CSS 优化：将关键 CSS 内联到 HTML 文件中，减少额外请求；推迟加载不重要的 CSS 文件。</li><li><p>移除阻塞 JavaScript：将不需要立即执行的脚本放置到页面底部，或使用 <code>defer</code>、<code>async</code> 来延迟加载。</p><p>第二次渲染优化（重复访问时的渲染优化）  </p><p>第二次渲染指的是用户再次访问同一个页面或应用时的加载过程。重点在于利用缓存、减少不必要的重复请求和渲染，提升加载速度。  </p></li></ul><ol><li>使用浏览器缓存</li></ol><ol><li>启用浏览器存储机制</li></ol><ol><li>Lazy Load 继续发挥作用</li></ol><ol><li>预缓存和预加载</li></ol><ol><li>减少重新计算与重绘</li></ol><ol><li>使用 HTTP/2 和 HTTP/3  </li></ol><h2 id="3-场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能"><a href="#3-场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能" class="headerlink" title="3.场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能"></a>3.场景：点赞功能，用户在短时间内多次点击怎么做，可能有偶数次或者奇数次（奇数点赞，偶数取消）的情况怎么保证页面性能</h2><ol><li>防抖（Debounce）或者节流（Throttle）机制  </li></ol><p>为了避免用户短时间内频繁触发点赞请求，可以采用<strong>防抖</strong>或<strong>节流</strong>来控制操作的频率：</p><ul><li><strong>防抖（Debounce）</strong>：用户每次点击都会触发点赞操作，但在设定时间内，如果用户再次点击，则重置计时，只有在设定时间内不再点击时才会真正触发点赞请求。这种方法适合处理短时间内的多次点击，最终只会执行一次操作。</li><li><strong>节流（Throttle）</strong>：限制用户每隔一定时间才能触发点赞操作，比如设置 500 毫秒的时间间隔，避免用户在短时间内频繁操作，从而减少请求频率。这对于频繁操作较多的情况下非常有用。</li></ul><p>2.乐观更新</p><p> 为了提升用户体验，页面可以<strong>在用户点击时立即更新状态</strong>，而无需等待服务器返回结果。这样即使用户连续点击，页面的响应依然很快，然后后台异步处理请求。乐观更新可以结合防抖或者节流机制一起使用。</p><p>具体实现如下：</p><ol><li><strong>立即更新界面</strong>：当用户点击点赞按钮时，页面立即更新状态（例如切换点赞图标）。</li><li><strong>异步发送请求</strong>：在后台异步发送点赞/取消点赞请求，更新服务器的点赞状态。</li><li><strong>错误处理</strong>：如果请求失败，回滚本地状态，恢复为原始状态。</li></ol><ol><li>合并请求  </li></ol><p>如果用户在短时间内多次点击，可以考虑将多个操作合并为一个请求，从而减少向服务器发送的请求次数，降低服务器压力。</p><p>具体做法是，<strong>在短时间内批量处理点击事件</strong>，将多次点击操作合并成一次请求，最后的状态取决于用户的最终操作结果。</p><ul><li>例如：用户短时间内点击了 5 次，实际上只会发出一次请求，且最终根据点击次数的奇偶性来决定是点赞还是取消点赞。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖函数（Debounce）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流函数（Throttle）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - lastCall &gt;= interval) &#123;</span><br><span class="line">      lastCall = now;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设点赞操作是 likePost</span></span><br><span class="line"><span class="keyword">const</span> handleLike = <span class="title function_">debounce</span>(likePost, <span class="number">300</span>); <span class="comment">// 或者使用 throttle</span></span><br></pre></td></tr></table></figure><h2 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常见的传输层协议，它们的主要区别在于连接模式、可靠性、数据传输方式等。下面列出了它们在多个方面的区别：  </p><ol><li>连接与无连接  </li><li>可靠性  </li></ol><ol><li>有序性</li></ol><ul><li><strong>TCP</strong>：保证数据包按顺序到达接收端。即使数据包以不同顺序到达，TCP 也会对它们进行重新排序，确保数据的顺序性。</li><li><strong>UDP</strong>：不保证数据的顺序性。UDP 数据报可能会乱序到达接收端，接收端需要自行处理数据顺序问题。</li></ul><ol><li><p>数据传输方式  </p><p><strong>TCP</strong>：基于<strong>字节流    UDP：基于报文</strong></p></li><li><p>速度与效率</p></li></ol><ul><li>TCP：由于其需要建立连接、确认和重传机制，TCP 的可靠性较高，但这些特性会带来一定的开销，因此速度较慢，效率较低。</li><li>UDP：因为没有连接建立、确认和重传机制，UDP 协议非常轻量且传输速度快，非常适合要求低延迟或高实时性的数据传输。</li></ul><h2 id="5-说一说promise"><a href="#5-说一说promise" class="headerlink" title="5.说一说promise"></a>5.说一说promise</h2><p><code>Promise</code> 是 JavaScript 中的一种异步编程解决方案，用于处理异步操作并避免回调地狱。<code>Promise</code> 代表一个未来可能完成或失败的操作，以及它完成后的返回值或失败原因。  </p><p>一个 <code>Promise</code> 对象有三种状态：</p><ol><li><strong>Pending</strong>（进行中）：初始状态，操作尚未完成。</li><li><strong>Fulfilled</strong>（已成功）：操作成功完成，并返回了一个值。</li><li><p><strong>Rejected</strong>（已失败）：操作失败，并返回了一个原因</p><p>一旦 <code>Promise</code> 状态变为 <code>Fulfilled</code> 或 <code>Rejected</code>，就不会再改变（不可逆）  </p><p>Promise 的用法  </p></li><li><p>创建 Promise  </p></li></ol><p>可以通过 <code>new Promise</code> 构造函数创建一个 <code>Promise</code> 对象，传入一个执行器（executor）函数，该函数有两个参数：</p><ul><li><code>resolve</code>: 当操作成功时调用，并传递结果。</li><li><code>reject</code>: 当操作失败时调用，并传递错误原因。</li></ul><ol><li>使用 <code>.then()</code> 和 <code>.catch()</code></li></ol><p><code>Promise</code> 的结果通过 <code>.then()</code> 方法处理。当 <code>Promise</code> 成功（fulfilled）时，会执行 <code>.then()</code> 中的回调函数；当 <code>Promise</code> 失败（rejected）时，会执行 <code>.catch()</code> 中的回调函数。  </p><ol><li>finally()</li></ol><p><code>.finally()</code> 方法用于在 <code>Promise</code> 结束后（无论是成功还是失败）执行某个回调函数，常用于清理资源等操作。</p><h3 id="Promise-链式调用"><a href="#Promise-链式调用" class="headerlink" title="Promise 链式调用"></a><strong>Promise 链式调用</strong></h3><p><code>Promise</code> 支持链式调用，即可以在一个 <code>.then()</code> 之后继续调用另一个 <code>.then()</code>，这样多个异步操作可以按顺序执行。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h3><p><code>Promise.all()</code> 方法用于并行处理多个 <code>Promise</code>，它接受一个包含多个 <code>Promise</code> 的可迭代对象（如数组）。当所有 <code>Promise</code> 都成功时，<code>Promise.all()</code> 返回一个包含每个 <code>Promise</code> 成功结果的数组；如果有任何一个 <code>Promise</code> 失败，则返回该失败原因。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h3><p><code>Promise.race()</code> 方法接受多个 <code>Promise</code>，并返回最先完成的那个 <code>Promise</code>，无论是成功还是失败。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h3><p><code>Promise.any()</code> 方法接受多个 <code>Promise</code>，只要其中有一个 <code>Promise</code> 成功，返回该 <code>Promise</code> 的结果。如果所有的 <code>Promise</code> 都失败，它会返回一个包含所有错误的聚合错误。</p><p><code>async/await</code> 是 <code>Promise</code> 的语法糖    让异步操作看起来像同步代码。  </p><ol><li>Promise 是基础：</li></ol><ul><li><code>Promise</code> 是一种对象，代表异步操作的最终完成（或失败）及其结果。</li><li><code>async/await</code> 的本质依赖于 <code>Promise</code>，每个 <code>async</code> 函数实际上都返回一个 <code>Promise</code>，即使你没有显式地返回 <code>Promise</code> 对象。</li></ul><ol><li>async/await 是 Promise 的语法糖：</li></ol><ul><li>使用 <code>async/await</code> 可以让异步代码看起来像同步代码，更加直观易读。</li><li><code>await</code> 后面的表达式需要是一个返回 <code>Promise</code> 的函数，<code>await</code> 会暂停该 <code>async</code> 函数的执行，直到 <code>Promise</code> 解决（resolve）或拒绝（reject），然后继续执行。</li></ul><h2 id="6-函数柯里化"><a href="#6-函数柯里化" class="headerlink" title="6.函数柯里化"></a>6.函数柯里化</h2><p>柯里化（Currying）是一种将接受多个参数的函数转换为一系列接受单一参数的函数的技术。它使函数可以部分应用其参数，即每次调用函数时传入一个参数，返回一个新函数，该新函数等待下一个参数，直到所有参数都传入后，函数执行并返回结果。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arity = fn.<span class="property">length</span>; <span class="comment">// 获取函数的参数个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的参数数量小于函数的参数数量，返回一个新的函数，继续接受参数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args); <span class="comment">// 如果参数足够，调用原始函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...nextArgs</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curried</span>(...args, ...nextArgs); <span class="comment">// 合并参数并继续调用</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们可以通过一个例子来测试这个柯里化函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-浏览器输入URL会发生什么&quot;&gt;&lt;a href=&quot;#1-浏览器输入URL会发生什么&quot; class=&quot;headerlink&quot; title=&quot;1.浏览器输入URL会发生什么&quot;&gt;&lt;/a&gt;1.浏览器输入URL会发生什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.URL 解析&lt;/</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>7-25</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d5.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d5.html</id>
    <published>2024-07-25T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p><p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p><p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为：”the sky is blue “</p><ul><li>移除多余空格 : “the sky is blue”</li><li>字符串反转：”eulb si yks eht”</li><li>单词反转：”blue is sky the”</li></ul><p>这样我们就完成了翻转字符串里的单词。</p><p>注意：开头 中间 结尾 都会有多余的空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;151-翻转字符串里的单词&quot;&gt;&lt;a href=&quot;#151-翻转字符串里的单词&quot; class=&quot;headerlink&quot; title=&quot;151.翻转字符串里的单词&quot;&gt;&lt;/a&gt;151.翻转字符串里的单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-24</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d4.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d4.html</id>
    <published>2024-07-24T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = -<span class="number">1</span>, r = s.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">while</span>(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;  <span class="comment">// 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span>(++l &lt; --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p><p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p><p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p><p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p><p>样例输入：a1b2c3</p><p>样例输出：anumberbnumbercnumber</p><p>数据范围：1 &lt;= s.length &lt; 10000。</p><p>思路：<strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="type">int</span> sOldIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> sNewIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从后往前将数字替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (sOldIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[sOldIndex] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[sNewIndex--] = s[sOldIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            sOldIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344.反转字符串&quot;&gt;&lt;/a&gt;344.反转字符串&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-23</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d3.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d3.html</id>
    <published>2024-07-23T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><p>给定四个包含整数的队列列表 A , B , C , D ，计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D [l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>原因:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个单元如下:</p><ol><li>（0，0，0，1）-&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>（1，1，0，0）-&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p>本题解答步骤：</p><ol><li>首先定义一个unordered_map，key放a和b两数之和，value放a和b两数之和出现的次数。</li><li>遍历大A和大B的集群，统计两个集群元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用于统计a+b+c+d = 0出现的次数。</li><li>再遍历大C和大D内存，找到如果0-(c+d)在map中出现过的话，就用count把map中key对应的值来统计出现次数。</li><li>最后返回统计值count就可以了</li></ol><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap; <span class="comment">//key:a+b的数值，value:a+b数值出现的次数</span></span><br><span class="line">        <span class="comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : B) &#123;</span><br><span class="line">                umap[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计a+b+c+d = 0 出现的次数</span></span><br><span class="line">        <span class="comment">// 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span> - (c + d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间度：O(n^2)，最坏情况下A和B的值复杂度各不相同，相加产生的数字个数为n^2</li></ul><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> twoSumMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计nums1和nums2数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n1 <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> n2 <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = n1 + n2;</span><br><span class="line">            twoSumMap.<span class="title function_">set</span>(sum, (twoSumMap.<span class="title function_">get</span>(sum) || <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n3 <span class="keyword">of</span> nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> n4 <span class="keyword">of</span> nums4) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = n3 + n4;</span><br><span class="line">            count += (twoSumMap.<span class="title function_">get</span>(<span class="number">0</span> - sum) || <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为题目说只有小写字母，那可以采用空间换取时间的存储策略，用一个长度为26的磁盘记录来杂志里字母出现的次数。</p><p>然后再用 ransomNote 去验证该阵列是否包含 ransomNote 所需要的所有字母。</p><p>依然是存储在缓存法中的应用。</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            cnt[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">             <span class="keyword">if</span> (cnt[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (cnt[i] &lt; 0)</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JS代码-1"><a href="#JS代码-1" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">ransomNote</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">magazine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>), </span><br><span class="line">        base = <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> magazine) &#123;  <span class="comment">// 记录 magazine里各个字符出现次数</span></span><br><span class="line">        strArr[s.<span class="title function_">charCodeAt</span>() - base]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> ransomNote) &#123; <span class="comment">// 对应的字符个数做--操作</span></span><br><span class="line">        <span class="keyword">const</span> index = s.<span class="title function_">charCodeAt</span>() - base;</span><br><span class="line">        <span class="keyword">if</span>(!strArr[index]) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果没记录过直接返回false</span></span><br><span class="line">        strArr[index]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p>思路：</p><p><strong>其实这个问题使用哈希法的</strong>操作并不十分合适，因为在去重的时候有很多需要注意的细节，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法在使用两层进行循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也可以在leetcode上通过，但是程序的执行时间依然比较长。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针高效法无法哈希法一些</strong>，那么来讲解一下具体实现的思路。</p><p>拿这个nums队列来举例，首先将队列排序，然后有一层进行循环，i从下标0的位置开始，同时在i+1的位置上定义一个下标left，在队列末尾定义下标right位置上。</p><p>仍然还是在吞吐量中找到 abc 使得 a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left和right呢，如果nums[i] + nums[left] + nums[right] &gt; 0就说明此时三数之和大了，因为CPU是排序后了，所以right下标就应该应该向左移动，这样才能得到三数之和一小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明此时三数之和小了，左就向右移动，才能让三数之和大一些，直到左与右相满足。</p><p>时间复杂度：O(n^2)。</p><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度： O(1)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 将数组排序</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i + <span class="number">1</span>, r = len - <span class="number">1</span>, iNum = nums[i]</span><br><span class="line">        <span class="comment">// 数组排过序，如果第一个数大于0直接返回res</span></span><br><span class="line">        <span class="keyword">if</span> (iNum &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (iNum == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">let</span> lNum = nums[l], rNum = nums[r], threeSum = iNum + lNum + rNum</span><br><span class="line">            <span class="comment">// 三数之和小于0，则左指针向右移动</span></span><br><span class="line">            <span class="keyword">if</span> (threeSum &lt; <span class="number">0</span>) l++ </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (threeSum &gt; <span class="number">0</span>) r--</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([iNum, lNum, rNum])</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>])&#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">                l++</span><br><span class="line">                r--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>一般来说哈希表都是用来快速判断一个元素是否出现集合里</strong>。</p><p>对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用。</p><p>哈希函数是把传入的key映射到符号表的索引上。</p><p>哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组（大小是受限的）</li><li>set（集合）</li><li>map（映射）</li></ul><p>在C++语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同</p><p>例如什么时候用std::set，什么时候用std::multiset，什么时候用std::unordered_set，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>没有限制数值的大小，就无法使用数组来做哈希表了</p><p><strong>主要因为如下两点：</strong></p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ul><p>所以此时一样的做映射的话，就可以使用set了。</p><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 使用unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>在两数之和中，map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>map是一种<code>&lt;key, value&gt;</code>的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p><p>C++提供如下三种map：</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p>std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）</p><p>1.两数之和中并不需要key有序，选择std::unordered_map 效率更高！</p><p>在454.四数相加中我们提到了其实需要哈希的地方都能找到map的身影。</p><p>关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而18. 四数之和，15.三数之和是一个数组（集合）里找到和为0的组合，可就难很多了！</p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><p>所以18. 四数之和，15.三数之和都推荐使用双指针法！</p><p><strong>强调：虽然map是万能的，以上详细介绍了什么时候用数组，什么时候用set</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;454-四数相加II&quot;&gt;&lt;a href=&quot;#454-四数相加II&quot; class=&quot;headerlink&quot; title=&quot;454.四数相加II&quot;&gt;&lt;/a&gt;454.四数相加II&lt;/h2&gt;&lt;p&gt;给定四个包含整数的队列列表 A , B , C , D ，计算有多少个元组 </summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-22</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d2.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d2.html</id>
    <published>2024-07-22T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>首先什么是哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实直白来讲其实数组就是一张哈希表。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先看暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。</p><p>暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。</p><p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><p>需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</p><p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串s中字符出现的次数，统计出来了。</p><p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。</p><p>那么最后检查一下，<strong>record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。</strong></p><p>最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。</p><p>时间复杂度为O(n)，空间上因为定义的是一个常量大小的辅助数组，所以空间复杂度为O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> !== t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> base = <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">        resSet[i.<span class="title function_">charCodeAt</span>() - base]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!resSet[i.<span class="title function_">charCodeAt</span>() - base]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        resSet[i.<span class="title function_">charCodeAt</span>() - base]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择</p><p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n + m) m 是最后要把 set转成vector</li><li>空间复杂度: O(n)</li></ul><p>本题后面 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：</p><ul><li>1 &lt;= nums1.length, nums2.length &lt;= 1000</li><li>0 &lt;= nums1[i], nums2[i] &lt;= 1000</li></ul><p>所以就可以 使用数组来做哈希表了， 因为数组都是 1000以内的。</p><p>对应C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 默认数值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123; <span class="comment">// nums1中出现的字母在hash数组中做记录</span></span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123; <span class="comment">// nums2中出现话，result记录</span></span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(m + n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据数组大小交换操作的数组</span></span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span> &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _ = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nums1Set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums1);</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="comment">// for(const n of nums2) &#123;</span></span><br><span class="line">    <span class="comment">//     nums1Set.has(n) &amp;&amp; resSet.add(n);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 循环 比 迭代器快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums2.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nums1Set.<span class="title function_">has</span>(nums2[i]) &amp;&amp; resSet.<span class="title function_">add</span>(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(resSet);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul><p>由于 <code>set.end()</code> 是一个表示集合末尾的迭代器（实际上是指向最后一个元素之后的位置），因此如果 <code>set.find(sum)</code> 返回的不是 <code>set.end()</code>，那么意味着 <code>sum</code> 的值在 <code>set</code> 中已经被找到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">            n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// n出现过，证明已陷入无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (m.<span class="title function_">has</span>(n)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        m.<span class="title function_">set</span>(n, <span class="number">1</span>)</span><br><span class="line">        n = <span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Set()更简洁</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        sum += (n % <span class="number">10</span>) ** <span class="number">2</span>;</span><br><span class="line">        n =  <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();   <span class="comment">// Set() 里的数是惟一的</span></span><br><span class="line">    <span class="comment">// 如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数</span></span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">1</span> &amp;&amp; !set.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">        set.<span class="title function_">add</span>(n);</span><br><span class="line">        n = <span class="title function_">getSum</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n === <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)</p><p>首先我再强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。应该想到使用哈希法了</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]); </span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">            <span class="comment">// map.insert(pair&lt;int, int&gt;(nums[i], i)); </span></span><br><span class="line">            map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;  <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">    <span class="keyword">if</span> (hash[target - nums[i]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, hash[target - nums[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    hash[nums[i]] = i;   <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表理论基础&quot;&gt;&lt;a href=&quot;#哈希表理论基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表理论基础&quot;&gt;&lt;/a&gt;哈希表理论基础&lt;/h2&gt;&lt;h3 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-21</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d1.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d1.html</id>
    <published>2024-07-21T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p><p>初始时，cur指向虚拟头结点，然后进行修改指针的三步操作</p><p>对应的C++代码实现如下： </p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* result = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head), temp = ret;</span><br><span class="line">  <span class="keyword">while</span> (temp.<span class="property">next</span> &amp;&amp; temp.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = temp.<span class="property">next</span>.<span class="property">next</span>, pre = temp.<span class="property">next</span>;</span><br><span class="line">    pre.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span> = pre;</span><br><span class="line">    temp.<span class="property">next</span> = cur;</span><br><span class="line">    temp = pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span> || head.<span class="property">next</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> after = head.<span class="property">next</span>;</span><br><span class="line">  head.<span class="property">next</span> = <span class="title function_">swapPairs</span>(after.<span class="property">next</span>);</span><br><span class="line">  after.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> after;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：</p><p>输入：head = [1,2], n = 1 输出：[1]</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><p>思路是这样的，但要注意一些细节。</p><p>定义fast指针和slow指针，初始值为虚拟头结点</p><p><strong>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）</strong></p><p>fast和slow同时移动，直到fast指向末尾</p><p>删除slow指向的下一个节点</p><p>此时不难写出如下:</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class="line">        <span class="comment">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class="line">        <span class="comment">// delete tmp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="JS代码-1"><a href="#JS代码-1" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建哨兵节点，简化解题逻辑</span></span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">  <span class="keyword">let</span> fast = dummyHead;</span><br><span class="line">  <span class="keyword">let</span> slow = dummyHead;</span><br><span class="line">  <span class="keyword">while</span> (n--) fast = fast.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">while</span> (fast.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    slow = slow.<span class="property">next</span>;</span><br><span class="line">    fast = fast.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>。 这里同学们要注意，交点不是数值相等，而是指针相等。</p><p>我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置。</p><p>此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。</p><p>否则循环退出返回空指针。</p><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n + m)</li><li>空间复杂度：O(1)</li></ul><h3 id="JS代码-2"><a href="#JS代码-2" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getListLen = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">       len++;</span><br><span class="line">       cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curA = headA,curB = headB,</span><br><span class="line">        lenA = <span class="title function_">getListLen</span>(headA),   <span class="comment">// 求链表A的长度</span></span><br><span class="line">        lenB = <span class="title function_">getListLen</span>(headB);  </span><br><span class="line">    <span class="keyword">if</span>(lenA &lt; lenB) &#123;       <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 交换变量注意加 “分号” ，两个数组交换变 量在同一个作用域下时</span></span><br><span class="line">        <span class="comment">// 如果不加分号，下面两条代码等同于一条代码: [curA, curB] = [lenB, lenA]</span></span><br><span class="line">        </span><br><span class="line">        [curA, curB] = [curB, curA];</span><br><span class="line">        [lenA, lenB] = [lenB, lenA];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = lenA - lenB;   <span class="comment">// 求长度差</span></span><br><span class="line">    <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>) &#123;       <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        curA = curA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(curA &amp;&amp; curA !== curB) &#123;  <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        curA = curA.<span class="property">next</span>;</span><br><span class="line">        curB = curB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p><p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p><p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p><p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p><h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p><p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><h3 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JS代码-3"><a href="#JS代码-3" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种循环实现方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先判断是否是环形链表</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow =head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span> &amp;&amp; fast!== slow) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast.<span class="property">next</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast !== slow) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow =head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast !== slow) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;24. 两两交换链表中的节点&lt;/h2&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-20</title>
    <link href="https://daixueshengt.github.io/posts/110fa4d0.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4d0.html</id>
    <published>2024-07-20T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p><p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：<code>ListNode* head = new ListNode(5);</code></p><p>使用默认构造函数初始化节点：<code>ListNode* head = new ListNode();head-&gt;val = 5;</code></p><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值</p><p>JS定义链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  val;</span><br><span class="line">  next = <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存</p><p><strong>当然如果使用java ，python的话就不用手动管理内存了。</strong></p><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>为了统一操作 <strong>设置一个虚拟头结点在进行删除操作。</strong></p><p>最后在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span> (<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (cur.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">next</span>.<span class="property">val</span> === val) &#123;</span><br><span class="line">            cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的设置一个虚拟头结点</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123; <span class="comment">// 如果--index 就会陷入死循环</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果index小于0，则在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>) index = <span class="number">0</span>;        </span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="comment">//delete命令指示释放了tmp指针原本所指的那部分内存，</span></span><br><span class="line">        <span class="comment">//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span></span><br><span class="line">        <span class="comment">//如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span></span><br><span class="line">        <span class="comment">//如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span></span><br><span class="line">        tmp=<span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: 涉及 <code>index</code> 的相关操作为 O(index), 其余为 O(1)</li><li>空间复杂度: O(n)</li></ul><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p><p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表</p><p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。</p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">            <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p><strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n), 要递归处理链表的每个节点</li><li>空间复杂度: O(n), 递归调用了 n 层栈空间</li></ul><h3 id="JS代码-1"><a href="#JS代码-1" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针：</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>, pre = <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        temp = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp = cur = null;</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表的定义&quot;&gt;&lt;a href=&quot;#链表的定义&quot; class=&quot;headerlink&quot; title=&quot;链表的定义&quot;&gt;&lt;/a&gt;链表的定义&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-19</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c9.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c9.html</id>
    <published>2024-07-19T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="58-区间和"><a href="#58-区间和" class="headerlink" title="58. 区间和"></a>58. 区间和</h3><p>给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b &gt; = a），直至文件结束。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出每个指定区间内元素的总和。</p><p>前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。</p><p><strong>前缀和 在涉及计算区间和的问题时非常有用</strong>！</p><p>C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;vec[i]);</span><br><span class="line">        presum += vec[i];</span><br><span class="line">        p[i] = presum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b)) &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) sum = p[b];</span><br><span class="line">        <span class="keyword">else</span> sum = p[b] - p[a - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-开发商购买土地"><a href="#44-开发商购买土地" class="headerlink" title="44. 开发商购买土地"></a>44. 开发商购买土地</h3><p>在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 </p><p>现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。</p><p>然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 </p><p>注意：区块不可再分。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入两个正整数，代表 n 和 m。 </p><p>接下来的 n 行，每行输出 m 个正整数。</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>请输出一个整数，代表两个子区域内土地总价值之间的最小差距。</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>如果将区域按照如下方式划分：</p><p>1 2 | 3<br>2 1 | 3<br>1 2 | 3 </p><p>两个子区域内土地总价值之间的最小差距可以达到 0。</p><p>数据范围：</p><p>1 &lt;= n, m &lt;= 100；<br>n 和 m 不同时为 1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>看到本题，大家如果想暴力求解，应该是 n^3 的时间复杂度，</p><p>一个 for 枚举分割线， 嵌套 两个for 去累加区间里的和。</p><p>二维前缀和的思想 可以回忆一下 有固定的公式</p><p>在行向遍历的时候，遇到行末尾就统一一下， 在列向遍历的时候，遇到列末尾就统计一下。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            sum += vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计遍历过的行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; m; j++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="comment">// 遍历到行末尾时候开始统计</span></span><br><span class="line">            <span class="keyword">if</span> (j == m - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span>; <span class="comment">// 统计遍历过的列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="comment">// 遍历到列末尾的时候开始统计</span></span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;58-区间和&quot;&gt;&lt;a href=&quot;#58-区间和&quot; class=&quot;headerlink&quot; title=&quot;58. 区间和&quot;&gt;&lt;/a&gt;58. 区间和&lt;/h3&gt;&lt;p&gt;给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。&lt;/p&gt;
&lt;h6 id=&quot;输入描述</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-18</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c8.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c8.html</id>
    <published>2024-07-18T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums = [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p>示例 2：</p><ul><li><p>输入：nums = [-7,-3,2,3,11]</p></li><li><p>输出：[4,9,9,49,121]</p></li></ul><h4 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h4><p>每个数平方之后，排个序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        A[i]*=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> O(n + nlogn)</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = nums[i] * nums[i];</span><br><span class="line">        <span class="keyword">let</span> right = nums[j] * nums[j];</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            res[k--] = right;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[k--] = left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(n)</p><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;    <span class="comment">//起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>);  <span class="comment">//中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>; <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;    <span class="comment">//更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">//初始化一个二维数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="keyword">for</span> (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走完一圈 右下左上 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;977-有序数组的平方&quot;&gt;&lt;a href=&quot;#977-有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;977.有序数组的平方&quot;&gt;&lt;/a&gt;977.有序数组的平方&lt;/h3&gt;&lt;p&gt;给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7-17</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c7.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c7.html</id>
    <published>2024-07-17T18:30:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><strong>704. 二分查找</strong></h5><p>思路：</p><p>二分法第一种写法</p><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid,left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二分法第二种写法</p><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid,left=<span class="number">0</span>,right=nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><strong>27. 移除元素</strong></h5><p>思路</p><p>暴力解法</p><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">removeElement</span> = (<span class="params">nums, val</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">      nums[k++] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h5><p>思路<br>暴力排序</p><p>最直观的想法，莫过于：每个数平方之后，排个序</p><p>双指针法</p><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>,k=n-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">    <span class="keyword">let</span> left = nums[i]*nums[i];</span><br><span class="line">    <span class="keyword">let</span> right = nums[j]*nums[j];</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      res[k] = right</span><br><span class="line">      j--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res[k]=left</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h4&gt;&lt;h5 id=&quot;704-二分查找&quot;&gt;&lt;a href=&quot;#704-二分查找&quot; class=&quot;headerlink&quot; title=&quot;704. 二分查找</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>vue基础day07(vuex)</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c6.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c6.html</id>
    <published>2024-07-16T16:31:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h3><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享</p><p>使用Vuex管理数据的好处：<br>A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护<br>B.能够高效的实现组件之间的数据共享，提高开发效率<br>C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新</p><h3 id="使用Vuex完成计数器案例"><a href="#使用Vuex完成计数器案例" class="headerlink" title="使用Vuex完成计数器案例"></a>使用Vuex完成计数器案例</h3><p>打开创建的vuex项目，找到src目录中的App.vue组件，将代码重新编写如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-addition&gt;&lt;/my-addition&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;----------------------------------------&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;my-subtraction&gt;&lt;/my-subtraction&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Addition from &#x27;./components/Addition.vue&#x27;</span><br><span class="line">import Subtraction from &#x27;./components/Subtraction.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;my-subtraction&#x27;: Subtraction,</span><br><span class="line">    &#x27;my-addition&#x27;: Addition</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在components文件夹中创建Addition.vue组件，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;当前最新的count值为：&lt;/h3&gt;</span><br><span class="line">        &lt;button&gt;+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在components文件夹中创建Subtraction.vue组件，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;当前最新的count值为：&lt;/h3&gt;</span><br><span class="line">        &lt;button&gt;-1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最后在项目根目录(与src平级)中创建 .prettierrc 文件，编写代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;semi&quot;:false,</span><br><span class="line">    &quot;singleQuote&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vuex中的核心特性"><a href="#Vuex中的核心特性" class="headerlink" title="Vuex中的核心特性"></a>Vuex中的核心特性</h3><h4 id="A-State"><a href="#A-State" class="headerlink" title="A.State"></a>A.State</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储</span><br><span class="line">例如，打开项目中的store.js文件，在State对象中可以添加我们要共享的数据，如：count:0</span><br><span class="line"></span><br><span class="line">在组件中访问State的方式：</span><br><span class="line">1).this.$store.state.全局数据名称  如：this.$store.state.count</span><br><span class="line">2).先按需导入mapState函数： import &#123; mapState &#125; from &#x27;vuex&#x27;</span><br><span class="line">然后数据映射为计算属性： computed:&#123; ...mapState([&#x27;全局数据名称&#x27;]) &#125;</span><br></pre></td></tr></table></figure><h4 id="B-Mutation"><a href="#B-Mutation" class="headerlink" title="B.Mutation"></a>B.Mutation</h4><p>Mutation用于修改变更$store中的数据<br>使用方式：<br>打开store.js文件，在mutations中添加代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    add(state,step)&#123;</span><br><span class="line">      //第一个形参永远都是state也就是$state对象</span><br><span class="line">      //第二个形参是调用add时传递的参数</span><br><span class="line">      state.count+=step;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在Addition.vue中给按钮添加事件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;Add&quot;&gt;+1&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  Add()&#123;</span><br><span class="line">    //使用commit函数调用mutations中的对应函数，</span><br><span class="line">    //第一个参数就是我们要调用的mutations中的函数名</span><br><span class="line">    //第二个参数就是传递给add函数的参数</span><br><span class="line">    this.$store.commit(&#x27;add&#x27;,10)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用mutations的第二种方式：<br>import { mapMutations } from ‘vuex’</p><p>methods:{<br>  …mapMutations([‘add’])<br>}<br>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">      <span class="comment">//获得mapMutations映射的sub函数</span></span><br><span class="line">      ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;sub&#x27;</span>]),</span><br><span class="line">      <span class="comment">//当点击按钮时触发Sub函数</span></span><br><span class="line">      <span class="title class_">Sub</span>()&#123;</span><br><span class="line">          <span class="comment">//调用sub函数完成对数据的操作</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">sub</span>(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>:&#123;</span><br><span class="line">      ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-Action"><a href="#C-Action" class="headerlink" title="C.Action"></a>C.Action</h4><p>在mutations中不能编写异步的代码，会导致vue调试器的显示出错。<br>在vuex中我们可以使用Action来执行异步操作。<br>操作步骤如下：<br>打开store.js文件，修改Action，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">addAsync</span>(<span class="params">context,step</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>,step);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Addition.vue中给按钮添加事件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;AddAsync&quot;&gt;...+1&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  AddAsync()&#123;</span><br><span class="line">    this.$store.dispatch(&#x27;addAsync&#x27;,5)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：<br>import { mapActions } from ‘vuex’</p><p>methods:{<br>  …mapMutations([‘subAsync’])<br>}<br>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapMutations,mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">      <span class="comment">//获得mapMutations映射的sub函数</span></span><br><span class="line">      ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;sub&#x27;</span>]),</span><br><span class="line">      <span class="comment">//当点击按钮时触发Sub函数</span></span><br><span class="line">      <span class="title class_">Sub</span>()&#123;</span><br><span class="line">          <span class="comment">//调用sub函数完成对数据的操作</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">sub</span>(<span class="number">10</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//获得mapActions映射的addAsync函数</span></span><br><span class="line">      ...<span class="title function_">mapActions</span>([<span class="string">&#x27;subAsync&#x27;</span>]),</span><br><span class="line">      <span class="title function_">asyncSub</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">subAsync</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>:&#123;</span><br><span class="line">      ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Getter"><a href="#D-Getter" class="headerlink" title="D.Getter"></a>D.Getter</h4><p>Getter用于对Store中的数据进行加工处理形成新的数据<br>它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化<br>打开store.js文件，添加getters，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  .......</span><br><span class="line">  getters:&#123;</span><br><span class="line">    //添加了一个showNum的属性</span><br><span class="line">    showNum : state =&gt;&#123;</span><br><span class="line">      return &#x27;最新的count值为：&#x27;+state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后打开Addition.vue中，添加插值表达式使用getters</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;&#123;&#123;$store.getters.showNum&#125;&#125;&lt;/h3&gt;</span><br><span class="line">或者也可以在Addition.vue中，导入mapGetters，并将之映射为计算属性</span><br><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapGetters([&#x27;showNum&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Vuex概述&quot;&gt;&lt;a href=&quot;#Vuex概述&quot; class=&quot;headerlink&quot; title=&quot;Vuex概述&quot;&gt;&lt;/a&gt;Vuex概述&lt;/h3&gt;&lt;p&gt;Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享&lt;/p&gt;
&lt;p&gt;使用Vue</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>vue基础day06(前端工程化)</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c5.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c5.html</id>
    <published>2024-07-15T16:31:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块化的分类"><a href="#1-模块化的分类" class="headerlink" title="1.模块化的分类"></a>1.模块化的分类</h3><h4 id="A-浏览器端的模块化"><a href="#A-浏览器端的模块化" class="headerlink" title="A.浏览器端的模块化"></a>A.浏览器端的模块化</h4><pre><code>    1).AMD(Asynchronous Module Definition,异步模块定义)    代表产品为：Require.js    2).CMD(Common Module Definition,通用模块定义)    代表产品为：Sea.js</code></pre><h4 id="B-服务器端的模块化"><a href="#B-服务器端的模块化" class="headerlink" title="B.服务器端的模块化"></a>B.服务器端的模块化</h4><pre><code>    服务器端的模块化规范是使用CommonJS规范：    1).使用require引入其他模块或者包    2).使用exports或者module.exports导出模块成员    3).一个文件就是一个模块，都拥有独立的作用域</code></pre><h4 id="C-ES6模块化"><a href="#C-ES6模块化" class="headerlink" title="C.ES6模块化"></a>C.ES6模块化</h4><pre><code>    ES6模块化规范中定义：        1).每一个js文件都是独立的模块        2).导入模块成员使用import关键字        3).暴露模块成员使用export关键字</code></pre><p>小结：推荐使用ES6模块化，因为AMD，CMD局限使用与浏览器端，而CommonJS在服务器端使用。<br>      ES6模块化是浏览器端和服务器端通用的规范.</p><h3 id="2-在NodeJS中安装babel"><a href="#2-在NodeJS中安装babel" class="headerlink" title="2.在NodeJS中安装babel"></a>2.在NodeJS中安装babel</h3><h4 id="A-安装babel"><a href="#A-安装babel" class="headerlink" title="A.安装babel"></a>A.安装babel</h4><pre><code>打开终端，输入命令：npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node安装完毕之后，再次输入命令安装：npm install --save @babel/polyfill</code></pre><h4 id="B-创建babel-config-js"><a href="#B-创建babel-config-js" class="headerlink" title="B.创建babel.config.js"></a>B.创建babel.config.js</h4><pre><code>在项目目录中创建babel.config.js文件。编辑js文件中的代码如下：    const presets = [        [&quot;@babel/env&quot;,&#123;            targets:&#123;                edge:&quot;17&quot;,                firefox:&quot;60&quot;,                chrome:&quot;67&quot;,                safari:&quot;11.1&quot;            &#125;        &#125;]    ]    //暴露    module.exports = &#123; presets &#125;</code></pre><h4 id="C-创建index-js文件"><a href="#C-创建index-js文件" class="headerlink" title="C.创建index.js文件"></a>C.创建index.js文件</h4><pre><code>在项目目录中创建index.js文件作为入口文件在index.js中输入需要执行的js代码，例如：    console.log(&quot;ok&quot;);</code></pre><h4 id="D-使用npx执行文件"><a href="#D-使用npx执行文件" class="headerlink" title="D.使用npx执行文件"></a>D.使用npx执行文件</h4><pre><code>打开终端，输入命令：npx babel-node ./index.js</code></pre><h3 id="3-设置默认导入-导出"><a href="#3-设置默认导入-导出" class="headerlink" title="3.设置默认导入/导出"></a>3.设置默认导入/导出</h3><h4 id="A-默认导出"><a href="#A-默认导出" class="headerlink" title="A.默认导出"></a>A.默认导出</h4><pre><code>export default &#123;    成员A,    成员B,    .......&#125;,如下：let num = 100;export default&#123;    num&#125;</code></pre><h4 id="B-默认导入"><a href="#B-默认导入" class="headerlink" title="B.默认导入"></a>B.默认导入</h4><pre><code>import 接收名称 from &quot;模块标识符&quot;，如下：import test from &quot;./test.js&quot;</code></pre><p>注意：在一个模块中，只允许使用export default向外默认暴露一次成员，千万不要写多个export default。<br>如果在一个模块中没有向外暴露成员，其他模块引入该模块时将会得到一个空对象 </p><h3 id="4-设置按需导入-导出"><a href="#4-设置按需导入-导出" class="headerlink" title="4.设置按需导入/导出"></a>4.设置按需导入/导出</h3><h4 id="A-按需导出"><a href="#A-按需导出" class="headerlink" title="A.按需导出"></a>A.按需导出</h4><pre><code>export let num = 998;export let myName = &quot;jack&quot;;export function fn = function()&#123; console.log(&quot;fn&quot;) &#125;</code></pre><h4 id="B-按需导入"><a href="#B-按需导入" class="headerlink" title="B.按需导入"></a>B.按需导入</h4><pre><code>import &#123; num,fn as printFn ,myName &#125; from &quot;./test.js&quot;//同时导入默认导出的成员以及按需导入的成员import test,&#123; num,fn as printFn ,myName &#125; from &quot;./test.js&quot;</code></pre><p>注意：一个模块中既可以按需导入也可以默认导入，一个模块中既可以按需导出也可以默认导出</p><h3 id="5-直接导入并执行代码"><a href="#5-直接导入并执行代码" class="headerlink" title="5.直接导入并执行代码"></a>5.直接导入并执行代码</h3><pre><code>import &quot;./test2.js&quot;;</code></pre><h3 id="6-webpack的概念"><a href="#6-webpack的概念" class="headerlink" title="6.webpack的概念"></a>6.webpack的概念</h3><p>webpack是一个流行的前端项目构建工具，可以解决目前web开发的困境。<br>webpack提供了模块化支持，代码压缩混淆，解决js兼容问题，性能优化等特性，提高了开发效率和项目的可维护性</p><h3 id="7-webpack的基本使用"><a href="#7-webpack的基本使用" class="headerlink" title="7.webpack的基本使用"></a>7.webpack的基本使用</h3><h4 id="A-创建项目目录并初始化"><a href="#A-创建项目目录并初始化" class="headerlink" title="A.创建项目目录并初始化"></a>A.创建项目目录并初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建项目，并打开项目所在目录的终端，输入命令：</span><br><span class="line">    npm init -y</span><br></pre></td></tr></table></figure><h4 id="B-创建首页及js文件"><a href="#B-创建首页及js文件" class="headerlink" title="B.创建首页及js文件"></a>B.创建首页及js文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在项目目录中创建index.html页面，并初始化页面结构：在页面中摆放一个ul，ul里面放置几个li</span><br><span class="line">在项目目录中创建js文件夹，并在文件夹中创建index.js文件</span><br></pre></td></tr></table></figure><h4 id="C-安装jQuery"><a href="#C-安装jQuery" class="headerlink" title="C.安装jQuery"></a>C.安装jQuery</h4><pre><code>打开项目目录终端，输入命令:npm install jQuery -S</code></pre><h4 id="D-导入jQuery"><a href="#D-导入jQuery" class="headerlink" title="D.导入jQuery"></a>D.导入jQuery</h4><pre><code>打开index.js文件，编写代码导入jQuery并实现功能：import $ from &quot;jquery&quot;;$(function()&#123;    $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;cyan&quot;);    $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;pink&quot;);&#125;)</code></pre><p>注意：此时项目运行会有错误，因为import $ from “jquery”;这句代码属于ES6的新语法代码，在浏览器中可能会存在兼容性问题<br>所以我们需要webpack来帮助我们解决这个问题。</p><h4 id="E-安装webpack"><a href="#E-安装webpack" class="headerlink" title="E.安装webpack"></a>E.安装webpack</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1).打开项目目录终端，输入命令:</span><br><span class="line">npm install webpack webpack-cli -D</span><br><span class="line">2).然后在项目根目录中，创建一个 webpack.config.js 的配置文件用来配置webpack</span><br><span class="line">在 webpack.config.js 文件中编写代码进行webpack配置，如下：</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&quot;development&quot;//可以设置为development(开发模式)，production(发布模式)</span><br><span class="line">&#125;</span><br><span class="line">补充：mode设置的是项目的编译模式。</span><br><span class="line">如果设置为development则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些</span><br><span class="line">如果设置为production则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些</span><br><span class="line">3).修改项目中的package.json文件添加运行脚本dev，如下：</span><br><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;dev&quot;:&quot;webpack&quot;</span><br><span class="line">&#125;</span><br><span class="line">注意：scripts节点下的脚本，可以通过 npm run 运行，如：</span><br><span class="line">运行终端命令：npm run dev</span><br><span class="line">将会启动webpack进行项目打包</span><br><span class="line">4).运行dev命令进行项目打包，并在页面中引入项目打包生成的js文件</span><br><span class="line">打开项目目录终端，输入命令:</span><br><span class="line">npm run dev</span><br><span class="line">等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。</span><br><span class="line">浏览页面查看效果。</span><br></pre></td></tr></table></figure><h3 id="8-设置webpack的打包入口-出口"><a href="#8-设置webpack的打包入口-出口" class="headerlink" title="8.设置webpack的打包入口/出口"></a>8.设置webpack的打包入口/出口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在webpack 4.x中，默认会将src/index.js 作为默认的打包入口js文件</span><br><span class="line">                 默认会将dist/main.js 作为默认的打包输出js文件</span><br><span class="line">如果不想使用默认的入口/出口js文件，我们可以通过改变 webpack.config.js 来设置入口/出口的js文件，如下：</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    //设置入口文件路径</span><br><span class="line">    entry: path.join(__dirname,&quot;./src/xx.js&quot;),</span><br><span class="line">    //设置出口文件</span><br><span class="line">    output:&#123;</span><br><span class="line">        //设置路径</span><br><span class="line">        path:path.join(__dirname,&quot;./dist&quot;),</span><br><span class="line">        //设置文件名</span><br><span class="line">        filename:&quot;res.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-设置webpack的自动打包"><a href="#9-设置webpack的自动打包" class="headerlink" title="9.设置webpack的自动打包"></a>9.设置webpack的自动打包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，我们更改入口js文件的代码，需要重新运行命令打包webpack，才能生成出口的js文件</span><br><span class="line">那么每次都要重新执行命令打包，这是一个非常繁琐的事情，那么，自动打包可以解决这样繁琐的操作。</span><br><span class="line">实现自动打包功能的步骤如下：</span><br><span class="line">    A.安装自动打包功能的包:webpack-dev-server</span><br><span class="line">        npm install webpack-dev-server -D</span><br><span class="line">    B.修改package.json中的dev指令如下：</span><br><span class="line">        &quot;scripts&quot;:&#123;</span><br><span class="line">            &quot;dev&quot;:&quot;webpack-dev-server&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    C.将引入的js文件路径更改为：&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    D.运行npm run dev，进行打包</span><br><span class="line">    E.打开网址查看效果：http://localhost:8080</span><br><span class="line"></span><br><span class="line">注意：webpack-dev-server自动打包的输出文件，默认放到了服务器的根目录中.</span><br></pre></td></tr></table></figure><p>补充：<br>在自动打包完毕之后，默认打开服务器网页，实现方式就是打开package.json文件，修改dev命令：<br>    “dev”: “webpack-dev-server —open —host 127.0.0.1 —port 9999”</p><h3 id="10-配置html-webpack-plugin"><a href="#10-配置html-webpack-plugin" class="headerlink" title="10.配置html-webpack-plugin"></a>10.配置html-webpack-plugin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">使用html-webpack-plugin 可以生成一个预览页面。</span><br><span class="line">因为当我们访问默认的 http://localhost:8080/的时候，看到的是一些文件和文件夹，想要查看我们的页面</span><br><span class="line">还需要点击文件夹点击文件才能查看，那么我们希望默认就能看到一个页面，而不是看到文件夹或者目录。</span><br><span class="line">实现默认预览页面功能的步骤如下：</span><br><span class="line">    A.安装默认预览功能的包:html-webpack-plugin</span><br><span class="line">        npm install html-webpack-plugin -D</span><br><span class="line">    B.修改webpack.config.js文件，如下：</span><br><span class="line">        //导入包</span><br><span class="line">        const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">        //创建对象</span><br><span class="line">        const htmlPlugin = new HtmlWebpackPlugin(&#123;</span><br><span class="line">            //设置生成预览页面的模板文件</span><br><span class="line">            template:&quot;./src/index.html&quot;,</span><br><span class="line">            //设置生成的预览页面名称</span><br><span class="line">            filename:&quot;index.html&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    C.继续修改webpack.config.js文件，添加plugins信息：</span><br><span class="line">        module.exports = &#123;</span><br><span class="line">            ......</span><br><span class="line">            plugins:[ htmlPlugin ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="11-webpack中的加载器"><a href="#11-webpack中的加载器" class="headerlink" title="11.webpack中的加载器"></a>11.webpack中的加载器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">通过loader打包非js模块：默认情况下，webpack只能打包js文件，如果想要打包非js文件，需要调用loader加载器才能打包</span><br><span class="line">    loader加载器包含：</span><br><span class="line">        <span class="number">1</span>).<span class="property">less</span>-loader</span><br><span class="line">        <span class="number">2</span>).<span class="property">sass</span>-loader</span><br><span class="line">        <span class="number">3</span>).<span class="property">url</span>-<span class="attr">loader</span>:打包处理css中与url路径有关的文件</span><br><span class="line">        <span class="number">4</span>).<span class="property">babel</span>-<span class="attr">loader</span>:处理高级js语法的加载器</span><br><span class="line">        <span class="number">5</span>).<span class="property">postcss</span>-loader</span><br><span class="line">        <span class="number">6</span>).<span class="property">css</span>-loader,style-loader</span><br><span class="line"></span><br><span class="line">注意：指定多个loader时的顺序是固定的，而调用loader的顺序是从后向前进行调用</span><br><span class="line"></span><br><span class="line">A.安装style-loader,css-loader来处理样式文件</span><br><span class="line">    <span class="number">1</span>).安装包</span><br><span class="line">        npm install style-loader css-loader -D</span><br><span class="line">    <span class="number">2</span>).配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">        <span class="variable language_">module</span> : &#123;</span><br><span class="line">            <span class="attr">rules</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">B.安装less,less-loader处理less文件</span><br><span class="line">    <span class="number">1</span>).安装包</span><br><span class="line">        npm install less-loader less -D</span><br><span class="line">    <span class="number">2</span>).配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">        <span class="variable language_">module</span> : &#123;</span><br><span class="line">            <span class="attr">rules</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,</span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">C.安装sass-loader,node-sass处理less文件</span><br><span class="line">    <span class="number">1</span>).安装包</span><br><span class="line">        npm install sass-loader node-sass -D</span><br><span class="line">    <span class="number">2</span>).配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">        <span class="variable language_">module</span> : &#123;</span><br><span class="line">            <span class="attr">rules</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,</span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,</span><br><span class="line">                    <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    补充：安装sass-loader失败时，大部分情况是因为网络原因，详情参考：</span><br><span class="line">    <span class="attr">https</span>:<span class="comment">//segmentfault.com/a/1190000010984731?utm_source=tag-newest</span></span><br><span class="line"></span><br><span class="line">D.安装post-css自动添加css的兼容性前缀（-ie-,-webkit-）</span><br><span class="line"><span class="number">1</span>).安装包</span><br><span class="line">    npm install postcss-loader autoprefixer -D</span><br><span class="line"><span class="number">2</span>).在项目根目录创建并配置postcss.<span class="property">config</span>.<span class="property">js</span>文件</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[ autoprefixer ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>).配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">    <span class="variable language_">module</span> : &#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.打包样式表中的图片以及字体文件</span><br><span class="line">在样式表css中有时候会设置背景图片和设置字体文件，一样需要loader进行处理</span><br><span class="line">使用url-loader和file-loader来处理打包图片文件以及字体文件</span><br><span class="line"><span class="number">1</span>).安装包</span><br><span class="line">    npm install url-loader file-loader -D</span><br><span class="line"><span class="number">2</span>).配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">    <span class="variable language_">module</span> : &#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>,</span><br><span class="line">                <span class="comment">//limit用来设置字节数，只有小于limit值的图片，才会转换</span></span><br><span class="line">                <span class="comment">//为base64图片</span></span><br><span class="line">                <span class="attr">use</span>:<span class="string">&quot;url-loader?limit=16940&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F.打包js文件中的高级语法：在编写js的时候，有时候我们会使用高版本的js语法</span><br><span class="line">有可能这些高版本的语法不被兼容，我们需要将之打包为兼容性的js代码</span><br><span class="line">我们需要安装babel系列的包</span><br><span class="line">A.安装babel转换器</span><br><span class="line">    npm install babel-loader @babel/core @babel/runtime -D</span><br><span class="line">B.安装babel语法插件包</span><br><span class="line">    npm install @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-<span class="keyword">class</span>-properties -D</span><br><span class="line">C.在项目根目录创建并配置babel.<span class="property">config</span>.<span class="property">js</span>文件</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">        <span class="attr">presets</span>:[<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">        <span class="attr">plugins</span>:[ <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>, <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">D.配置规则：更改webpack.<span class="property">config</span>.<span class="property">js</span>的<span class="variable language_">module</span>中的rules数组</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="attr">plugins</span>:[ htmlPlugin ],</span><br><span class="line">    <span class="variable language_">module</span> : &#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//test设置需要匹配的文件类型，支持正则</span></span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">//use表示该文件类型需要调用的loader</span></span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,</span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>,</span><br><span class="line">                <span class="comment">//limit用来设置字节数，只有小于limit值的图片，才会转换</span></span><br><span class="line">                <span class="comment">//为base64图片</span></span><br><span class="line">                <span class="attr">use</span>:<span class="string">&quot;url-loader?limit=16940&quot;</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>:<span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="comment">//exclude为排除项，意思是不要处理node_modules中的js文件</span></span><br><span class="line">                <span class="attr">exclude</span>:<span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Vue单文件组件"><a href="#12-Vue单文件组件" class="headerlink" title="12.Vue单文件组件"></a>12.Vue单文件组件</h3><p>传统Vue组件的缺陷：<br>全局定义的组件不能重名，字符串模板缺乏语法高亮，不支持css(当html和js组件化时，css没有参与其中)<br>没有构建步骤限制，只能使用H5和ES5，不能使用预处理器（babel）<br>解决方案：<br>使用Vue单文件组件，每个单文件组件的后缀名都是.vue<br>每一个Vue单文件组件都由三部分组成<br>1).template组件组成的模板区域<br>2).script组成的业务逻辑区域<br>3).style样式区域</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    组件代码区域</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    js代码区域</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    样式代码区域</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>补充：安装Vetur插件可以使得.vue文件中的代码高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">配置.vue文件的加载器</span><br><span class="line"></span><br><span class="line">A.安装vue组件的加载器</span><br><span class="line"></span><br><span class="line">    npm install vue-loader vue-template-compiler -D</span><br><span class="line"></span><br><span class="line">B.配置规则：更改webpack.config.js的module中的rules数组</span><br><span class="line"></span><br><span class="line">    const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);</span><br><span class="line"></span><br><span class="line">    const vuePlugin = new VueLoaderPlugin();</span><br><span class="line"></span><br><span class="line">    module.exports = &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        plugins:[ htmlPlugin, vuePlugin  ],</span><br><span class="line"></span><br><span class="line">        module : &#123;</span><br><span class="line"></span><br><span class="line">            rules:[</span><br><span class="line"></span><br><span class="line">                ...//其他规则</span><br><span class="line"></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    test:/.vue$/,</span><br><span class="line"></span><br><span class="line">                    loader:&quot;vue-loader&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-在webpack中使用vue"><a href="#13-在webpack中使用vue" class="headerlink" title="13.在webpack中使用vue"></a>13.在webpack中使用vue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">上一节我们安装处理了vue单文件组件的加载器，想要让vue单文件组件能够使用，我们必须要安装vue</span><br><span class="line"></span><br><span class="line">并使用vue来引用vue单文件组件。</span><br><span class="line"></span><br><span class="line">A.安装Vue</span><br><span class="line"></span><br><span class="line">    npm install vue -S</span><br><span class="line"></span><br><span class="line">B.在index.js中引入vue：import Vue from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">C.创建Vue实例对象并指定el，最后使用render函数渲染单文件组件</span><br><span class="line"></span><br><span class="line">    const vm = new Vue(&#123;</span><br><span class="line"></span><br><span class="line">        el:&quot;#first&quot;,</span><br><span class="line"></span><br><span class="line">        render:h=&gt;h(app)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="14-使用webpack打包发布项目"><a href="#14-使用webpack打包发布项目" class="headerlink" title="14.使用webpack打包发布项目"></a>14.使用webpack打包发布项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在项目上线之前，我们需要将整个项目打包并发布。</span><br><span class="line"></span><br><span class="line">A.配置package.json</span><br><span class="line"></span><br><span class="line">    &quot;scripts&quot;:&#123;</span><br><span class="line"></span><br><span class="line">        &quot;dev&quot;:&quot;webpack-dev-server&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;build&quot;:&quot;webpack -p&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">B.在项目打包之前，可以将dist目录删除，生成全新的dist目录</span><br></pre></td></tr></table></figure><h3 id="15-Vue脚手架"><a href="#15-Vue脚手架" class="headerlink" title="15.Vue脚手架"></a>15.Vue脚手架</h3><p>Vue脚手架可以快速生成Vue项目基础的架构。<br>A.安装3.x版本的Vue脚手架：<br>    npm install -g @vue/cli<br>B.基于3.x版本的脚手架创建Vue项目：<br>    1).使用命令创建Vue项目<br>        命令：vue create my-project<br>        选择Manually select features(选择特性以创建项目)<br>        勾选特性可以用空格进行勾选。<br>        是否选用历史模式的路由：n<br>        ESLint选择：ESLint + Standard config<br>        何时进行ESLint语法校验：Lint on save<br>        babel，postcss等配置文件如何放置：In dedicated config files(单独使用文件进行配置)<br>        是否保存为模板：n<br>        使用哪个工具安装包：npm<br>    2).基于ui界面创建Vue项目<br>        命令：vue ui<br>        在自动打开的创建项目网页中配置项目信息。<br>    3).基于2.x的旧模板，创建Vue项目<br>        npm install -g @vue/cli-init<br>        vue init webpack my-project</p><p>C.分析Vue脚手架生成的项目结构<br>    node_modules:依赖包目录<br>    public：静态资源目录<br>    src：源码目录<br>    src/assets:资源目录<br>    src/components：组件目录<br>    src/views:视图组件目录<br>    src/App.vue:根组件<br>    src/main.js:入口js<br>    src/router.js:路由js<br>    babel.config.js:babel配置文件</p><h3 id="16-Vue脚手架的自定义配置"><a href="#16-Vue脚手架的自定义配置" class="headerlink" title="16.Vue脚手架的自定义配置"></a>16.Vue脚手架的自定义配置</h3><pre><code>A.通过 package.json 进行配置 [不推荐使用]    &quot;vue&quot;:&#123;        &quot;devServer&quot;:&#123;            &quot;port&quot;:&quot;9990&quot;,            &quot;open&quot;:true        &#125;    &#125;B.通过单独的配置文件进行配置，创建vue.config.js    module.exports = &#123;        devServer:&#123;            port:8888,            open:true        &#125;    &#125;</code></pre><h3 id="17-Element-UI的基本使用"><a href="#17-Element-UI的基本使用" class="headerlink" title="17.Element-UI的基本使用"></a>17.Element-UI的基本使用</h3><p>Element-UI:一套基于2.0的桌面端组件库<br>官网地址：<a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a><br>A.安装：<br>    npm install element-ui -S<br>B.导入使用：<br>    import ElementUI from “element-ui”;<br>    import “element-ui/lib/theme-chalk/index.css”;</p><pre><code>Vue.use(ElementUI)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块化的分类&quot;&gt;&lt;a href=&quot;#1-模块化的分类&quot; class=&quot;headerlink&quot; title=&quot;1.模块化的分类&quot;&gt;&lt;/a&gt;1.模块化的分类&lt;/h3&gt;&lt;h4 id=&quot;A-浏览器端的模块化&quot;&gt;&lt;a href=&quot;#A-浏览器端的模块化&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>vue基础day05(路由)</title>
    <link href="https://daixueshengt.github.io/posts/110fa4c4.html"/>
    <id>https://daixueshengt.github.io/posts/110fa4c4.html</id>
    <published>2024-07-14T16:31:00.000Z</published>
    <updated>2024-10-09T11:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>前端路由是基于hash值的变化进行实现的（比如点击页面中的菜单或者按钮改变URL的hash值，根据hash值的变化来控制组件的切换）<br>核心实现依靠一个事件，即监听hash值变化的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//location.hash可以获取到最新的hash值</span></span><br><span class="line">    location.<span class="property">hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路：<br>在页面中有一个vue实例对象，vue实例对象中有四个组件，分别是tab栏切换需要显示的组件内容<br>在页面中有四个超链接，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#/zhuye&quot;</span>&gt;主页&lt;/a&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/keji&quot;</span>&gt;</span>科技<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/caijing&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/yule&quot;</span>&gt;</span>娱乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当我们点击这些超链接的时候，就会改变url地址中的hash值，当hash值被改变时，就会触发onhashchange事件<br>在触发onhashchange事件的时候，我们根据hash值来让不同的组件进行显示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过 location.hash 获取到最新的 hash 值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span><br><span class="line">    <span class="keyword">switch</span>(location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/zhuye&#x27;</span>:</span><br><span class="line">        <span class="comment">//通过更改数据comName来指定显示的组件</span></span><br><span class="line">        <span class="comment">//因为 &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; ，组件已经绑定了comName</span></span><br><span class="line">        vm.<span class="property">comName</span> = <span class="string">&#x27;zhuye&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/keji&#x27;</span>:</span><br><span class="line">        vm.<span class="property">comName</span> = <span class="string">&#x27;keji&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/caijing&#x27;</span>:</span><br><span class="line">        vm.<span class="property">comName</span> = <span class="string">&#x27;caijing&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/yule&#x27;</span>:</span><br><span class="line">        vm.<span class="property">comName</span> = <span class="string">&#x27;yule&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-Router简介"><a href="#Vue-Router简介" class="headerlink" title="Vue Router简介"></a>Vue Router简介</h3><p>它是一个Vue.js官方提供的路由管理器。是一个功能更加强大的前端路由器，推荐使用。<br>Vue Router和Vue.js非常契合，可以一起方便的实现SPA(single page web application,单页应用程序)应用程序的开发。<br>Vue Router依赖于Vue，所以需要先引入Vue，再引入Vue Router</p><p>Vue Router的特性：<br>支持H5历史模式或者hash模式<br>支持嵌套路由<br>支持路由参数<br>支持编程式路由<br>支持命名路由<br>支持路由导航守卫<br>支持路由过渡动画特效<br>支持路由懒加载<br>支持路由滚动行为</p><h3 id="Vue-Router的使用步骤-★★★"><a href="#Vue-Router的使用步骤-★★★" class="headerlink" title="Vue Router的使用步骤(★★★)"></a>Vue Router的使用步骤(★★★)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">A.导入js文件</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;lib/vue_2.5.22.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/vue-router_3.0.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">B.添加路由链接:<span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span>&gt;</span>是路由中提供的标签，默认会被渲染为a标签，to属性默认被渲染为href属性，</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">to属性的值会被渲染为#开头的hash地址</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">C.添加路由填充位（路由占位符）</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">D.定义路由组件</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">var User = &#123; template:&quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>This is User<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot; &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">var Login = &#123; template:&quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>This is Login<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot; &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">E.配置路由规则并创建路由实例</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">var myRouter = new VueRouter(&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    //routes是路由规则数组</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    routes:[</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        //每一个路由规则都是一个对象，对象中至少包含path和component两个属性</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        //path表示  路由匹配的hash地址，component表示路由规则对应要展示的组件对象</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123;path:&quot;/user&quot;,component:User&#125;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123;path:&quot;/login&quot;,component:Login&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    ]</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">F.将路由挂载到Vue实例中</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">new Vue(&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    el:&quot;#app&quot;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    //通过router属性挂载路由对象</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    router:myRouter</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">小结：</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">Vue Router的使用步骤还是比较清晰的，按照步骤一步一步就能完成路由操作</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">A.导入js文件</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">B.添加路由链接</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">C.添加路由占位符(最后路由展示的组件就会在占位符的位置显示)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">D.定义路由组件</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">E.配置路由规则并创建路由实例</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">F.将路由挂载到Vue实例中</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">补充：</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">路由重定向：可以通过路由重定向为页面设置默认展示的组件</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">在路由规则中添加一条路由规则即可，如下：</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">var myRouter = new VueRouter(&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    //routes是路由规则数组</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    routes: [</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        //path设置为/表示页面最初始的地址 / ,redirect表示要被重定向的新地址，设置为一个路由即可</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123; path:&quot;/&quot;,redirect:&quot;/user&quot;&#125;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123; path: &quot;/user&quot;, component: User &#125;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123; path: &quot;/login&quot;, component: Login &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    ]</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="嵌套路由，动态路由的实现方式"><a href="#嵌套路由，动态路由的实现方式" class="headerlink" title="嵌套路由，动态路由的实现方式"></a>嵌套路由，动态路由的实现方式</h3><h4 id="A-嵌套路由的概念-★★★"><a href="#A-嵌套路由的概念-★★★" class="headerlink" title="A.嵌套路由的概念(★★★)"></a>A.嵌套路由的概念(★★★)</h4><p>当我们进行路由的时候显示的组件中还有新的子级路由链接以及内容。</p><p>嵌套路由最关键的代码在于理解子级路由的概念：<br>比如我们有一个/login的路由<br>那么/login下面还可以添加子级路由，如:<br>/login/account<br>/login/phone</p><p>参考代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">User</span> = &#123; <span class="attr">template</span>: <span class="string">&quot;&lt;div&gt;This is User&lt;/div&gt;&quot;</span> &#125;</span><br><span class="line"><span class="comment">//Login组件中的模板代码里面包含了子级路由链接以及子级路由的占位符</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Login</span> = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;This is Login&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to=&quot;/login/account&quot;&gt;账号密码登录&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to=&quot;/login/phone&quot;&gt;扫码登录&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- 子路由组件将会在router-view中显示 --&gt;</span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义两个子级路由组件</span></span><br><span class="line">    <span class="keyword">var</span> account = &#123; <span class="attr">template</span>:<span class="string">&quot;&lt;div&gt;账号：&lt;input&gt;&lt;br&gt;密码：&lt;input&gt;&lt;/div&gt;&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> phone = &#123; <span class="attr">template</span>:<span class="string">&quot;&lt;h1&gt;扫我二维码&lt;/h1&gt;&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> myRouter = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">        <span class="comment">//routes是路由规则数组</span></span><br><span class="line">        <span class="attr">routes</span>: [</span><br><span class="line">            &#123; <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,<span class="attr">redirect</span>:<span class="string">&quot;/user&quot;</span>&#125;,</span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="string">&quot;/user&quot;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;,</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>, </span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Login</span>,</span><br><span class="line">                <span class="comment">//通过children属性为/login添加子路由规则</span></span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123; <span class="attr">path</span>: <span class="string">&quot;/login/account&quot;</span>, <span class="attr">component</span>: account &#125;,</span><br><span class="line">                    &#123; <span class="attr">path</span>: <span class="string">&quot;/login/phone&quot;</span>, <span class="attr">component</span>: phone &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">router</span>:myRouter</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="B-动态路由匹配-★★★"><a href="#B-动态路由匹配-★★★" class="headerlink" title="B.动态路由匹配(★★★)"></a>B.动态路由匹配(★★★)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">User</span> = &#123; <span class="attr">template</span>:<span class="string">&quot;&lt;div&gt;用户：&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRouter = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//routes是路由规则数组</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过/:参数名  的形式传递参数 </span></span><br><span class="line"></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;,</span><br><span class="line"></span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-命名路由以及编程式导航"><a href="#7-命名路由以及编程式导航" class="headerlink" title="7.命名路由以及编程式导航"></a>7.命名路由以及编程式导航</h3><h4 id="A-命名路由：给路由取别名"><a href="#A-命名路由：给路由取别名" class="headerlink" title="A.命名路由：给路由取别名"></a>A.命名路由：给路由取别名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRouter = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//routes是路由规则数组</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过name属性为路由添加一个别名</span></span><br><span class="line"></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>, <span class="attr">component</span>: <span class="title class_">User</span>, <span class="attr">name</span>:<span class="string">&quot;user&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加了别名之后，可以使用别名进行跳转</span></span><br><span class="line"></span><br><span class="line">&lt;router-link to=<span class="string">&quot;/user&quot;</span>&gt;<span class="title class_">User</span>&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&#x27;user&#x27; , params: &#123;id:123&#125; &#125;&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以编程式导航</span></span><br><span class="line"></span><br><span class="line">myRouter.<span class="title function_">push</span>( &#123; <span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span> , <span class="attr">params</span>: &#123;<span class="attr">id</span>:<span class="number">123</span>&#125; &#125; )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="B-编程式导航-★★★"><a href="#B-编程式导航-★★★" class="headerlink" title="B.编程式导航(★★★)"></a>B.编程式导航(★★★)</h4><p>页面导航的两种方式：<br>A.声明式导航：通过点击链接的方式实现的导航<br>B.编程式导航：调用js的api方法实现导航</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>-<span class="title class_">Router</span>中常见的导航方式：</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&quot;hash地址&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span> , <span class="attr">params</span>: &#123;<span class="attr">id</span>:<span class="number">123</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>:<span class="string">&quot;/login&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>:<span class="string">&quot;/login&quot;</span>,<span class="attr">query</span>:&#123;<span class="attr">username</span>:<span class="string">&quot;jack&quot;</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>( n );<span class="comment">//n为数字，参考history.go</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>( -<span class="number">1</span> );</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端路由&quot;&gt;&lt;a href=&quot;#前端路由&quot; class=&quot;headerlink&quot; title=&quot;前端路由&quot;&gt;&lt;/a&gt;前端路由&lt;/h3&gt;&lt;p&gt;前端路由是基于hash值的变化进行实现的（比如点击页面中的菜单或者按钮改变URL的hash值，根据hash值的变化来控制组件</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="知识点" scheme="https://daixueshengt.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
</feed>
