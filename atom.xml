<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陶同学&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/85a0cbb73a82a62a3f9fc11c5e6f5f5c</icon>
  <subtitle>hhh</subtitle>
  <link href="https://daixueshengt.github.io/atom.xml" rel="self"/>
  
  <link href="https://daixueshengt.github.io/"/>
  <updated>2024-07-04T06:56:56.043Z</updated>
  <id>https://daixueshengt.github.io/</id>
  
  <author>
    <name>陶同学</name>
    <email>2568510567@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript基础</title>
    <link href="https://daixueshengt.github.io/posts/100fa4c0.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4c0.html</id>
    <published>2024-07-04T11:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<p>想要系统学习ts ，可以查看阮一峰老师的教程 <a href="https://wangdoc.com/typescript/intro">TypeScript教程</a></p><h3 id="为什么需要TypeScript"><a href="#为什么需要TypeScript" class="headerlink" title="为什么需要TypeScript"></a><strong>为什么需要TypeScript</strong></h3><p>JavaScript 是一门动态运行语言，没有类型检测，但是这也导致了有很多错误到了运行阶段才能发现，比如说下面一段代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLen</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getLen</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="title function_">getLen</span>() <span class="comment">// 只有在运行时才会报错</span></span><br></pre></td></tr></table></figure><h3 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript"></a><strong>什么是TypeScript</strong></h3><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p><p>Typescript是JavaScript的超集，支持类型，并且最终会被编译成JS代码。</p><h3 id="TS运行环境"><a href="#TS运行环境" class="headerlink" title="TS运行环境"></a><strong>TS运行环境</strong></h3><ol><li>前置条件</li></ol><p>安装ts前，要提前安装<a href="http://node.js/">Node.js</a> , 并且<a href="http://node.js/">Node.js</a>版本最好在V16以上，建议你使用nvm来管理你的nodejs版本。</p><ol><li>ts的安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 ts</span><br><span class="line">npm install typescript -g</span><br><span class="line"># 查看tsc的版本</span><br><span class="line">tsc --version</span><br></pre></td></tr></table></figure><h3 id="TS基本示例"><a href="#TS基本示例" class="headerlink" title="TS基本示例"></a><strong>TS基本示例</strong></h3><p>新建hello.ts文件，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><p>执行下列命令，会看到生成一个.js文件，是与之对应的js代码</p><p>tsc hello.ts</p><p>修改ts代码，在函数参数中加上name:string , 这表示传入的参数名称为name, 类型为string ，如果传入其他类型的参数，比如整数类型100， 代码会自动报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params">name:<span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello,<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&quot;jack&quot;</span>)</span><br><span class="line"><span class="comment">// 下一行代码会自动报错：100下方有红色波浪线</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h3><p>想要为变量添加类型很简单，就是在变量后面添加: type ，但是一旦添加上类型之后，就不能修改其值的类型，比如下面的示例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;mike&quot;</span></span><br><span class="line"><span class="comment">// 不被允许 </span></span><br><span class="line"><span class="comment">// name = 100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a><strong>联合类型</strong></h3><p>联合类型是由两个或者多个其他类型组成的类型，类型和类型之间用| 关联，值可以是类型中的任何一个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;100&quot;</span></span><br><span class="line">id = <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="type类型别名"><a href="#type类型别名" class="headerlink" title="type类型别名"></a><strong>type类型别名</strong></h3><p>假设有多个类型都需要用到同一个类型，别名不允许重名。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumOrStr</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="title class_">NumOrStr</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="title class_">NumOrStr</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a><strong>类型缩小</strong></h3><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”, 区分该值到底属于哪一种类型，然后再进一步处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;100&quot;</span></span><br><span class="line">id = <span class="number">100</span></span><br><span class="line"><span class="comment">// 下面一行代码还是会报错, 类型number上不存在length属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><p>可以使用 typeof/switch等类型判断的方法进行类型缩小。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="property">length</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a><strong>类型推断</strong></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;mike&quot;</span> <span class="comment">// 类型推断为string</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><strong>类型断言</strong></h3><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a><strong>交叉类型</strong></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IName</span> &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPerson</span> = <span class="title class_">IName</span> &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">IPerson</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">age</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a><strong>any</strong></h3><p>如果你不想限制变量的类型，可以使用any, 但是并不推荐这样做。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">any</span> = <span class="string">&quot;mike&quot;</span></span><br><span class="line">name = <span class="number">30</span></span><br><span class="line">name = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a><strong>数组的声明</strong></h3><p>在ts中，要求所有成员必须满足类型要求，其类型有两种写法，第一种是成员的类型之后，加上方括号。如果成员有多种类型，可以使用()将联合类型包起来。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>|<span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>第二种写法是使用内置的 Array 接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="元组的声明"><a href="#元组的声明" class="headerlink" title="元组的声明"></a><strong>元组的声明</strong></h3><p>元组是ts特有的，在数组中应该尽量保持成员类型是相同的，但是元组的成员类型可以自由设置，各个成员的类型可以不同。</p><p>const a: [string, number, string] = [“mike”, 18, “male”]</p><p>使用元组时，必须给出类型，否则会将其视为数组</p><p>const a = [“mike”, 18] // 类型被推断为 (number | string)[]</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a><strong>type</strong></h3><p>除了原始类型，ts还可以为对象定义类型，比如说用一个对象表示一个坐标点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要求坐标的 x 属性和 y 属性必须传入整数时，可以这样做</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样无法通用，我们可以用type为该类型起一个别名，简化使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointType</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// point的类型为PointType</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">PointType</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointType</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">    z?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以传递或者不传递 z 属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">PointType</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a><strong>interface</strong></h3><p>interface的使用和type十分相似，都是用来定义类型，基本用法如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointType</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface可以扩展，这意味着可以声明同名的interface</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointType</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointType</span> &#123;</span><br><span class="line">  z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交叉类型-1"><a href="#交叉类型-1" class="headerlink" title="交叉类型"></a><strong>交叉类型</strong></h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><p>JS中对函数的参数个数，参数类型，返回类型均不做限制</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) : <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h3><p>开发中，经常需要定义一组相关的常量，比如方向Direction, 状态码Status, 因此ts中引入了枚举结构，将相关常量放在一起。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举结构的默认值从0开始，依次递增, 我们也可以为成员显式赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个颜色的枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="string">&quot;RED&quot;</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="string">&quot;GREEN&quot;</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="string">&quot;BLUE&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>泛型是ts的难点</p><p>泛型可以在编写函数、类或者接口的时候传递类型参数，这些类型参数在使用时才被具体指定，就相当于一个占位符，在使用时才会传入具体类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数使用了类型参数 T, 但是 T是什么并不确定</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们可以对函数进行调用，函数被调用时会被具体参数替代。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 被替换为 string 类型</span></span><br><span class="line"><span class="keyword">let</span> result = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 输出: Hello</span></span><br><span class="line"><span class="comment">// T 被替换为 number 类型</span></span><br><span class="line"><span class="keyword">let</span> numberResult = identity&lt;<span class="built_in">number</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(); <span class="comment">// 输出: 42</span></span><br></pre></td></tr></table></figure><p>泛型不仅可以用于函数，还可以用于类和接口, 其写法也是在类的名称后面加上<T></p><p>下面我们定义一个Box 类接受类型参数 T，并使用它来定义实例变量和方法的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">value</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getValue</span>(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line"><span class="keyword">let</span> stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringBox.<span class="title function_">getValue</span>()); <span class="comment">// 输出: hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numberBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">102</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberBox.<span class="title function_">getValue</span>()); <span class="comment">// 输出: 102</span></span><br></pre></td></tr></table></figure><p>泛型不仅可以用于函数，还可以用于接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口，表示具有一个值的容器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Container</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型接口</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">numberContainer</span>: <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">value</span>: <span class="number">99</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">stringContainer</span>: <span class="title class_">Container</span>&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">value</span>: <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberContainer.<span class="property">value</span>); <span class="comment">// 输出: 99</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringContainer.<span class="property">value</span>); <span class="comment">// 输出: Hello</span></span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a><strong>泛型约束</strong></h3><p>直接使用泛型太过自由，有的时候我们需要让泛型类型参数满足某些条件，比如下面代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">   <span class="comment">// 代码报错，类型 T 上不存在属性 length</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此ts提供了语法约束类型参数，如果不满足约束条件，编译时就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> hasLength &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接受一个类型参数 T，该参数必须符合 hasLength 接口</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T <span class="keyword">extends</span> hasLength&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用泛型约束，我们在函数内部可以安全地访问arg.length属性。</p><h3 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a><strong>类型声明文件</strong></h3><p><u>xx.d.ts</u>  , d 表示声明，类型声明。</p><p><u>tsconfig.json </u> 是TS项目的配置文件, 供tsc编译器使用，其内容是一个JSON对象，通过这个配置文件，你可以定义项目的编译选项、文件包含与排除规则、模块解析规则等。</p><p>关于配置的更多内容，可以在官网查看：<a href="https://www.typescriptlang.org/tsconfig">tsconfig说明</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想要系统学习ts ，可以查看阮一峰老师的教程 &lt;a href=&quot;https://wangdoc.com/typescript/intro&quot;&gt;TypeScript教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么需要TypeScript&quot;&gt;&lt;a href=&quot;#为什么需要TypeSc</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://daixueshengt.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a549.html"/>
    <id>https://daixueshengt.github.io/posts/c993a549.html</id>
    <published>2024-06-08T09:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="43-localStorage和sessionStorage的区别"><a href="#43-localStorage和sessionStorage的区别" class="headerlink" title="43.localStorage和sessionStorage的区别"></a>43.localStorage和sessionStorage的区别</h2><p>localStorage：永久存储在本地，适合保存在本地的数据</p><p>sessionStorage：会话级的存储，敏感账号一次性登录</p><p>相同点：</p><ul><li>都是保存在浏览器端</li><li>不会把数据自动的发送给服务器，仅在本地保存</li><li>只能存储字符串，可以将对象JSON.stringfy()编码之后进行存储</li></ul><p>不同点：</p><ul><li>存储大小限制不同：sessionStorage存储的大小为5M，localStorage存储大小为20M</li><li>数据有效期不同：localStorage始终有效，窗口关闭或浏览器关闭，一直保存，持久保存数据</li><li>作用域不同：sessionStorage在不同的浏览器窗口不会进行共享，只有同一个页面中共享。localStorage在所有同源的窗口下可以共享。</li></ul><h2 id="leetcode20-有效的括号"><a href="#leetcode20-有效的括号" class="headerlink" title="leetcode20. 有效的括号"></a>leetcode<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> start = s[i];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span> || s[i]==<span class="string">&#x27;[&#x27;</span> || s[i]==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> end = stack[stack.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(end==<span class="string">&#x27;(&#x27;</span> &amp;&amp; start ==<span class="string">&#x27;)&#x27;</span> ||end==<span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; start ==<span class="string">&#x27;&#125;&#x27;</span> || end==<span class="string">&#x27;[&#x27;</span> &amp;&amp; start ==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span>==<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode1047-删除字符串中的所有相邻重复项"><a href="#leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="leetcode1047. 删除字符串中的所有相邻重复项"></a>leetcode<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(v <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> prev =stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(prev!=v)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(prev);</span><br><span class="line">            stack.<span class="title function_">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode104771-简化路径"><a href="#leetcode104771-简化路径" class="headerlink" title="leetcode104771. 简化路径"></a>leetcode<a href="https://leetcode.cn/problems/simplify-path/">104771. 简化路径</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">path</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> simplifyPath = <span class="keyword">function</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack =[]</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = path.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val &amp;&amp; val==<span class="string">&#x27;..&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &amp;&amp; val!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    arr.<span class="property">length</span> ? str=<span class="string">&#x27;/&#x27;</span>+stack.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>):str=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;43-localStorage和sessionStorage的区别&quot;&gt;&lt;a href=&quot;#43-localStorage和sessionStorage的区别&quot; class=&quot;headerlink&quot; title=&quot;43.localStorage和sessionSto</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a548.html"/>
    <id>https://daixueshengt.github.io/posts/c993a548.html</id>
    <published>2024-06-07T09:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="38-宏任务和微任务"><a href="#38-宏任务和微任务" class="headerlink" title="38.宏任务和微任务"></a>38.宏任务和微任务</h2><p>js是单线程的 、 主线程</p><p>宏任务</p><p>​    分类：setTimeout、setInterval、requestAnimation</p><p>​    1、宏任务所处的队列就是宏任务队列</p><p>​    2、第一个宏任务队列中只有一个任务：执行主线程的js代码</p><p>​    3、宏任务队列可以有多个</p><p>​    4、当宏任务队列中的任务全部执行完以后会查看是否有微任务队列 如果有先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列</p><p>微任务</p><p>​    分类：new Promise().then(回调)    process.nextTick</p><p>​    微任务所处的队列就是微任务队列</p><p>​    只有一个微任务队列</p><p>​    在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务</p><p>默认一开始第一个宏任务队列中只有一个任务：执行主线程的js代码；执行完毕后检查是否有微任务，有则执行完 再执行宏任务队列。</p><p>代码案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---start---&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>();<span class="comment">//修改promise实例对象的状态为成功状态</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise实例成功回调执行&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---end---&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>—-start—-</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>—-end—-</p><p>promise实例成功回调执行</p><p>setTimeout</p><h2 id="39-比较React与Vue"><a href="#39-比较React与Vue" class="headerlink" title="39.比较React与Vue"></a>39.比较React与Vue</h2><p>1）相同点</p><ul><li>都有组件化开发和虚拟dom</li><li>都支持props进行父子组件间数据通信</li><li>都支持数据驱动视图，不直接操作真实dom，更新状态数据界面就自动更新</li><li>都支持服务器端渲染</li><li>都有支持native 的方案,React 的 React Native,Vue 的Weex</li></ul><p>2）不同点</p><ul><li>数据绑定vue 实现了数据的双向绑定,react 数据流动是单向的</li><li>组件写法不一样,React 推荐的做法是 JSX，也就是把 HTML和 CSS 全都写进 JavaScript了,即’all in js’; Vue 推荐的做法是webpack+vue-loader 的单文件组件格式,即 html,css,js 写在同一个文件</li><li>state 对象在 react 应用中不可变的,需要使用 setstate 方法更新状态;在 vue 中,state 对象不是必须的,数据由 data 属性在 vue 对象中管理</li></ul><h2 id="40-Redux管理状态的机制"><a href="#40-Redux管理状态的机制" class="headerlink" title="40.Redux管理状态的机制"></a>40.Redux管理状态的机制</h2><p>1) redux 是一个独立专门用于做状态管理的JS库，不是 react 插件库</p><p>2)它可以用在 react, angular, vue 等项目中,但基本与 react 配合使用</p><p>3)作用:集中式管理 react 应用中多个组件共享的状态和从后台获取的数据</p><h2 id="41-VUE组件间通信方式"><a href="#41-VUE组件间通信方式" class="headerlink" title="41.VUE组件间通信方式"></a>41.VUE组件间通信方式</h2><p>1）通信种类</p><p>1.父向子</p><p>2.子向父</p><p>3.隔代组件间通信</p><p>4.兄弟组件间通信</p><p>2）实现通信方式</p><p>1.props</p><ul><li>通过一般属性实现父向子通信</li><li>通过函数属性实现子向父通信</li><li>缺点：隔代组件和兄弟组件间通信比较麻烦</li></ul><p>2.vue自定义事件</p><ul><li>vue内置实现，可以代替函数类型的props<ul><li>绑定监听：&lt;MyComp @eventName=”callback”</li><li>触发事件：this.$emit(“eventName,data)</li></ul></li><li>缺点：只适合于子向父通信</li></ul><p>3.消息订阅与发布</p><ul><li>需要引入消息订阅与发布的实现库，如：pubsub-js<ul><li>订阅消息：PubSub.subscribe(‘msg’,(msg,data)=&gt;{})</li><li>发布消息：PubSub.publish(‘msg’,data)</li></ul></li><li>优点：此方式可用于任意关系组件间通信</li></ul><p>4.vuex</p><ul><li>是什么: vuex 是 vue 官方提供的集中式管理 vue 多组件共享状态数据的 vue 插件</li><li>优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便</li></ul><p>5.slot</p><ul><li>是什么：专门用来实现父向子传递带数据的标签</li><li>注意：通信的标签板块是在父组件中解析好后再传递给子组件的</li></ul><h2 id="42-说说vue的MVVM实现原理"><a href="#42-说说vue的MVVM实现原理" class="headerlink" title="42.说说vue的MVVM实现原理"></a>42.说说vue的MVVM实现原理</h2><p>Vue作为MVVM模式的实现库的2种技术</p><ul><li>模版解析</li><li>数据绑定</li></ul><p>模版解析：实现初始化显示</p><ul><li>解析大括号表达式</li><li>解析指令</li></ul><p>数据绑定：实现更新显示</p><ul><li>通过数据劫持实现</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;38-宏任务和微任务&quot;&gt;&lt;a href=&quot;#38-宏任务和微任务&quot; class=&quot;headerlink&quot; title=&quot;38.宏任务和微任务&quot;&gt;&lt;/a&gt;38.宏任务和微任务&lt;/h2&gt;&lt;p&gt;js是单线程的 、 主线程&lt;/p&gt;
&lt;p&gt;宏任务&lt;/p&gt;
&lt;p&gt;​    分</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a547.html"/>
    <id>https://daixueshengt.github.io/posts/c993a547.html</id>
    <published>2024-06-06T10:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-你是如何理解ES6中Promise的以及它的实例方法？"><a href="#31-你是如何理解ES6中Promise的以及它的实例方法？" class="headerlink" title="31.你是如何理解ES6中Promise的以及它的实例方法？"></a>31.你是如何理解ES6中Promise的以及它的实例方法？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是异步编程的一种解决方案</span></span><br><span class="line"><span class="comment">// 三种状态：pending（进行中），fulfilled（已成功），rejected（已失败）</span></span><br><span class="line"><span class="comment">// 特点：状态不受外界的影响，只有异步操作的结果，决定当前是哪一种状态，一旦状态改变就不会再变</span></span><br><span class="line"><span class="comment">// 用法：Promise是一个构造函数，用来生成Promise实例</span></span><br><span class="line"><span class="comment">// promise的构造函数接收一个函数作为参数，这个函数有两个参数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line"><span class="comment">// resolve函数：将promise对象的状态由pending变为fulfilled，在异步操作成功时调用</span></span><br><span class="line">    <span class="title function_">resolve</span>() <span class="comment">// 返回异步操作的结果，作为参数传递出去</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reject函数：将promise对象的状态由pending变为rejected，在异步操作失败时调用</span></span><br><span class="line">    <span class="title function_">reject</span>() <span class="comment">//返回异步操作的结果，作为参数传递出去</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 实例方法</span></span><br><span class="line"><span class="comment">// then():当实例状态发生改变的时候的回调函数,返回的是一个新的promise实例，也就是promise可以链式书写的原因</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        <span class="keyword">if</span>(time%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据，time=&#x27;</span>+time)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;失败的数据，time=&#x27;</span>+time)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">//resolved已成功的状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="comment">//rejected已失败的状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch():用于指定发生错误的回调函数，一般来说通过catch替代then的第二个参数</span></span><br><span class="line"><span class="comment">// finally():用来指定不管Promise对象状态最后如何，都会执行的操作</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">//resolved已成功的状态</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;最后的结果&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="32-ES6中Promise-all的理解以及应用场景？"><a href="#32-ES6中Promise-all的理解以及应用场景？" class="headerlink" title="32.ES6中Promise.all的理解以及应用场景？"></a>32.ES6中Promise.all的理解以及应用场景？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将多个Promise实例，包装成一个新的Promise实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;成功01&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;成功02&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;成功03&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 参数可以不是数组，但是必须是iterator接口</span></span><br><span class="line"><span class="keyword">let</span> pAll = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pAll)</span><br><span class="line"><span class="comment">//pAll的状态，由p1,p2,p3来决定，只有当这三个都为成功，pA11才会为成功，</span></span><br><span class="line"><span class="comment">//但是有一个失败，那么就是失败，这个时候第一个失败的实例的返回值，会传递给pAll的回调函数</span></span><br><span class="line"><span class="comment">//如果作为参数的实例，自己定义了catch方法，那么它一旦rejected，不会触pAll的catch方法</span></span><br><span class="line"><span class="comment">//多个请求结果合并在一起</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBannerList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="string">&#x27;轮播图的数据&#x27;</span>)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMusicList</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;歌曲列表的数据&#x27;</span>)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getcateList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;歌单分类的数据&#x27;</span>)</span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">All</span>=<span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getBannerList</span>(),<span class="title function_">getMusicList</span>(),<span class="title function_">getcateList</span>()])</span><br><span class="line"><span class="title class_">All</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">initLoad</span>()</span><br></pre></td></tr></table></figure><h2 id="33-你能说说ES6中Promise-race的用法和使用场景吗？"><a href="#33-你能说说ES6中Promise-race的用法和使用场景吗？" class="headerlink" title="33.你能说说ES6中Promise.race的用法和使用场景吗？"></a>33.你能说说ES6中Promise.race的用法和使用场景吗？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prace = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1,p2])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prace)</span><br><span class="line"><span class="comment">//Promise.race区别于promise.all只要实例中有一个先改变状态，就会把这个实例的参数的返回值传给prace的回调函数</span></span><br><span class="line"><span class="comment">// 使用场景：请求超时提示</span></span><br></pre></td></tr></table></figure><h2 id="34-函数节流和防抖"><a href="#34-函数节流和防抖" class="headerlink" title="34.函数节流和防抖"></a>34.函数节流和防抖</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">节流函数</span><br><span class="line"><span class="comment">// fn要被节流的函数，delay规定的时间</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line"><span class="comment">// 记录上一次函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//记录当前函数触发的时间</span></span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span>(nowTime-lastTime &gt; delay)&#123;</span><br><span class="line">            fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">            <span class="comment">// 同步时间</span></span><br><span class="line">            lastTime =nowTime; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onscroll</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll事件被触发了&#x27;</span>+ <span class="title class_">Date</span>.<span class="title function_">now</span>());&#125;，<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">节流函数：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line">    <span class="comment">//记录上一次的延时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 清除上一次的延时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">// 重新设置新的延时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件被触发了&#x27;</span>+ <span class="title class_">Date</span>.<span class="title function_">now</span>());&#125;, <span class="number">1000</span>);</span><br><span class="line">多次点击按钮，只让最后一次点击后才触发</span><br></pre></td></tr></table></figure><h2 id="35-什么是跨域-解决跨域的办法有哪些"><a href="#35-什么是跨域-解决跨域的办法有哪些" class="headerlink" title="35.什么是跨域?解决跨域的办法有哪些?"></a>35.什么是跨域?解决跨域的办法有哪些?</h2><ol><li>同源策略</li></ol><ul><li>是浏览器安全策略</li><li>协议名、域名、端口号必须完全一致</li></ul><ol><li>跨域</li></ol><ul><li>违背同源策略就会产生跨域</li></ul><ol><li>解决跨域</li></ol><ul><li>jsonp cors 服务器代理。。。</li></ul><p>jsonp解决方案  前端实现方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建script标签</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">//数据请求回来会被触发的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置script的src属性，设置请求地址</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000?callback=getData&#x27;</span>;</span><br><span class="line"><span class="comment">// 让script生效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><h2 id="36-从一个url地址到最终页面渲染完成，发生了什么？"><a href="#36-从一个url地址到最终页面渲染完成，发生了什么？" class="headerlink" title="36.从一个url地址到最终页面渲染完成，发生了什么？"></a>36.从一个url地址到最终页面渲染完成，发生了什么？</h2><ol><li><p>DNS解析：将域名地址解析为ip地址</p><ul><li>浏览器DNS缓存</li><li>系统DNS缓存</li><li>路由器DNS缓存</li><li>网络运营商DNS缓存</li><li>递归搜索：blog.baidu.com<ul><li>.com域名下查找DNS解析</li><li>.baidu域名下查找DNS解析</li><li>blog域名下查找DNS解析</li><li>出错了</li></ul></li></ul></li><li><p>TCP连接：三次握手</p><ul><li>第一次握手，浏览器发起，告诉服务器我要发送请求了</li><li>第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧</li><li>第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧</li></ul></li><li><p>发送请求</p><ul><li>请求报文：http协议的通信内容</li></ul></li><li><p>接受响应</p><ul><li>响应报文</li></ul></li><li><p>渲染页面</p><ul><li>遇见html标记，浏览器调用html解析器解析成token并构建成dom树</li><li>遇到style/link标记，浏览器调用css解析器，处理css标记并构建cssom树</li><li>遇到script标记，调用JavaScript解析器，处理script代码（绑定事件，修改dom树、cssom树）</li><li>将dom树和cssom树合并成一个渲染树</li><li>根据渲染树来计算布局，计算每个节点的几何信息（布局）</li><li>将各个节点颜色绘制到屏幕上（渲染）</li></ul><p>注意：</p><p>这五个步骤不一定按照顺序执行，如果dom树或cssom树被修改了，可能会执行多次布局和渲染。往往实际页面中，这些步骤都会执行多次的。</p></li><li><p>断开连接：TCP四次挥手</p></li></ol><ul><li>第一次挥手：由浏览器发起的，发送给服务器，我东西发送完了（请求报文），你准备关闭吧</li><li>第二次挥手：由服务器发起的，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备吧</li><li>第三次挥手：由服务器发起的，告诉浏览器，我东西发送完了（响应报文），你准备关闭吧</li><li>第四次挥手：由浏览器发起，告诉服务器，我东西接受完了（响应报文），我准备关闭了，你也准备吧</li></ul><h2 id="37-闭包"><a href="#37-闭包" class="headerlink" title="37.闭包"></a>37.闭包</h2><p>什么是闭包？</p><ol><li>密闭的容器，类似于set，map容器，存储数据的</li><li>闭包是一个对象，存放数据的格式：key：value</li></ol><p>形成条件</p><ol><li>函数嵌套</li><li>内部函数引用外部函数的局部变量</li></ol><p>闭包的优点：延长外部函数局部变量的生命周期</p><p>闭包的缺点：容易造成内存泄漏</p><p>注意点：</p><ol><li>合理使用闭包</li><li>用完闭包要及时清除（销毁）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun2</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的应用场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="title function_">fun</span>();</span><br><span class="line"><span class="title function_">fun2</span>() <span class="comment">//2</span></span><br><span class="line"><span class="title function_">fun2</span>() <span class="comment">//3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;31-你是如何理解ES6中Promise的以及它的实例方法？&quot;&gt;&lt;a href=&quot;#31-你是如何理解ES6中Promise的以及它的实例方法？&quot; class=&quot;headerlink&quot; title=&quot;31.你是如何理解ES6中Promise的以及它的实例方法？&quot;&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a546.html"/>
    <id>https://daixueshengt.github.io/posts/c993a546.html</id>
    <published>2024-06-05T23:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="28-如何在JS中对原型进行修改和重写？"><a href="#28-如何在JS中对原型进行修改和重写？" class="headerlink" title="28.如何在JS中对原型进行修改和重写？"></a>28.如何在JS中对原型进行修改和重写？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>===<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>===p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>=&#123;</span><br><span class="line">    <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接给Person的原型对象用对象进行赋值时，p的构造函数指向根构造函数object</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);<span class="comment">//p(this).__proto__=Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>===<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>===p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//false</span></span><br><span class="line">p.<span class="property">constructor</span>=<span class="title class_">Person</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>===p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="29-JS中如何判断一个属性是属于实例对象还是继承于构造函数？"><a href="#29-JS中如何判断一个属性是属于实例对象还是继承于构造函数？" class="headerlink" title="29.JS中如何判断一个属性是属于实例对象还是继承于构造函数？"></a>29.JS中如何判断一个属性是属于实例对象还是继承于构造函数？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过hasownProperty()//检测一个属性是否属于自身对象，还是继承于原型链上的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p.<span class="property">phone</span> = <span class="number">12345</span>;</span><br><span class="line">p.<span class="property">height</span>=<span class="number">182</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;phone&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;sex&quot;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="title function_">hasOwnProperty</span>(i))&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-JS中bind和call、apply有什么作用？它们的区别是什么？"><a href="#30-JS中bind和call、apply有什么作用？它们的区别是什么？" class="headerlink" title="30.JS中bind和call、apply有什么作用？它们的区别是什么？"></a>30.JS中bind和call、apply有什么作用？它们的区别是什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：改变函数运行时的this指向</span></span><br><span class="line"><span class="keyword">var</span> uname=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    uname=<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">say</span>() <span class="comment">//李四</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>,<span class="number">0</span>)<span class="comment">//张三</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>.<span class="title function_">bind</span>(obj),<span class="number">0</span>)<span class="comment">//李四</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//apply:两个参数，第一个是this指向，第二个是函数接收的参数，以数组的形式传入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...argus</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...argus);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    myname=<span class="string">&quot;王五&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">fun.<span class="title function_">apply</span>(person,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);<span class="comment">//传入的参数必须是一个数组</span></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 如果第一个参数是null或者是undefined，this默认指向window</span></span><br><span class="line">fun.<span class="title function_">apply</span>(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">fun.<span class="title function_">apply</span>(<span class="literal">undefined</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//call:两个参数，第一个是this指向，第二个是参数列表</span></span><br><span class="line"><span class="comment">// call 和 apply改变this指向原函数立即执行，临时改变this指向一次</span></span><br><span class="line">fun.<span class="title function_">call</span>(person,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// bind:两个参数，第一个是this指向，第二个是参数列表</span></span><br><span class="line"><span class="comment">// 改变this指向不会立即执行，返回一个永久改变this指向的函数</span></span><br><span class="line"><span class="keyword">var</span> bindFun = fun.<span class="title function_">bind</span>(person)</span><br><span class="line"><span class="title function_">bindFun</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;28-如何在JS中对原型进行修改和重写？&quot;&gt;&lt;a href=&quot;#28-如何在JS中对原型进行修改和重写？&quot; class=&quot;headerlink&quot; title=&quot;28.如何在JS中对原型进行修改和重写？&quot;&gt;&lt;/a&gt;28.如何在JS中对原型进行修改和重写？&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a545.html"/>
    <id>https://daixueshengt.github.io/posts/c993a545.html</id>
    <published>2024-06-03T09:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-JS中数组的遍历方法有哪些"><a href="#26-JS中数组的遍历方法有哪些" class="headerlink" title="26.JS中数组的遍历方法有哪些"></a>26.JS中数组的遍历方法有哪些</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">// forEach:不会改变原数组，没有返回值</span></span><br><span class="line"><span class="comment">// 三个参数 遍历值，索引值，数组本身</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:不会改变原数组，有返回值（以数组的形式返回）</span></span><br><span class="line"><span class="keyword">let</span> resultMap = arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);c</span><br><span class="line">    <span class="keyword">return</span> index*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter: 过滤数组,也可直接遍历</span></span><br><span class="line"><span class="comment">// 有返回值 返回包含符合条件元素的数组</span></span><br><span class="line"><span class="keyword">let</span> resultFilter = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line"><span class="keyword">return</span> item&gt;<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of:返回是数组的元素，对象的属性值。不能遍历普通的对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce :接受一个函数，作为一个累加器</span></span><br><span class="line"><span class="comment">// 前两个参数, 第一个计算之后返回的值或者初始值，第二个当前元素</span></span><br><span class="line"><span class="keyword">let</span> resultReduce = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre,item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre+item</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultReduce);</span><br></pre></td></tr></table></figure><h2 id="27-如何理解JS中原型？"><a href="#27-如何理解JS中原型？" class="headerlink" title="27.如何理解JS中原型？"></a>27.如何理解JS中原型？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prototype属性，默认对应着一个空对象（没有我们指定的方法和属性），这个空对象就是我们所说的原型对象，每一个prototype属性都是不相等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// 显式原型和隐式原型</span></span><br><span class="line"><span class="comment">// 每一个函数都有一个prototype属性，就是显式原型</span></span><br><span class="line"><span class="comment">// 每一个实例对象都有一个__proto__,就是隐式原型</span></span><br><span class="line"><span class="comment">// 实例对象的隐式原型等于对应的构造函数的显示原型的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>)&#123; <span class="comment">// 内部语句：Fun(this).prototype=&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="keyword">var</span> fun=<span class="keyword">new</span> <span class="title class_">Fun</span>() <span class="comment">// 内部语句：fun(this).__proto__=Fun.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>===fun.<span class="property">__proto__</span>)</span><br><span class="line"><span class="comment">// 总结：</span></span><br><span class="line"><span class="comment">// 函数的prototype属性，在定义函数是自动添加的，默认值是一个空对象</span></span><br><span class="line"><span class="comment">// 对象的__proto__属性，创建对象时自动添加的，默认值是构造函数的prototype属性。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;26-JS中数组的遍历方法有哪些&quot;&gt;&lt;a href=&quot;#26-JS中数组的遍历方法有哪些&quot; class=&quot;headerlink&quot; title=&quot;26.JS中数组的遍历方法有哪些&quot;&gt;&lt;/a&gt;26.JS中数组的遍历方法有哪些&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>day2(5-30)</title>
    <link href="https://daixueshengt.github.io/posts/97c25550.html"/>
    <id>https://daixueshengt.github.io/posts/97c25550.html</id>
    <published>2024-05-30T14:20:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">第一章  数组part02</span><br><span class="line"> </span><br><span class="line">977.有序数组的平方 ，209.长度最小的子数组 ，59.螺旋矩阵II ，总结 </span><br><span class="line"></span><br><span class="line">建议大家先独立做题，然后看视频讲解，然后看文章讲解，然后在重新做一遍题，把题目AC，最后整理成今日当天的博客</span><br><span class="line"></span><br><span class="line">拓展题目可以先不做</span><br><span class="line"></span><br><span class="line"> 详细布置</span><br><span class="line"></span><br><span class="line"> 977.有序数组的平方 </span><br><span class="line"></span><br><span class="line">题目建议： 本题关键在于理解双指针思想 </span><br><span class="line"></span><br><span class="line">题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/</span><br><span class="line">文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</span><br><span class="line">视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep </span><br><span class="line"></span><br><span class="line"> 209.长度最小的子数组</span><br><span class="line"></span><br><span class="line">题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。 </span><br><span class="line"></span><br><span class="line">题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/</span><br><span class="line">文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</span><br><span class="line">视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 59.螺旋矩阵II</span><br><span class="line"></span><br><span class="line">题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 </span><br><span class="line"></span><br><span class="line">题目链接：https://leetcode.cn/problems/spiral-matrix-ii/</span><br><span class="line">文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html</span><br><span class="line">视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/</span><br><span class="line"></span><br><span class="line"> 总结 </span><br><span class="line"></span><br><span class="line">题目建议：希望大家 也做一个自己 对数组专题的总结</span><br><span class="line"></span><br><span class="line">文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><p>js 写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>ts写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="暴力写法"><a href="#暴力写法" class="headerlink" title="暴力写法"></a>暴力写法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h5 id="双指针写法"><a href="#双指针写法" class="headerlink" title="双指针写法"></a>双指针写法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>js写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>ts写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>day1(5-29)</title>
    <link href="https://daixueshengt.github.io/posts/762a9ea0.html"/>
    <id>https://daixueshengt.github.io/posts/762a9ea0.html</id>
    <published>2024-05-29T10:50:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">第一章  数组part01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 今日任务 </span><br><span class="line"></span><br><span class="line">数组理论基础，704. 二分查找，27. 移除元素  </span><br><span class="line"></span><br><span class="line"> 详细布置</span><br><span class="line"></span><br><span class="line"> 数组理论基础  </span><br><span class="line"></span><br><span class="line">文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</span><br><span class="line"></span><br><span class="line">题目建议： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。</span><br><span class="line"></span><br><span class="line"> 704. 二分查找 </span><br><span class="line"></span><br><span class="line">题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。</span><br><span class="line"></span><br><span class="line">先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。</span><br><span class="line"></span><br><span class="line">题目链接：https://leetcode.cn/problems/binary-search/</span><br><span class="line">文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</span><br><span class="line">视频讲解：https://www.bilibili.com/video/BV1fA4y1o715</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> 27. 移除元素</span><br><span class="line"></span><br><span class="line">题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。 </span><br><span class="line"></span><br><span class="line">题目链接：https://leetcode.cn/problems/remove-element/ </span><br><span class="line">文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</span><br><span class="line">视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><h5 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h5><p> target 是在一个在左闭右闭的区间里，[left, right]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><h5 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h5><p> target 是在一个在左闭右开的区间里，[left, right），那么二分法的边界处理方式则截然不同。</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><p>js 写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid,left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ts写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">mid</span>: <span class="built_in">number</span>, <span class="attr">left</span>: <span class="built_in">number</span> = <span class="number">0</span>, <span class="attr">right</span>: <span class="built_in">number</span> = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + ((right - left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br></pre></td></tr></table></figure><h5 id="暴力写法"><a href="#暴力写法" class="headerlink" title="暴力写法"></a>暴力写法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    nums[j<span class="number">-1</span>]=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h5 id="双指针写法"><a href="#双指针写法" class="headerlink" title="双指针写法"></a>双指针写法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>js写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="property">length</span>; fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ts写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeElement</span>(<span class="params">nums: <span class="built_in">number</span>[], val: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">slow</span>:<span class="built_in">number</span> = <span class="number">0</span>,<span class="attr">fast</span>: <span class="built_in">number</span> =<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (fast &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== val) &#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>职场小白军规</title>
    <link href="https://daixueshengt.github.io/posts/9bdce6af.html"/>
    <id>https://daixueshengt.github.io/posts/9bdce6af.html</id>
    <published>2024-05-28T21:24:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<p>当学生的时候，老师有义务回答你的问题</p><p>但是在职场，没人有这个义务，凡事先求已后求人</p><p><img src="https://img2.imgtp.com/2024/05/28/skWfPQgT.jpg" alt=""></p><h3 id="心态调整"><a href="#心态调整" class="headerlink" title="心态调整"></a>心态调整</h3><ul><li>做、学、问，三件事，做：学：问=2:2:1</li><li>比起学习的你，其他人更希望看到在做事的你</li><li>少问<code>是什么</code>，<code>为什么</code>，<code>怎么做</code></li><li>要闻就问 <code>我这样做对不对？</code>，<code>我打算这么做可以么？</code>，<code>我这么做哪里不合适？</code></li><li>有问题优先找师傅，如果没有固定师傅，就去问问招你进来的领导，让他帮你指定一个师傅</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>电脑必装笔记软件，与手机云同步</li><li>常备便签纸，再买个好本子，配两只好笔，推荐Pentel+荧光笔</li><li>低调，别太显眼，不要把自己整滴过于帅或者漂亮，除非你的工作本身就跟颜值有关</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>别人交代的任务，尽可能的要当场复述重点并确认，目标及时间节点要卡准</p><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>两个目标：实现、学习。</p><p>大爷心态：实习（工作）是双向的，公司要人干活又缺钱，别PUA自己，别让自己被PUA</p><p>初期框架意识：对业务全程掌握感的重要性</p><p>中期差不多意识：合理分配自己的时间精力，批量化分配70分的东西；并且多沟通，向上管理</p><p>后期观察判断意识：不要all in 转正。你首先是自己的产品经理，要借助平台撬动更大的资源，做好自己这款产品。</p><p><code>世界上成功的产品经理只有一种，那就是用自己的方式度过这一生。</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>正常不需要新人站队，如果要站，你师傅站哪你站哪</p><p>有些事坚持做就好了，不用想太多。没有必要短期上太高的强度，没有必要。习惯细水长流</p><p>没有必要过度安排和计划，以致过渡的压力与焦虑，走一步看一步，如今计划赶不上变化。船到桥头自然直</p><p>谁不向往更好的生活，眼界打开，自身的基础素质够高，才能走的更远。</p><p>不忘探索生活与热爱，活着的本质就是现在。</p><p>或许有时要向钱低头，但也要找到难得的兴趣所在，把自己的时间付给有价值的事情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当学生的时候，老师有义务回答你的问题&lt;/p&gt;
&lt;p&gt;但是在职场，没人有这个义务，凡事先求已后求人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2.imgtp.com/2024/05/28/skWfPQgT.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;心态调</summary>
      
    
    
    
    <category term="非技术杂记" scheme="https://daixueshengt.github.io/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://daixueshengt.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题</title>
    <link href="https://daixueshengt.github.io/posts/c993a544.html"/>
    <id>https://daixueshengt.github.io/posts/c993a544.html</id>
    <published>2024-05-27T10:36:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p><img src="https://img2.imgtp.com/2024/05/27/iU4gPmmD.png" alt="冒泡排序原理图"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序的排序  冒泡</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 轮数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;arr.<span class="property">length</span>-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">            arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><h2 id="2-反转数组"><a href="#2-反转数组" class="headerlink" title="2.反转数组"></a>2.反转数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i]=arr[arr.<span class="property">length</span>-<span class="number">1</span>-i];</span><br><span class="line">    arr[arr.<span class="property">length</span>-<span class="number">1</span>-i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><h2 id="3-去掉数组中重复性的数据"><a href="#3-去掉数组中重复性的数据" class="headerlink" title="3.去掉数组中重复性的数据"></a>3.去掉数组中重复性的数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line"><span class="keyword">let</span> t=[];</span><br><span class="line">t[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;t.<span class="property">length</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[k]==arr[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==t.<span class="property">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">            t.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t);</span><br></pre></td></tr></table></figure><h2 id="4-用css创建一个三角形"><a href="#4-用css创建一个三角形" class="headerlink" title="4.用css创建一个三角形"></a>4.用css创建一个三角形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用css创建一个三角形 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#box&#123;</span><br><span class="line">width: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">border: 100px solid;</span><br><span class="line"></span><br><span class="line">border-top-color: red;</span><br><span class="line">border-right-color: transparent;</span><br><span class="line">border-bottom-color: transparent;</span><br><span class="line">border-left-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="5-rem适配"><a href="#5-rem适配" class="headerlink" title="5.rem适配"></a>5.rem适配</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 实现移动端 rem适配 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    *&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#box</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">0.5rem</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>:<span class="number">0.5rem</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* html根元素字体大小设置屏幕区域的宽 */</span></span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取屏幕区域的宽度</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> width= <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取html</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> htmlNode=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;html&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 设置字体大小</span></span></span><br><span class="line"><span class="language-javascript">    htmlNode.<span class="property">style</span>.<span class="property">fontSize</span>=width+<span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序&quot;&gt;&lt;/a&gt;1.冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img2.imgtp.com/2024/05/27/iU4gPmmD.p</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>前端项目打包上线</title>
    <link href="https://daixueshengt.github.io/posts/987bf438.html"/>
    <id>https://daixueshengt.github.io/posts/987bf438.html</id>
    <published>2024-05-24T16:54:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端项目上线"><a href="#前端项目上线" class="headerlink" title="前端项目上线"></a>前端项目上线</h2><h3 id="1-项目打包"><a href="#1-项目打包" class="headerlink" title="1.项目打包"></a>1.项目打包</h3><ul><li>我们开发用的脚手架其实就是一个微型服务器，用于:支撑开发环境、运行代理服务器等。</li><li>打包完的文件中不存在: <code>.vue</code>、<code>.jsx</code>、<code>.less</code> 等文件，而是:html、css、js 等。</li><li>打包后的文件，不再借助脚手架运行，而是需要部署到服务器上运行。</li><li>打包前，请务必梳理好前端项目的 <code>ajax</code>封装(请求前缀、代理规则等)</li></ul><h2 id="2-本地服务器部署"><a href="#2-本地服务器部署" class="headerlink" title="2.本地服务器部署"></a>2.本地服务器部署</h2><h2 id="3-nginx-服务器部署"><a href="#3-nginx-服务器部署" class="headerlink" title="3.nginx 服务器部署"></a>3.nginx 服务器部署</h2><h3 id="3-1-nginx-简介"><a href="#3-1-nginx-简介" class="headerlink" title="3.1.nginx 简介"></a>3.1.nginx 简介</h3><p>Nginx(发音为“engine-x”)是一款高性能的 HTTP 服务器和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。Nginx最初由 lgor Sysoev 编写，于 2004年发布。它以其高性能、高稳定性、丰富的功能集和低系统资源消耗而闻名，主要功能有:<br>1.反向代理<br>2.负载均衡<br>3.静态内容服务<br>4.HTTP/2 支持<br>5.SSL/TLS 支持<br>6.高速缓存</p><p><img src="https://img2.imgtp.com/2024/05/24/ameDRWn8.png" alt="1655883039"></p><h2 id="4-云服务器部署"><a href="#4-云服务器部署" class="headerlink" title="4.云服务器部署"></a>4.云服务器部署</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端项目上线&quot;&gt;&lt;a href=&quot;#前端项目上线&quot; class=&quot;headerlink&quot; title=&quot;前端项目上线&quot;&gt;&lt;/a&gt;前端项目上线&lt;/h2&gt;&lt;h3 id=&quot;1-项目打包&quot;&gt;&lt;a href=&quot;#1-项目打包&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://daixueshengt.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>产品入门记录</title>
    <link href="https://daixueshengt.github.io/posts/f1288e52.html"/>
    <id>https://daixueshengt.github.io/posts/f1288e52.html</id>
    <published>2024-05-24T11:24:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<p>产品岗最终要的是实习经历 做产品的经历</p><p>star法则     描述项目经历 实习经历</p><p>Situation（情景）、Task（任务）、Action（行动）和Result（结果）</p><p>1、STAR法则，说清背景，结果要尽可能量化</p><p>2、提取产品关键词在前，方便HR阅览</p><p>3、自己尝试去将过往经历进行优化，去写对应的文档、去输出对应的框架图</p><p>工作职责</p><p>需求挖掘</p><p>产品设计</p><p>产品优化</p><p>上线效果</p><p>其中简历的个人技能与评价部分</p><p>个人技能</p><ul><li>计算机技能:Axure、Visio、Xmind、figma、墨刀、办公软件三件套、数据分析软件SQL等</li><li>语言技能:英语四六级、托福雅思等</li></ul><p>获奖情况</p><ul><li>奖项不要写太多了，该模块没有都可以…</li></ul><p>自我评价</p><ul><li>自我评价不要用大量形容词堆砌，多用动词，数量词，如坚持每月阅读5本互联网相关数据，并做读书笔记;慎用形容词，比如严谨认真，刻苦努力等</li></ul><p>产品最重要的是面试</p><p>产品最常见的灵魂三问<br>1、产品经理是什么，团队中什么样的角色?<br>2、产品经理应该具备什么特质，什么是产品思维?<br>3、产品经理日常的工作是什么，具体是？</p><p>群面</p><p>一、产品运营策划题</p><ol><li>明确目标用户</li><li>用户需求及痛点</li><li>产品解决方案</li></ol><p>AARRR海盗模型</p><p>提高触达用户数</p><p>提高用户活跃度</p><p>提高用户粘性</p><p>提高用户付费数</p><p>二、排序策略题</p><ol><li>考察逻辑思维</li><li>列出评分体系</li><li>列出打分框架</li></ol><p>什么是一个好的产品</p><ol><li>解决用户的需求 </li><li>有一定的用户粘性 </li><li>有完整的产品体验</li></ol><p>群面的心态：要认识到群面的本质是推动方案的形成，要合作而不是零和博弈。同时，要自信一点。</p><p>自我介绍：尽量说一些和题目、团队有关的经历、专业知识，少谈题外话。</p><p>自由讨论：一开始的时候要站出来说要3分钟的时间来看题目，3分钟之后给后面的时间划分出一个框架出来。</p><p>观点如何出来？</p><p>横向拆解：需求、用户、场景</p><p>纵向拆解：前中后，比如设计一种购物app，分析购物前、购物中、购物后</p><p>如果没有观点的时候，使用复读机战略。不断去重复别人的观点（询问式）</p><p>要注意不要将自己的角色框死了，随机应变。</p><p>要有打断别人的勇气。如果讨论没有结论，就会团灭，所以当一个人发言很垃圾的时候，一定要去打断、拉回来。</p><p>初次群面体验</p><p><img src="https://img2.imgtp.com/2024/05/24/4bBqlpdl.png" alt="群面题"></p><p>讨论得出：2,3,8,9,10.</p><p>群面总结：</p><p>Leader</p><p>Timer</p><p>小组成员</p><p>Recorder</p><p>reporter</p><p>洞察力 </p><p>优先级的能力 挑资源</p><p>合作能力</p><p>抗压能力</p><p>决策能力</p><p>创新思维</p><p>成本控制</p><p>能否被人记住</p><p>近期读《幕后产品》脑图</p><p><img src="https://img2.imgtp.com/2024/05/24/n79jCxeI.png" alt="幕后产品"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;产品岗最终要的是实习经历 做产品的经历&lt;/p&gt;
&lt;p&gt;star法则     描述项目经历 实习经历&lt;/p&gt;
&lt;p&gt;Situation（情景）、Task（任务）、Action（行动）和Result（结果）&lt;/p&gt;
&lt;p&gt;1、STAR法则，说清背景，结果要尽可能量化&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="非技术杂记" scheme="https://daixueshengt.github.io/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://daixueshengt.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://daixueshengt.github.io/posts/100fa4c9.html"/>
    <id>https://daixueshengt.github.io/posts/100fa4c9.html</id>
    <published>2024-05-23T17:54:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<ul><li>防抖(Debounce)是指对于短时间内重复发生的输入事件,只处理最后一次输入。它的目的是消除输入抖动。</li></ul><ul><li>节流(Throttle)是指对于短时间内频繁发生的输入事件,只处理一定时间内的第一次输入。它的目的是限制输入频率。</li></ul><p>使用场景不同：</p><ul><li>防抖通常用于处理诸如按钮点击、滚动条滚动等偶尔发生的输入事件,以避免重复触发。</li><li>节流通常用于处理诸如鼠标移动、窗口大小调整等频繁发生的输入事件,以限制更新频率,提高性能。</li></ul><p>实现方式不同：</p><ul><li>防抖一般通过设置一个延迟时间,只在指定时间内没有新的输入事件发生时才触发。</li><li>节流一般通过设置一个固定的时间间隔,每隔一定时间触发一次输入事件的处理。</li></ul><p>效果不同：</p><ul><li>防抖可以确保在输入稳定后才触发一次事件处理。</li><li>节流可以确保在指定时间内至多触发一次事件处理。</li></ul><p>防抖函数举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="title function_">debence</span>(handle));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hhh&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debence</span>(<span class="params">handle</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果第二次的时间没到1s，就销毁上一个定时器</span></span><br><span class="line">        <span class="comment">// 第二次点击时，会找到上一次闭包中的timer，并且销毁</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            handle.<span class="title function_">call</span>(<span class="variable language_">this</span>,e);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流函数举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">throttle</span>(handle));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hhh&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    获取当前时间戳 now。</span></span><br><span class="line"><span class="comment">    计算当前时间与上次执行时间 lastTime 的差值。</span></span><br><span class="line"><span class="comment">    如果差值大于等于 1000ms (1 秒), 则执行 handle 函数,并更新 lastTime 为当前时间。</span></span><br><span class="line"><span class="comment">    如果差值小于 1000ms, 则不执行 handle 函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="comment">// 如果当前时间 - 上次执行时间 &gt;= 1000ms，则执行 handle 函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      handle.<span class="title function_">call</span>(<span class="variable language_">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样,当我们在 1 秒内多次点击按钮时,throttle 函数只会在第一次点击时执行 handle 函数,后续的点击事件会被忽略,直到 1 秒后再次执行。</span></span><br></pre></td></tr></table></figure><p>可以使用lodash中的Debounce、Throttle 函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;防抖(Debounce)是指对于短时间内重复发生的输入事件,只处理最后一次输入。它的目的是消除输入抖动。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;节流(Throttle)是指对于短时间内频繁发生的输入事件,只处理一定时间内的第一次输入。它的目的是限制输入频率。&lt;</summary>
      
    
    
    
    <category term="技术杂记" scheme="https://daixueshengt.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://daixueshengt.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>5-15简单题开始找手感</title>
    <link href="https://daixueshengt.github.io/posts/43cc8af.html"/>
    <id>https://daixueshengt.github.io/posts/43cc8af.html</id>
    <published>2024-05-15T18:30:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-牛群排列去重"><a href="#1-牛群排列去重" class="headerlink" title="1.  牛群排列去重"></a>1.  牛群排列去重</h2><p>[<a href="https://www.nowcoder.com/practice/8cabda340ac6461984ef9a1ad66915e4">https://www.nowcoder.com/practice/8cabda340ac6461984ef9a1ad66915e4</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        ListNode* cur=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val==cur-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next=cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-调整牛群顺序"><a href="#2-调整牛群顺序" class="headerlink" title="2.调整牛群顺序"></a>2.调整牛群顺序</h2><p>[<a href="https://www.nowcoder.com/practice/a1f432134c31416b8b2957e66961b7d4">https://www.nowcoder.com/practice/a1f432134c31416b8b2957e66961b7d4</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">moveNthToEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 统一操作，设置一个虚拟头节点</span></span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* tail=dummy;</span><br><span class="line">  <span class="comment">// 先有一个指针走到最后一个节点，并计算个数</span></span><br><span class="line">        <span class="keyword">while</span>(tail-&gt;next)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p=dummy;</span><br><span class="line">  <span class="comment">//另一个指正走到倒数n个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count-n;i++)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp=p-&gt;next;</span><br><span class="line">        p-&gt;next=tmp-&gt;next;</span><br><span class="line">        tail-&gt;next=tmp;</span><br><span class="line">        tmp-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-合并两群能量值"><a href="#3-合并两群能量值" class="headerlink" title="3.合并两群能量值"></a>3.合并两群能量值</h2><p>[<a href="https://www.nowcoder.com/practice/d728938f66ac44b5923d4f2e185667ec">https://www.nowcoder.com/practice/d728938f66ac44b5923d4f2e185667ec</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param l1 ListNode类 </span></span><br><span class="line"><span class="comment">     * @param l2 ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeEnergyValues</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点</span></span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归并排序思想</span></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;=l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接剩余节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next=l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next=l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-牛牛队列成环"><a href="#4-牛牛队列成环" class="headerlink" title="4.牛牛队列成环"></a>4.牛牛队列成环</h2><p>[<a href="https://www.nowcoder.com/practice/38467f349b3a4db595f58d43fe64fcc7">https://www.nowcoder.com/practice/38467f349b3a4db595f58d43fe64fcc7</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow-&gt;val!=fast-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span> || fast-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关键是这，快慢指针，快指针每次走两步，慢指针每次走一步，如果存在环，一定会相遇。</span></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-牛群编号的回文顺序"><a href="#5-牛群编号的回文顺序" class="headerlink" title="5.牛群编号的回文顺序"></a>5.牛群编号的回文顺序</h2><p>[<a href="https://www.nowcoder.com/practice/e41428c80d48458fac60a35de44ec528">https://www.nowcoder.com/practice/e41428c80d48458fac60a35de44ec528</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以将链表中的数据保存到一个vector数组中，然后判断这个数组是否回文。</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;<span class="function">s</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>,j=v.size()<span class="number">-1</span>;i&lt;j;i++,j--)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]!=v[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-牛群的秘密通信"><a href="#6-牛群的秘密通信" class="headerlink" title="6.牛群的秘密通信"></a>6.牛群的秘密通信</h2><ol><li>创建一个栈用于存储左括号。栈的作用是用于判断括号的闭合性，它遵循先进后出的原则。每当遇到左括号时，就将其压入栈中，当遇到右括号时，就需要判断当前栈顶的左括号是否与之匹配。</li><li>遍历字符串s的每个字符。在遍历过程中，对于每个字符，我们需要判断它是否是左括号或右括号，并进行相应的操作。</li><li>如果当前字符是左括号（‘(’, ‘{’, ‘[’），将其压入栈中。</li><li>如果当前字符是右括号（‘)’, ‘}’,‘]’），我们需要判断栈是否为空。如果栈为空，说明没有相应的左括号与之匹配，直接返回false。如果栈不为空，将栈顶的左括号弹出，判断当前右括号是否与弹出的左括号匹配。如果不匹配，返回false。</li><li>遍历结束后，判断栈是否为空。如果栈不为空，说明左括号没有完全闭合，返回false；如果栈为空，说明所有左括号都有相应的右括号匹配，返回true。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param s string字符串</span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_valid_cow_communication</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span> || c==<span class="string">&#x27;&#123;&#x27;</span> || c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>()!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-牛的表达式计算器"><a href="#7-牛的表达式计算器" class="headerlink" title="7.牛的表达式计算器"></a>7.牛的表达式计算器</h2><p>[<a href="https://www.nowcoder.com/practice/261e7f01438f414c92f59c0059d3a906">https://www.nowcoder.com/practice/261e7f01438f414c92f59c0059d3a906</a>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param tokens string字符串vector </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculatePostfix</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用到队列，从左往右，依次入队，遇到运算符，出队两个进行计算，再入队</span></span><br><span class="line">        <span class="comment">// 将数组中的数据入栈，如果遇到符号，则出数据并进行相加，再入数据，直到遍历完。</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str==<span class="string">&quot;+&quot;</span>||str==<span class="string">&quot;-&quot;</span>||str==<span class="string">&quot;*&quot;</span>||str==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> right=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(left+right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(left-right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(left*right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(left/right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculatePostfix</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; sk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i] != <span class="string">&quot;+&quot;</span> &amp;&amp; tokens[i] != <span class="string">&quot;-&quot;</span> &amp;&amp; tokens[i] != <span class="string">&quot;*&quot;</span> &amp;&amp; tokens[i] != <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i])); <span class="comment">// 遇到数字将其入栈（需要将字符串转为整型）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 遇到运算符则依次弹出栈顶的两个数字进行相应的运算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = sk.<span class="built_in">top</span>();</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> a = sk.<span class="built_in">top</span>();</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = a + b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = a - b; <span class="comment">// 注意弹出和运算顺序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = a * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res = a / b;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.<span class="built_in">push</span>(res); <span class="comment">// 将运算结果入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sk.<span class="built_in">top</span>(); <span class="comment">// 最终栈顶元素即为运算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-牛群排列去重&quot;&gt;&lt;a href=&quot;#1-牛群排列去重&quot; class=&quot;headerlink&quot; title=&quot;1.  牛群排列去重&quot;&gt;&lt;/a&gt;1.  牛群排列去重&lt;/h2&gt;&lt;p&gt;[&lt;a href=&quot;https://www.nowcoder.com/practic</summary>
      
    
    
    
    <category term="算法训练" scheme="https://daixueshengt.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="算法题" scheme="https://daixueshengt.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>9.day9 (5-14)</title>
    <link href="https://daixueshengt.github.io/posts/a5d80461.html"/>
    <id>https://daixueshengt.github.io/posts/a5d80461.html</id>
    <published>2024-05-14T11:30:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="牛客-前端专业面试真题"><a href="#牛客-前端专业面试真题" class="headerlink" title="牛客-前端专业面试真题"></a>牛客-前端专业面试真题</h2><h3 id="1-说一说HTML语义化？"><a href="#1-说一说HTML语义化？" class="headerlink" title="1.说一说HTML语义化？"></a>1.说一说HTML语义化？</h3><p>语义化标签、利于页面内容结构化、利于无CSS页面可读、利于SEO、利于代码可读  标准回答 HTML语义化就是指在使用HTML标签构建页面时，避免大篇幅的使用无语义的标签</p><p>使用HTML语义化标签的作用：</p><ul><li>易于用户阅读，样式文件未加载时，页面结构清晰</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重</li><li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，代码更具可读性，代码更好维护</li></ul><p>加分回答 HTML5语义化标签并没有广泛使用，比如京东、淘宝等，还是使用div元素，设置id是header或者footer，这个可能是因为HTML5新增的语义化标签的作用不是特别大，网站没有必要重写</p><h3 id="2-说一说盒模型？"><a href="#2-说一说盒模型？" class="headerlink" title="2.说一说盒模型？"></a>2.说一说盒模型？</h3><p>CSS盒模型定义了盒的每个部分包含 margin, border, padding,  content 。根据盒子大小的计算方式不同盒模型分成了两种，标准盒模型和怪异盒模型。 标准模型，给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 content box。<code>padding</code> 和 <code>border</code>再加上设置的宽高一起决定整个盒子的大小。  怪异盒模型，给盒设置 <code>width</code> 和 <code>height</code>，包含了<code>padding</code>和<code>border</code>，设置的 <code>width</code> 和 <code>height</code>就是盒子实际的大小 默认情况下，盒模型都是标准盒模型 设置标准盒模型：<code>box-sizing:content-box</code> 设置怪异盒模型：<code>box-sizing:border-box</code></p><h3 id="3-说一下浮动？"><a href="#3-说一下浮动？" class="headerlink" title="3.说一下浮动？"></a>3.说一下浮动？</h3><p>得分点 脱离文档流、盒子塌陷、 影响其他元素排版、伪元素  、<code>overflow:hidden</code> 、标签插入法  </p><p>标准回答 浮动的作用，设置浮动的图片，可以实现文字环绕图片，设置了浮动的块级元素可以排列在同一行，设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。</p><p>设置浮动元素的特点：</p><ul><li>设置了浮动，该元素脱标。元素不占位置 -浮动可以进行模式转换（行内块元素）  浮动造成的影响，使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。  </li></ul><p>清除浮动的方法：</p><ul><li>伪元素清除浮动：给浮动元素父级增加 .clearfix::after {      content: ‘’; display: table; clear: both;  } /<em>兼容IE低版本 </em>/ .clearfix {  *zoom: 1; } overflow：hidden<code>：给浮动元素父级增加</code>overflow：hidden`属性 额外标签法：给浮动元素父级增加标签 </li></ul><p>加分回答 三种清除浮动的特点和影响：</p><ul><li>伪元素清除浮动：不会新增标签，不会有其他影响，是当下清除浮动最流行的方法 </li><li><code>overflow：hidden</code>：不会新增标签，但是如果父级元素有定位元素超出父级，超出部分会隐藏，在不涉及父级元素有超出内容的情况，overflow：hidden比较常用，毕竟写法方便简洁 </li><li>标签插入法：清除浮动的语法加在新增标签上，由于新增标签会造成不必要的渲染，所以这种方法目前不建议使用</li></ul><h3 id="4-说一说样式优先级的规则是什么？"><a href="#4-说一说样式优先级的规则是什么？" class="headerlink" title="4.说一说样式优先级的规则是什么？"></a>4.说一说样式优先级的规则是什么？</h3><p>得分点 <code>!important</code>、行内样式、嵌入样式、外链样式、id选择器、类选择器、标签选择器、复合选择器、通配符、继承样式  </p><p>标准回答:</p><p>CSS样式的优先级应该分成四大类</p><ul><li>第一类<code>!important</code>，无论引入方式是什么，选择器是什么，它的优先级都是最高的。</li><li>第二类引入方式，行内样式的优先级要高于嵌入和外链，嵌入和外链如果使用的选择器相同就看他们在页面中插入的顺序，在后面插入的会覆盖前面的。</li><li>第三类选择器，选择器优先级：id选择器&gt;（类选择器 | 伪类选择器 | 属性选择器 ）&gt; （后代选择器 | 伪元素选择器 ）&gt; （子选择器 | 相邻选择器） &gt; 通配符选择器 。</li><li>第四类继承样式，是所有样式中优先级比较低的。</li><li>第五类浏览器默认样式优先级最低。</li></ul><p>加分回答：</p><p>用!important要谨慎</p><ul><li>一定要优先考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li><li>只有在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></li><li>永远不要在你的插件中使用 <code>!important</code></li><li>永远不要在全站范围的 CSS 代码中使用 <code>!important</code>  优先级的比较指的是相同的样式属性，不同样式属性优先级比较失效，比如：在设置<code>max-width</code>时注意，已经给元素的<code>max-width</code>设置了<code>!important</code>但是还不生效，很有可能就是被width覆盖了  举例：<code>div</code>最终的宽度还是<code>200px</code>  <code>div &#123;  max-width: 400px !important; height: 200px;background-color: tomato;width: 200px;&#125;</code></li></ul><h3 id="5-说一说CSS尺寸设置的单位"><a href="#5-说一说CSS尺寸设置的单位" class="headerlink" title="5.说一说CSS尺寸设置的单位"></a>5.说一说CSS尺寸设置的单位</h3><p>px、rem、em、vw、vh </p><p>标准回答:</p><p>px：pixel像素的缩写，绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位。</p><p>em：相对长度单位，在 <code>font-size</code> 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如当前元素的字体尺寸未设置，由于字体大小可继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小。</p><p>rem：相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小。</p><p>vw：相对长度单位，相对于视窗宽度的1%。</p><p>vh：相对长度单位，相对于视窗高度的1%。</p><p> 加分回答:</p><p>rem应用：在移动端网页开发中，页面要做成响应式的，可使用rem配合媒体查询或者flexible.js实现。原理是通过媒体查询或者flexible.js，能够在屏幕尺寸发生改变时，重置html根元素的字体大小，页面中的元素都是使用rem为单位设置的尺寸，因此只要改变根元素字体大小，页面中的其他元素的尺寸就自动跟着修改  vw应用：由于vw被更多浏览器兼容之后，在做移动端响应式页面时，通常使用vw配合rem。原理是使用vw设置根元素html字体的大小，当窗口大小发生改变，vw代表的尺寸随着修改，无需加入媒体查询和flexible.js，页面中的其他元素仍使用rem为单位，就可实现响应式。</p><h3 id="6-说一说BFC"><a href="#6-说一说BFC" class="headerlink" title="6.说一说BFC"></a>6.说一说BFC</h3><p>定义：BFC(Block Formatting Context)块级格式化上下文，是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。</p><p>形成条件：a.flaot  b.position  3. overflow  4.display</p><p>布局规则：</p><p>a.区域内box从上到下排列 </p><p>b.box垂直方向的距离由margin决定 </p><p>c.同一个bfc内box margin会重叠</p><p>d.bfc不会与flaot重叠 </p><p>e.bfc计算高度 也会计算float元素 </p><h3 id="7-说几个未知宽高元素水平垂直居中方法"><a href="#7-说几个未知宽高元素水平垂直居中方法" class="headerlink" title="7.说几个未知宽高元素水平垂直居中方法"></a>7.说几个未知宽高元素水平垂直居中方法</h3><p><code>position</code>   <code>transform</code>   <code>flex</code>   <code>justify-content</code>   <code>align-items</code>  <code>vertical-align</code>  <code>text-align</code></p><p> 标准回答</p><p> 未知宽高元素水平垂直都居中的实现方法：</p><ol><li>设置元素相对父级定位<code>position:absolute;left:50%;right:50%</code>，让自身平移自身高度50% <code>transform: translate(-50%,-50%);</code>，这种方式兼容性好，被广泛使用的一种方式</li><li>设置元素的父级为弹性盒子<code>display:flex</code>，设置父级和盒子内部子元素水平垂直都居中<code>justify-content:center; align-items:center</code>  ，这种方式代码简洁，但是兼容性ie 11以上支持，由于目前ie版本都已经很高，很多网站现在也使用这种方式实现水平垂直居中</li><li>设置元素的父级为网格元素<code>display: grid</code>，设置父级和盒子内部子元素水平垂直都居中<code>justify-content:center; align-items:center</code>  ，这种方式代码简洁，但是兼容性ie 10以上支持<ol><li>设置元素的父级为表格元素<code>display: table-cell</code>，其内部元素水平垂直都居中<code>text-align: center;vertical-align: middle;</code> ，设置子元素为行内块<code>display: inline-block;</code>，这种方式兼容性较好</li></ol></li></ol><p>加分回答</p><p>京东的移动端顶部京东logo，使用的是<code>display:flex</code>这种模式 </p><h3 id="8-说一说三栏布局的实现方案"><a href="#8-说一说三栏布局的实现方案" class="headerlink" title="8.说一说三栏布局的实现方案"></a>8.说一说三栏布局的实现方案</h3><p>三栏布局：三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。  这里以左边宽度固定为100px，右边宽度固定为200px为例。  （1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。  （2）利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1  （3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。  （4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于左边列的宽度，否则左边列上不去，而双飞翼布局则不存在这个问题。  （5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</p><h3 id="9-说一说JS数据类型有哪些-区别是什么？"><a href="#9-说一说JS数据类型有哪些-区别是什么？" class="headerlink" title="9.说一说JS数据类型有哪些,区别是什么？"></a>9.说一说JS数据类型有哪些,区别是什么？</h3><p>Number、String、Boolean、BigInt、Symbol、Null、Undefined、Object、8种</p><p>标准回答：</p><p> JS数据类型分为两类：一类是基本数据类型，也叫简单数据类型，包含7种类型，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。另一类是引用数据类型也叫复杂数据类型，通常用Object代表，普通对象，数组，正则，日期，Math数学函数都属于Object。</p><p> 数据分成两大类的本质区别：基本数据类型和引用数据类型它们在内存中的存储方式不同。</p><p> 基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。</p><p>引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p><p> 加分回答：</p><p> Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。</p><p>数据的创建方法Symbol()，因为它的构造函数不够完整，所以不能使用new Symbol()创建数据。由于Symbol()创建数据具有唯一性，所以 Symbol() !== Symbol(), 同时使用Symbol数据作为key不能使用for获取到这个key，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。</p><p>BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。</p><p>使用方法：</p><ul><li>整数末尾直接+n：647326483767797n</li><li>调用BigInt()构造函数：BigInt(“647326483767797”)</li><li>注意：BigInt和Number之间不能进行混合操作  </li></ul><h3 id="10-说一说null-和-undefined-的区别，如何让一个属性变为null"><a href="#10-说一说null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="10.说一说null 和 undefined 的区别，如何让一个属性变为null"></a>10.说一说null 和 undefined 的区别，如何让一个属性变为null</h3><p>undefind 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是undefined。undefined通过typeof判断类型是’undefined’。undefined == undefined  undefined === undefined 。</p><p>null代表对象的值未设置，相当于一个对象没有设置指针地址就是null。null通过typeof判断类型是’object’。</p><p>undefined 表示一个变量初始状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。</p><p>null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。因此，需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</p><h3 id="11-说一说JavaScript有几种方法判断变量的类型？"><a href="#11-说一说JavaScript有几种方法判断变量的类型？" class="headerlink" title="11.说一说JavaScript有几种方法判断变量的类型？"></a>11.说一说JavaScript有几种方法判断变量的类型？</h3><p>typeof、instanceof、Object.prototype.toString.call()（对象原型链判断方法）、 constructor (用于引用数据类型)   </p><p>标准回答:</p><p>typeof：常用于判断基本数据类型，对于引用数据类型除了function返回’function‘，其余全部返回’object’。</p><p>instanceof：主要用于区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined, null, symbol检测不出来。</p><p>constructor：用于检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。</p><p>Object.prototype.toString.call()：适用于所有类型的判断检测，检测方法是Object.prototype.toString.call(数据) 返回的是该数据类型的字符串。 </p><h3 id="12-说一说数组去重都有哪些方法？"><a href="#12-说一说数组去重都有哪些方法？" class="headerlink" title="12.说一说数组去重都有哪些方法？"></a>12.说一说数组去重都有哪些方法？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">new</span> <span class="title class_">Set</span>(): </span><br><span class="line"><span class="keyword">let</span> array = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="number">2.</span><span class="attr">indexOf</span>: </span><br><span class="line"><span class="keyword">if</span>(array.<span class="title function_">indexOf</span>(arr[i]) == -<span class="number">1</span>)&#123; array.<span class="title function_">push</span>(arr[i])&#125;  </span><br><span class="line">或者 arr5.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span> &#123;<span class="keyword">return</span> self.<span class="title function_">indexOf</span>(item) === index&#125;)  </span><br><span class="line"><span class="number">3.</span>使用reduce+includes：</span><br><span class="line"><span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,curr</span>) =&gt;</span> prev.<span class="title function_">includes</span>(curr) ? prev : [...prev,curr],[])   </span><br></pre></td></tr></table></figure><h3 id="13-说一说伪数组和数组的区别？"><a href="#13-说一说伪数组和数组的区别？" class="headerlink" title="13.说一说伪数组和数组的区别？"></a>13.说一说伪数组和数组的区别？</h3><p> 伪数组它的类型不是Array，而是Object，而数组类型是Array。可以使用的length属性查看长度，也可以使用[index]获取某个元素，但是不能使用数组的其他方法，也不能改变长度，遍历使用for in方法。</p><p>伪数组的常见场景：</p><ul><li>函数的参数arguments </li><li>原生js获取DOM：document.querySelector(‘div’) 等</li><li>jquery获取DOM：$(“div”)等 </li></ul><p>伪数组转换成真数组方法 </p><ul><li>Array.prototype.slice.call(伪数组) </li><li>[].slice.call(伪数组) </li><li>Array.from(伪数组) 转换后的数组长度由 <code>length</code> 属性决定。索引不连续时转换结果是连续的，会自动补位。</li></ul><h3 id="14-说一说map-和-forEach-的区别？"><a href="#14-说一说map-和-forEach-的区别？" class="headerlink" title="14.说一说map 和 forEach 的区别？"></a>14.说一说map 和 forEach 的区别？</h3><p>map有返回值，可以开辟新空间，return出来一个length和原数组一致的数组，即便数组元素是undefined或者是null。</p><p>forEach默认无返回值，返回结果为undefined，可以通过在函数体内部使用索引修改数组元素。</p><p>map的处理速度比forEach快，而且返回一个新的数组，方便链式调用其他数组新方法，比如filter、reduce</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">map</span>(<span class="function"><span class="params">value</span> =&gt;</span> value * value).<span class="title function_">filter</span>(<span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">10</span>); <span class="comment">// arr2 = [16, 25]</span></span><br></pre></td></tr></table></figure><h3 id="15-说一说es6中箭头函数？"><a href="#15-说一说es6中箭头函数？" class="headerlink" title="15.说一说es6中箭头函数？"></a>15.说一说es6中箭头函数？</h3><p>得分点 没有this、this是从外部获取、不能使用new、没有arguments、没有原型和super</p><p>标准回答</p><p>箭头函数相当于匿名函数，简化了函数定义。箭头函数有两种写法，当函数体是单条语句的时候可以省略{}和return。另一种是包含多条语句，不可以省略{}和return。</p><p>箭头函数最大的特点就是没有this，所以this是从外部获取，就是继承外部的执行上下文中的this，由于没有this关键字所以箭头函数也不能作为构造函数， 同时通过 <code>call()</code> 或 <code>apply()</code> 方法调用一个函数时，只能传递参数（不能绑定this），第一个参数会被忽略。箭头函数也没有原型和super。</p><p>不能使用yield关键字，因此箭头函数不能用作 Generator 函数。不能返回直接对象字面量。  </p><p>加分回答</p><p>箭头函数函数适用场景:</p><ul><li><p>简单的函数表达式，内部没有this引用，没有递归、事件绑定、解绑定，适用于map、filter等方法中，写法简洁  <code>var arr = [1,2,3]; var newArr = arr.map((num)=&gt;num*num)</code></p></li><li><p>内层函数表达式，需要调用this，且this应与外层函数一致时</p></li><li><blockquote><p>let group = {   title: “Our Group”,   students: [“John”, “Pete”, “Alice”],   </p><p>showList() {     this.students.forEach(       student =&gt; alert(this.title + ‘: ‘ + student)     );   } }; group.showList();</p></blockquote></li></ul><h3 id="16-事件扩展符用过吗-…-，什么场景下？"><a href="#16-事件扩展符用过吗-…-，什么场景下？" class="headerlink" title="16.事件扩展符用过吗(…)，什么场景下？"></a>16.事件扩展符用过吗(…)，什么场景下？</h3><ol><li>数组克隆 let a = [1,2,3];let b = […a] </li><li>数组合并 let a = [1,2,3];let b = [4,5,6];let c = […a,…b] </li><li>类数组转成真正的数组 let a = new Set([1,2,3]); let b = […a] </li></ol><p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历的属性，浅拷贝到当前的对象中，浅拷贝和深拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><h3 id="17-说一说你对闭包的理解？"><a href="#17-说一说你对闭包的理解？" class="headerlink" title="17.说一说你对闭包的理解？"></a>17.说一说你对闭包的理解？</h3><ol><li>内层函数引用外层函数中变量，这些变量的集合就是闭包 </li><li>通过作用域链，当前作用域可以访问上级作用域中的变量 </li><li>解决的问题：保存变量，保护变量 </li><li>带来的问题：内存泄露 </li><li>块级作用域</li></ol><p>闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量</p><p>闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。 </p><p>闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。</p><p>加分回答 闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。 </p><h3 id="18-说一说JS变量提升？"><a href="#18-说一说JS变量提升？" class="headerlink" title="18.说一说JS变量提升？"></a>18.说一说JS变量提升？</h3><p>函数和var声明的变量会有变量提升，js在预编译阶段会将函数和var声明的变量提升至最前面先执行，之后再按顺序执行代码块进行赋值，而let和const声明的变量只是创建提升，在预编译中将其创建，形成暂时性死区，不能提前访问和调用变量，只能在赋值之后进行调用和访问</p><h3 id="19-说一说this指向（普通函数、箭头函数）？"><a href="#19-说一说this指向（普通函数、箭头函数）？" class="headerlink" title="19.说一说this指向（普通函数、箭头函数）？"></a>19.说一说this指向（普通函数、箭头函数）？</h3><p>普通函数指向调用处，箭头函数指向定义处</p><h3 id="20-说一说call-apply-bind的作用和区别？"><a href="#20-说一说call-apply-bind的作用和区别？" class="headerlink" title="20.说一说call apply bind的作用和区别？"></a>20.说一说call apply bind的作用和区别？</h3><p>首先，call apply bind三个方法都可以用来改变函数的this指向，具体区别如下：</p><p>1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。  </p><p>  2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。  </p><p>  3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn</p><h3 id="21-说一说js继承的方法和优缺点？"><a href="#21-说一说js继承的方法和优缺点？" class="headerlink" title="21.说一说js继承的方法和优缺点？"></a>21.说一说js继承的方法和优缺点？</h3><p>1、原型链继承 </p><p>优点：写法简单、容易理解。</p><p>缺点：①引用类型的值会被所有实例共享；②在子类实例对象创建时，不能向父类传参；</p><p>2、借用构造函数继承 </p><p>优点：①避免了引用类型的值会被所有实例共享；②在子类实例对象创建时，可以向父类传参；</p><p>缺点：方法在构造函数中，每次创建实例对象时都会重新创建一遍方法；</p><p>3、组合继承</p><p>融合原型链和借用构造函数的优点，是js中最常用的继承方式；</p><p>缺点：无论什么情况下，父类构造函数都会被调用两次，一是创建子类原型对象时，二是子类构造函数内部。</p><p>4、原型式继承 </p><p>优点：不需要单独创建构造函数；</p><p>缺点：引用类型的值会被所有实例共享。</p><p>5、寄生式继承</p><p>优点：不需要单独创建构造函数；</p><p>缺点：方法在构造函数中，每次创建实例对象时都会重新创建一遍。</p><p>6、寄生组合继承</p><p>优点：高效率只调用一次父类构造函数，并且避免了子类原型对象上不必要、多余的属性，同时，还能将原型链保持不变，因此能使用instanceof 和 isPrototypeOf。</p><p>缺点：代码复杂</p><h3 id="22-说一说new会发生什么？"><a href="#22-说一说new会发生什么？" class="headerlink" title="22.说一说new会发生什么？"></a>22.说一说new会发生什么？</h3><ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）</li><li>为步骤1新创建的对象添加属性<code>__proto__</code>，将该属性链接至构造函数的原型对象</li><li>将步骤1新创建的对象作为<code>this</code>的上下文</li><li><p>如果该函数没有返回对象，则返回<code>this</code></p><p><code>new</code>关键字后面的构造函数不能是箭头函数。</p></li></ol><h3 id="23-说一说defer和async区别？"><a href="#23-说一说defer和async区别？" class="headerlink" title="23.说一说defer和async区别？"></a>23.说一说defer和async区别？</h3><p>html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器在解析文档时遇到script标签就会停止解析阻塞文档解析，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。 而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行，而async是在JS加载完成后立即执行JS脚本，阻塞文档解析，而defer则是JS加载完成后，在文档解析完成后执行JS脚本。</p><p>因为js文件存在服务器中并不是在浏览器中，当浏览器遇见script标签时就发起请求，也就是加载的意思，然后把js代码解析再执行  </p><p>文档解析就是解析html创建dom树</p><h3 id="24-说一说promise是什么与使用方法？"><a href="#24-说一说promise是什么与使用方法？" class="headerlink" title="24.说一说promise是什么与使用方法？"></a>24.说一说promise是什么与使用方法？</h3><ol><li>概念：异步编程的一种解决方案，解决了地狱回调的问题</li><li>使用方法：new Promise((resolve,reject) =&gt; { resolve（）; reject（）; })里面有多个resovle或者reject只执行第一个。如果第一个是resolve的话后面可以接.then查看成功消息。如果第一个是reject的话，.catch查看错误消息。</li></ol><p>Promise的作用：Promise是异步微任务，解决了异步多层嵌套回调的问题，让代码的可读性更高，更容易维护</p><p>Promise使用：Promise是ES6提供的一个构造函数，可以使用Promise构造函数new一个实例，Promise构造函数接收一个函数作为参数，这个函数有两个参数，分别是两个函数 <code>resolve</code>和<code>reject</code>，<code>resolve</code>将Promise的状态由等待变为成功，将异步操作的结果作为参数传递过去；<code>reject</code>则将状态由等待转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。实例创建完成后，可以使用<code>then</code>方法分别指定成功或失败的回调函数，也可以使用catch捕获失败，then和catch最终返回的也是一个Promise，所以可以链式调用。</p><p>Promise的特点：</p><ol><li>对象的状态不受外界影响（Promise对象代表一个异步操作，有三种状态）。</li><li>pending（执行中）  Resolved（成功，又称Fulfilled）  rejected（拒绝）<br>其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise对象的状态改变，只有两种可能（状态凝固了，就不会再变了，会一直保持这个结果）从Pending变为Resolved   从Pending变为Rejected</li><li>resolve 方法的参数是then中回调函数的参数，reject 方法中的参数是catch中的参数</li><li>then 方法和 catch方法 只要不报错，返回的都是一个fullfilled状态的promise</li></ol><blockquote><p>Promise.resolve() :返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。 Promise.reject()：返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法。 Promise.all()：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。 Promise.any()：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。 </p><p>Promise.race()：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 </p></blockquote><h3 id="25-说一说JS实现异步的方法？"><a href="#25-说一说JS实现异步的方法？" class="headerlink" title="25.说一说JS实现异步的方法？"></a>25.说一说JS实现异步的方法？</h3><p>得分点：回调函数、事件监听、setTimeout、Promise、生成器Generators/yield、async/await </p><h3 id="26-说一说cookie、sessionStorage、localStorage-区别？"><a href="#26-说一说cookie、sessionStorage、localStorage-区别？" class="headerlink" title="26.说一说cookie、sessionStorage、localStorage 区别？"></a>26.说一说cookie、sessionStorage、localStorage 区别？</h3><p>1.都是浏览器存储 </p><p>2.都存储在浏览器本地 </p><p>区别： </p><ol><li>cookie由服务器写入， sessionStorage以及localStorage都是由前端写入</li><li>cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除 </li><li>cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M </li><li>3者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面 </li><li>前端给后端发送请求时，自动携带Cookie中的数据, 但是SessionStorage、 LocalStorage不会</li><li>cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能</li></ol><h3 id="27-说一说如何实现可过期的localstorage数据？"><a href="#27-说一说如何实现可过期的localstorage数据？" class="headerlink" title="27.说一说如何实现可过期的localstorage数据？"></a>27.说一说如何实现可过期的localstorage数据？</h3><p>惰性删除是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p><h3 id="28-说一下token-能放在cookie中吗？"><a href="#28-说一下token-能放在cookie中吗？" class="headerlink" title="28.说一下token 能放在cookie中吗？"></a>28.说一下token 能放在cookie中吗？</h3><p>能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie </p><p>token认证流程 </p><ol><li>客户端使用用户名跟密码请求登录 </li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端签发一个 token ，并把它发送给客户端</li><li>客户端接收 token 以后会把它存储起来，比如放在  cookie 里或者 localStorage 里</li><li>客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里） </li><li>服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据</li></ol><h3 id="29-说一说axios的拦截器原理及应用？"><a href="#29-说一说axios的拦截器原理及应用？" class="headerlink" title="29.说一说axios的拦截器原理及应用？"></a>29.说一说axios的拦截器原理及应用？</h3><p> 1.拦截器分为 请求（request）拦截器和响应（response）拦截器。<br> 2.请求拦截器用于在接口请求之前做的处理，比如为每个请求带上相应的参数（token，时间戳等）。<br> 3.响应拦截器用于在接口返回之后做的处理，比如对返回的状态进行判断（token是否过期）<br> 4.拦截器原理：创建一个chn数组，数组中保存了拦截器相应方法以及dispatchRequest（dispatchRequest这个函数调用才会真正的开始下发请求），把请求拦截器的方法放到chn数组中dispatchRequest的前面，把响应拦截器的方法放到chn数组中dispatchRequest的后面，把请求拦截器和响应拦截器forEach将它们分unshift,push到chn数组中，为了保证它们的执行顺序，需要使用promise，以出队列的方式对chn数组中的方法挨个执行。</p><h3 id="30-说一说创建ajax过程？"><a href="#30-说一说创建ajax过程？" class="headerlink" title="30.说一说创建ajax过程？"></a>30.说一说创建ajax过程？</h3><p>（1）创建异步对象，即 XMLHttpRequest 对象。 </p><p>（2）使用 open 方法设置请求参数。open(method, url, async)。</p><p>​    参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。 </p><p>（3）发送请求：send()。 </p><p>（4）注册事件：注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调  用，我们需要手动写一些判断的逻辑。</p><p> （5）服务端响应，获取返回的数据。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;牛客-前端专业面试真题&quot;&gt;&lt;a href=&quot;#牛客-前端专业面试真题&quot; class=&quot;headerlink&quot; title=&quot;牛客-前端专业面试真题&quot;&gt;&lt;/a&gt;牛客-前端专业面试真题&lt;/h2&gt;&lt;h3 id=&quot;1-说一说HTML语义化？&quot;&gt;&lt;a href=&quot;#1-说一</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>8.ES6中扩展运算符的作用</title>
    <link href="https://daixueshengt.github.io/posts/1a75aa6a.html"/>
    <id>https://daixueshengt.github.io/posts/1a75aa6a.html</id>
    <published>2024-05-13T21:30:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="23-ES6中扩展运算符的作用"><a href="#23-ES6中扩展运算符的作用" class="headerlink" title="23.ES6中扩展运算符的作用"></a>23.ES6中扩展运算符的作用</h2><p>ES6中扩展运算符(…)的作用:将一个数组变为一个以空格分隔的参数序列</p><p>数组的复制 （浅拷贝）</p><p>数组的和合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arr4=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> arr5=[...arr3,...arr4];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr5)</span><br><span class="line">对象合并同理</span><br></pre></td></tr></table></figure><p>字符串改为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArr=[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArr)</span><br></pre></td></tr></table></figure><h2 id="24-ES6中的rest参数"><a href="#24-ES6中的rest参数" class="headerlink" title="24.ES6中的rest参数"></a>24.ES6中的rest参数</h2><p>ES6中的rest参数，用于禁取函数多余的参数，形式:(…变量名)，把一个分离的参数序列整合为一个数组，值是一个数组</p><p>rest参数只能放在最后一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">a,...argus</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> argus)&#123;</span><br><span class="line">        total+=value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="25-ES6中对象和数组的解构"><a href="#25-ES6中对象和数组的解构" class="headerlink" title="25.ES6中对象和数组的解构"></a>25.ES6中对象和数组的解构</h2><p>解构：一种提取数据的模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的解构：以元素的位置为匹配条件</span></span><br><span class="line"><span class="keyword">const</span> [a,b,c] =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c)</span><br><span class="line"><span class="keyword">const</span> [a,,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的解构:是以属性的名称为匹配条件</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:name,age&#125;=obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">children</span>:&#123;<span class="attr">name1</span>:<span class="string">&quot;张三2&quot;</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,<span class="attr">children</span>:&#123;name1&#125;&#125;=obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS中什么是DOM和BOM?</span></span><br><span class="line"><span class="comment">//DOM:document,文档对象类型，用来获取或者设置文档标签的属性</span></span><br><span class="line"><span class="comment">// JS可以通过DOM获取到有哪些标签，标签有哪些属性，内容有哪些</span></span><br><span class="line"><span class="comment">// DOM操作的对象是文档，所以DOM和浏览器没有关系，关注网页本身的内容</span></span><br><span class="line"><span class="comment">// BOM:browser object model，浏览器对象模型，提供独立于内容而与浏览器窗口进行交瓦的对象</span></span><br><span class="line"><span class="comment">// 管理窗口与窗口之间的通讯，核心对象是window --&gt; location(用于url相关的操作)、history(用于历史相关的操作)，navigator(包含了浏览器相关的信息)...</span></span><br><span class="line"><span class="comment">// BOM是控制浏览器行为的api,DOM是一个页面结构的api</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;23-ES6中扩展运算符的作用&quot;&gt;&lt;a href=&quot;#23-ES6中扩展运算符的作用&quot; class=&quot;headerlink&quot; title=&quot;23.ES6中扩展运算符的作用&quot;&gt;&lt;/a&gt;23.ES6中扩展运算符的作用&lt;/h2&gt;&lt;p&gt;ES6中扩展运算符(…)的作用:将一</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>7.ES6中const定义的对象属性可以修改吗？</title>
    <link href="https://daixueshengt.github.io/posts/5d1f741e.html"/>
    <id>https://daixueshengt.github.io/posts/5d1f741e.html</id>
    <published>2024-05-11T22:27:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19-ES6中const定义的对象属性可以修改吗？"><a href="#19-ES6中const定义的对象属性可以修改吗？" class="headerlink" title="19.ES6中const定义的对象属性可以修改吗？"></a>19.ES6中const定义的对象属性可以修改吗？</h2><p>const定义后，当然可以修改对象中的属性的值</p><p>const保证并不是变量的值不能改动，而是变量指向内存地址不能改动</p><h2 id="20-ES6中let、const和var有哪些用法和区别？"><a href="#20-ES6中let、const和var有哪些用法和区别？" class="headerlink" title="20.ES6中let、const和var有哪些用法和区别？"></a>20.ES6中let、const和var有哪些用法和区别？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var</span>:</span><br><span class="line">使用<span class="keyword">var</span>声明的变量既是顶级变量(顶层对象(<span class="variable language_">window</span>对象)的属性)也是全局变量</span><br><span class="line">使用<span class="keyword">var</span>声明的变量存在变量提升的情况</span><br><span class="line">使用<span class="keyword">var</span>可以对一个变量进行多次声明，后面的声明会覆盖前面的变量声明</span><br><span class="line">在函数中再次使用<span class="keyword">var</span>声明这个变量的时候，这个变量就是局部的，如果不是用<span class="keyword">var</span>，那就全局的</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> :</span><br><span class="line"><span class="keyword">let</span>所声明变量只在<span class="keyword">let</span>命令所在的代码块中生效</span><br><span class="line"><span class="keyword">let</span>不存在变量提升</span><br><span class="line"><span class="keyword">let</span>不允许在相同的作用域下重复声明</span><br><span class="line"></span><br><span class="line"><span class="attr">const</span>:</span><br><span class="line"><span class="keyword">const</span>声明一个只读的常量，一旦声明，常量的值就不能改变</span><br><span class="line"><span class="keyword">const</span>一旦声明，就必须赋值</span><br><span class="line">除了以上的其他的都和<span class="keyword">let</span>一样的</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">变量提升:</span><br><span class="line"><span class="keyword">var</span>声明的变量存在变量提升，<span class="keyword">let</span>和<span class="keyword">const</span>不存在变量提升</span><br><span class="line">块级作用域:</span><br><span class="line"><span class="keyword">var</span>不存在块级作用域，<span class="keyword">let</span>和<span class="keyword">const</span>存在块级作用域，只在所在代码块生效</span><br><span class="line">重复声明:</span><br><span class="line"><span class="keyword">var</span>允许重复声明，<span class="keyword">let</span>和<span class="keyword">const</span>不允许在同一个作用域重复声明</span><br><span class="line">修改声明的变量:</span><br><span class="line"><span class="keyword">var</span>和<span class="keyword">let</span>可以改变声明的变量，<span class="keyword">const</span>，不可以，一旦声明，必须赋值，并且常量的值不能改变</span><br></pre></td></tr></table></figure><h2 id="21-JS中如何判断一个对象是空对象？"><a href="#21-JS中如何判断一个对象是空对象？" class="headerlink" title="21.JS中如何判断一个对象是空对象？"></a>21.JS中如何判断一个对象是空对象？</h2><p>使用JSON自带的.stringify方法来判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)===<span class="string">&quot;&#123;&#125;&quot;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是空对象&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用object.keys()来判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj))<span class="comment">//[name,age]</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是一个空对象&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-如果在ES6中new一个箭头函数会怎么样？"><a href="#22-如果在ES6中new一个箭头函数会怎么样？" class="headerlink" title="22.如果在ES6中new一个箭头函数会怎么样？"></a>22.如果在ES6中new一个箭头函数会怎么样？</h2><p>会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new关键字的执行过程</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">new</span>构造函数会在内存中创建一个空对象</span><br><span class="line"><span class="number">2.</span><span class="variable language_">this</span>就会指向刚才创建的那个空对象</span><br><span class="line"><span class="number">3.</span>执行构造函数中的代码，给空对象添加属性和方法</span><br><span class="line"><span class="number">4.</span>返回这个新的对象（所以构造函数中不需要<span class="keyword">return</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"> 箭头函数内的<span class="variable language_">this</span>是静态的，指向定义时所在的对象，而不是调用时，<span class="variable language_">this</span>指向不可以改变的</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;19-ES6中const定义的对象属性可以修改吗？&quot;&gt;&lt;a href=&quot;#19-ES6中const定义的对象属性可以修改吗？&quot; class=&quot;headerlink&quot; title=&quot;19.ES6中const定义的对象属性可以修改吗？&quot;&gt;&lt;/a&gt;19.ES6中cons</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>6.你是如何在JS中进行隐式转换的？</title>
    <link href="https://daixueshengt.github.io/posts/2b5cd5a6.html"/>
    <id>https://daixueshengt.github.io/posts/2b5cd5a6.html</id>
    <published>2024-05-10T21:27:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-你是如何在JS中进行隐式转换的？"><a href="#16-你是如何在JS中进行隐式转换的？" class="headerlink" title="16.你是如何在JS中进行隐式转换的？"></a>16.你是如何在JS中进行隐式转换的？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// + 操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串;其他情况下两边的变量都会被转换为数字。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>+<span class="string">&quot;23&quot;</span>);<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>+<span class="literal">false</span>);<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>+<span class="literal">false</span>);<span class="comment">//1false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>+<span class="literal">false</span>);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -、*、/ 操作运算符会转换为数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">25</span>-<span class="string">&#x27;23&#x27;</span>);<span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>*<span class="literal">false</span>);<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>/<span class="string">&#x27;aa&#x27;</span>);<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于==操作符来说</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>==<span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;0&#x27;</span>==<span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &lt; 和 &gt; 比较符，按照字母的排列顺序来比较</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>&gt;<span class="string">&#x27;d&#x27;</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;de&#x27;</span>&gt;<span class="string">&#x27;fg&#x27;</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他情况下，转换为数字再比较</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>&lt;<span class="number">13</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>&lt;-<span class="number">1</span>)<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a&gt;<span class="number">2</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">valueOf</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a.<span class="title function_">toString</span>()));</span><br></pre></td></tr></table></figure><h2 id="17-你是如何理解JS中深拷贝和浅拷贝的？"><a href="#17-你是如何理解JS中深拷贝和浅拷贝的？" class="headerlink" title="17.你是如何理解JS中深拷贝和浅拷贝的？"></a>17.你是如何理解JS中深拷贝和浅拷贝的？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要在于复制出来的新对象和原来的对象是否会互相影响</span></span><br><span class="line"><span class="comment">// 浅拷贝:仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅拷贝出来的对象也会相应的改变</span></span><br><span class="line"><span class="comment">// 新旧对象共享内存，修改其中一个，另一个也会受到影响</span></span><br><span class="line"><span class="comment">// 深拷贝:在内存中开辟一块新的地址用于存放复制的对象</span></span><br><span class="line"><span class="comment">// 新旧对象不会共享内存，修改其中的一个不会影响另一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝 通过‘=’直接赋值</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1=obj;</span><br><span class="line"><span class="comment">//而后改变obj1中的属性值，obj中的也会变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝 Object.assign()方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1= <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj)</span><br><span class="line">obj1.<span class="property">age</span>=<span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝 通过JSON对象来实现</span></span><br><span class="line"><span class="comment">// JSON.stringify:将js的值(对象或者数组)转为一个JSON字符串</span></span><br><span class="line"><span class="comment">// JSON.parse:用来解析JSON字符串，转换为Object类型</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">obj1.<span class="property">age</span>=<span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝 通过扩展运算符实现深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1= &#123;...obj,<span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br></pre></td></tr></table></figure><h2 id="18-你是怎么理解JS中-操作符的强制类型转换规则的？"><a href="#18-你是怎么理解JS中-操作符的强制类型转换规则的？" class="headerlink" title="18.你是怎么理解JS中==操作符的强制类型转换规则的？"></a>18.你是怎么理解JS中==操作符的强制类型转换规则的？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS中==操作符的强制类型转换规定</span></span><br><span class="line"><span class="comment">//首先判断两者的类型是否相同，如果不相同会进行类型转换，相同的话就比较大小</span></span><br><span class="line"><span class="comment">// 转换情况:</span></span><br><span class="line"><span class="comment">// 1、字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较大小</span></span><br><span class="line"><span class="comment">// 2、其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较</span></span><br><span class="line"><span class="comment">// 3、nu11和undefined之间的相等比较，结果为真，其他值和它们进行比较都返回假值</span></span><br><span class="line"><span class="comment">// 4、对象和非对象之间的相等比较，会将对象先转为基本数据类型再进行判断</span></span><br><span class="line"><span class="comment">// 5、如果两个操作值都是对象，则比较它们是不是指向同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回true,否则返回false</span></span><br></pre></td></tr></table></figure><p><em>你想成为一个成功的人，怎么能不累</em> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;16-你是如何在JS中进行隐式转换的？&quot;&gt;&lt;a href=&quot;#16-你是如何在JS中进行隐式转换的？&quot; class=&quot;headerlink&quot; title=&quot;16.你是如何在JS中进行隐式转换的？&quot;&gt;&lt;/a&gt;16.你是如何在JS中进行隐式转换的？&lt;/h2&gt;&lt;figu</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>5.JS中有哪几种判断数组的方法？</title>
    <link href="https://daixueshengt.github.io/posts/2d646d77.html"/>
    <id>https://daixueshengt.github.io/posts/2d646d77.html</id>
    <published>2024-05-09T22:27:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-JS中有哪几种判断数组的方法？"><a href="#13-JS中有哪几种判断数组的方法？" class="headerlink" title="13.JS中有哪几种判断数组的方法？"></a>13.JS中有哪几种判断数组的方法？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js中判断数组的方法</span></span><br><span class="line"><span class="comment">//通过Object.prototype.toString.call()做判断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]))&gt;&gt;&gt; [object <span class="title class_">Array</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>))&gt;&gt;&gt; <span class="title class_">Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>)===<span class="string">&#x27;Array&#x27;</span>)&gt;&gt;&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型链做判断</span></span><br><span class="line"><span class="comment">//对象的隐式原型等于构造函数的显式原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">__proto__</span>===<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>); &gt;&gt;&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ES6的Array.isArray()做判断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([])); &gt;&gt;&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过instanceof做判断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &gt;&gt;&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.prototype.isPrototypeOf做判断,判断Array是否在传入内容的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>([])) &gt;&gt;&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="14-JS中“-”操作符什么时候用于字符串拼接？"><a href="#14-JS中“-”操作符什么时候用于字符串拼接？" class="headerlink" title="14.JS中“+”操作符什么时候用于字符串拼接？"></a>14.JS中“+”操作符什么时候用于字符串拼接？</h2><p>如果 + 操作符其中一个操作数是字符串(或者通过ToPrimitive操作之后最终得到的字符串),则执行字符串的拼接，否则执行数字加法</p><h2 id="15-JS中Object-is-和-、-有什么区别？"><a href="#15-JS中Object-is-和-、-有什么区别？" class="headerlink" title="15.JS中Object.is()和===、==有什么区别？"></a>15.JS中Object.is()和===、==有什么区别？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Js中object.is()与比较操作符 ”===“(严格相等运算符)和”==“(相等运算符)的区别</span></span><br><span class="line"><span class="comment">// 双等号(==):如果两边的类型不一致，进行强制类型转换，然后再去进行比较</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>==<span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>==<span class="string">&#x27;1&#x27;</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三等号(===):如果两边的类型不一致，不会进行强制类型转换，直接返回false。等型等值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>===<span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>===<span class="string">&#x27;1&#x27;</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>===<span class="title class_">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span>===-<span class="number">0</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// object.is() : 用来判断两个值是否严格相等。处理一些特殊的情况，-0和+0不再相等，两个NaN是相等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">is</span>(+<span class="number">0</span>，-<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;13-JS中有哪几种判断数组的方法？&quot;&gt;&lt;a href=&quot;#13-JS中有哪几种判断数组的方法？&quot; class=&quot;headerlink&quot; title=&quot;13.JS中有哪几种判断数组的方法？&quot;&gt;&lt;/a&gt;13.JS中有哪几种判断数组的方法？&lt;/h2&gt;&lt;figure c</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>4.JS数据类型检测的方式有哪些？</title>
    <link href="https://daixueshengt.github.io/posts/4b968259.html"/>
    <id>https://daixueshengt.github.io/posts/4b968259.html</id>
    <published>2024-05-08T22:52:00.000Z</published>
    <updated>2024-07-04T06:56:56.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-JS数据类型检测的方式有哪些？"><a href="#10-JS数据类型检测的方式有哪些？" class="headerlink" title="10.JS数据类型检测的方式有哪些？"></a>10.JS数据类型检测的方式有哪些？</h2><ol><li><p>typeof（检测数据类型的运算符）</p></li><li><p>instanceof（检测某一个实例是否属于这个类）</p><blockquote><p>可以正确判断对象的类型，不可以判断基本数据类型，内部运行机制，判断在它的原型链上能否找到这个类型的原型。</p></blockquote></li><li><p>constructor(检测实例和类的关系，从而检测数据类型)，引用原来构造该对象的函数</p><blockquote><p>除了undefined和null，其他类型都能检测正确</p></blockquote></li><li><p>Object.prototype.toString.call() (检测数据类型)</p><blockquote><p>都能检测</p></blockquote></li></ol><h2 id="11-JS中instanceof操作符的实现原理以及实现方法"><a href="#11-JS中instanceof操作符的实现原理以及实现方法" class="headerlink" title="11.JS中instanceof操作符的实现原理以及实现方法"></a>11.JS中instanceof操作符的实现原理以及实现方法</h2><p>instanceof操作符用于判断构造函数的prototype属性是否出现在对象的原型链中的任何位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);&gt;&gt;&gt;<span class="literal">true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)===<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); &gt;&gt;&gt;<span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Person</span>);&gt;&gt;&gt;<span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>);&gt;&gt;&gt;<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手写instanceof实现原理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instance</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line"><span class="comment">//获取对象的原型</span></span><br><span class="line"><span class="keyword">let</span> proto=<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)；</span><br><span class="line"><span class="comment">//获取构造函数的prototype属性</span></span><br><span class="line"><span class="keyword">let</span> prototype=right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!proto)&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">if</span>(proto===prototype)&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="comment">//如果没有找到，就继续在原型链上找</span></span><br><span class="line">proto=<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-JS中typeof-NaN的结果是什么？"><a href="#12-JS中typeof-NaN的结果是什么？" class="headerlink" title="12.JS中typeof NaN的结果是什么？"></a>12.JS中typeof NaN的结果是什么？</h2><p>NaN(not a number)不是一个数字，表示是否属于number类型的一种状态:是或否，不是确切的值</p><p>Js中number数据类型除了浮点型和整数型，还有一个特殊值NaN</p><p><code>console.log(typeof NaN)</code>     &gt;&gt;&gt;number</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NaN,表达式中存在不可转化的变量，返回了无效的结果，不是返回确切的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//NaN不等于本身,不是确切的值,代表一个范围</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>（<span class="title class_">NaN</span>==<span class="title class_">NaN</span>）<span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;10-JS数据类型检测的方式有哪些？&quot;&gt;&lt;a href=&quot;#10-JS数据类型检测的方式有哪些？&quot; class=&quot;headerlink&quot; title=&quot;10.JS数据类型检测的方式有哪些？&quot;&gt;&lt;/a&gt;10.JS数据类型检测的方式有哪些？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://daixueshengt.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="八股" scheme="https://daixueshengt.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
</feed>
